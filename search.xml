<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>SpringMVC拦截器</title>
      <link href="/2017/08/14/SpringMVC%E6%8B%A6%E6%88%AA%E5%99%A8/"/>
      <url>/2017/08/14/SpringMVC%E6%8B%A6%E6%88%AA%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="SpringMVC-拦截器的原理图"><a href="#SpringMVC-拦截器的原理图" class="headerlink" title="SpringMVC 拦截器的原理图"></a>SpringMVC 拦截器的原理图</h1><p> <img src="http://i.imgur.com/IXPPwYv.png" alt=""><br>注意postHandle方法的执行顺序与定义顺序正好相反。</p><h1 id="springMVC拦截器的实现一般有两种方式"><a href="#springMVC拦截器的实现一般有两种方式" class="headerlink" title="springMVC拦截器的实现一般有两种方式"></a>springMVC拦截器的实现一般有两种方式</h1><ol><li>第一种方式是要定义的Interceptor类要实现了Spring的HandlerInterceptor 接口，或者子接口如WebRequestInterceptor</li><li><p>第二种方式是继承实现了HandlerInterceptor接口的类，比如Spring已经提供的实现了HandlerInterceptor接口的抽象类HandlerInterceptorAdapter.</p><a id="more"></a><p>HandlerInterceptor 接口中定义了三个方法，我们就是通过这三个方法来对用户的请求进行拦截处理的。流程：<br><img src="http://i.imgur.com/GGUBVhn.png" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringMVCInterceptor</span> <span class="keyword">implements</span> <span class="title">HandlerInterceptor</span> </span>&#123;  </span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * preHandle方法是进行处理器拦截用的，顾名思义，该方法将在Controller处理之前进行调用，SpringMVC中的Interceptor拦截器是链式的，可以同时存在 </span></span><br><span class="line"><span class="comment">     * 多个Interceptor，然后SpringMVC会根据声明的前后顺序一个接一个的执行，而且所有的Interceptor中的preHandle方法都会在 </span></span><br><span class="line"><span class="comment">     * Controller方法调用之前调用。SpringMVC的这种Interceptor链式结构也是可以进行中断的，这种中断方式是令preHandle的返 </span></span><br><span class="line"><span class="comment">     * 回值为false，当preHandle的返回值为false的时候整个请求就结束了。 </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request,  </span></span></span><br><span class="line"><span class="function"><span class="params">            HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception </span>&#123;  </span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub  </span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 这个方法只会在当前这个Interceptor的preHandle方法返回值为true的时候才会执行。postHandle是进行处理器拦截用的，它的执行时间是在处理器进行处理之 </span></span><br><span class="line"><span class="comment">     * 后，也就是在Controller的方法调用之后执行，但是它会在DispatcherServlet进行视图的渲染之前执行，也就是说在这个方法中你可以对ModelAndView进行操 </span></span><br><span class="line"><span class="comment">     * 作。这个方法的链式结构跟正常访问的方向是相反的，也就是说先声明的Interceptor拦截器该方法反而会后调用，这跟Struts2里面的拦截器的执行过程有点像， </span></span><br><span class="line"><span class="comment">     * 只是Struts2里面的intercept方法中要手动的调用ActionInvocation的invoke方法，Struts2中调用ActionInvocation的invoke方法就是调用下一个Interceptor </span></span><br><span class="line"><span class="comment">     * 或者是调用action，然后要在Interceptor之前调用的内容都写在调用invoke之前，要在Interceptor之后调用的内容都写在调用invoke方法之后。 </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postHandle</span><span class="params">(HttpServletRequest request,  </span></span></span><br><span class="line"><span class="function"><span class="params">            HttpServletResponse response, Object handler,  </span></span></span><br><span class="line"><span class="function"><span class="params">            ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception </span>&#123;  </span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub  </span></span><br><span class="line">          </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 该方法也是需要当前对应的Interceptor的preHandle方法的返回值为true时才会执行。该方法将在整个请求完成之后，也就是DispatcherServlet渲染了视图执行， </span></span><br><span class="line"><span class="comment">     * 这个方法的主要作用是用于清理资源的，当然这个方法也只能在当前这个Interceptor的preHandle方法的返回值为true时才会执行。 </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterCompletion</span><span class="params">(HttpServletRequest request,  </span></span></span><br><span class="line"><span class="function"><span class="params">            HttpServletResponse response, Object handler, Exception ex)</span>  </span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> Exception </span>&#123;  </span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub  </span></span><br><span class="line">          </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>preHandle：预处理回调方法，实现处理器的预处理（如登录检查），第三个参数为响应的处理器（如我们上一章的Controller实现）；<br>  返回值：true表示继续流程（如调用下一个拦截器或处理器）；</p><pre><code>false表示流程中断（如登录检查失败），不会继续调用其他的拦截器或处理器，此时我们需要通过response来产生响应；</code></pre></li><li>postHandle：后处理回调方法，实现处理器的后处理（但在渲染视图之前），此时我们可以通过modelAndView（模型和视图对象）对模型数据进行处理或对视图进行处理，modelAndView也可能为null。</li><li>afterCompletion：整个请求处理完毕回调方法，即在视图渲染完毕时回调，如性能监控中我们可以在此记录结束时间并输出消耗时间，还可以进行一些资源清理，类似于try-catch-finally中的finally，但仅调用处理器执行链中preHandle返回true的拦截器的afterCompletion。<h2 id="实例1：SpringMVC拦截器实现登录认证"><a href="#实例1：SpringMVC拦截器实现登录认证" class="headerlink" title="实例1：SpringMVC拦截器实现登录认证"></a>实例1：SpringMVC拦截器实现登录认证</h2>控制器<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 登录认证的控制器 </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="meta">@Controller</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginControl</span> </span>&#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 登录 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> session </span></span><br><span class="line"><span class="comment">     *          HttpSession </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> username </span></span><br><span class="line"><span class="comment">     *          用户名 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> password </span></span><br><span class="line"><span class="comment">     *          密码 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="meta">@RequestMapping</span>(value=<span class="string">"/login"</span>)  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">login</span><span class="params">(HttpSession session,String username,String password)</span> <span class="keyword">throws</span> Exception</span>&#123;        </span><br><span class="line">        <span class="comment">//在Session里保存信息  </span></span><br><span class="line">        session.setAttribute(<span class="string">"username"</span>, username);  </span><br><span class="line">        <span class="comment">//重定向  </span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"redirect:hello.action"</span>;   </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 退出系统 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> session </span></span><br><span class="line"><span class="comment">     *          Session </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="meta">@RequestMapping</span>(value=<span class="string">"/logout"</span>)  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">logout</span><span class="params">(HttpSession session)</span> <span class="keyword">throws</span> Exception</span>&#123;  </span><br><span class="line">        <span class="comment">//清除Session  </span></span><br><span class="line">        session.invalidate();  </span><br><span class="line">          </span><br><span class="line">        <span class="keyword">return</span> <span class="string">"redirect:hello.action"</span>;  </span><br><span class="line">    &#125;       </span><br><span class="line">&#125; </span><br><span class="line">```   </span><br><span class="line">拦截器：</span><br><span class="line">```java</span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 登录认证的拦截器 </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginInterceptor</span> <span class="keyword">implements</span> <span class="title">HandlerInterceptor</span></span>&#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * Handler执行完成之后调用这个方法 </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterCompletion</span><span class="params">(HttpServletRequest request,  </span></span></span><br><span class="line"><span class="function"><span class="params">            HttpServletResponse response, Object handler, Exception exc)</span>  </span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> Exception </span>&#123;  </span><br><span class="line">          </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * Handler执行之后，ModelAndView返回之前调用这个方法 </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response,  </span></span></span><br><span class="line"><span class="function"><span class="params">            Object handler, ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception </span>&#123;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * Handler执行之前调用这个方法 </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response,  </span></span></span><br><span class="line"><span class="function"><span class="params">            Object handler)</span> <span class="keyword">throws</span> Exception </span>&#123;  </span><br><span class="line">        <span class="comment">//获取请求的URL  </span></span><br><span class="line">        String url = request.getRequestURI();  </span><br><span class="line">        <span class="comment">//URL:login.jsp是公开的;这个demo是除了login.jsp是可以公开访问的，其它的URL都进行拦截控制  </span></span><br><span class="line">        <span class="keyword">if</span>(url.indexOf(<span class="string">"login.action"</span>)&gt;=<span class="number">0</span>)&#123;  </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="comment">//获取Session  </span></span><br><span class="line">        HttpSession session = request.getSession();  </span><br><span class="line">        String username = (String)session.getAttribute(<span class="string">"username"</span>);  </span><br><span class="line">          </span><br><span class="line">        <span class="keyword">if</span>(username != <span class="keyword">null</span>)&#123;  </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="comment">//不符合条件的，跳转到登录界面  </span></span><br><span class="line">        request.getRequestDispatcher(<span class="string">"/WEB-INF/jsp/login.jsp"</span>).forward(request, response);  </span><br><span class="line">          </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;  </span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>在spring的配置文件中配置这个拦截器</p><pre><code class="xml"><span class="comment">&lt;!-- 拦截器 --&gt;</span>          <span class="tag">&lt;<span class="name">mvc:interceptors</span>&gt;</span>              <span class="comment">&lt;!-- 多个拦截器，顺序执行 --&gt;</span>              <span class="tag">&lt;<span class="name">mvc:interceptor</span>&gt;</span>                  <span class="tag">&lt;<span class="name">mvc:mapping</span> <span class="attr">path</span>=<span class="string">"/**"</span>/&gt;</span>                  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"com.mvc.interceptor.LoginInterceptor"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span>              <span class="tag">&lt;/<span class="name">mvc:interceptor</span>&gt;</span>          <span class="tag">&lt;/<span class="name">mvc:interceptors</span>&gt;</span></code></pre><p>此外，也可在postHandle和afterCompletion中定义拦截逻辑，其中postHandle处理尚未渲染的ModelAndView数据，afterCompletion中处理后置的一些验证等操作.</p><h2 id="实例2-性能监控"><a href="#实例2-性能监控" class="headerlink" title="实例2 性能监控"></a>实例2 性能监控</h2><p>如记录一下请求的处理时间，得到一些慢请求（如处理时间超过500毫秒），从而进行性能改进，一般的反向代理服务器如apache都具有这个功能，但此处我们演示一下使用拦截器怎么实现。<br>实现分析：<br>1、在进入处理器之前记录开始时间，即在拦截器的preHandle记录开始时间；<br>2、在结束请求处理之后记录结束时间，即在拦截器的afterCompletion记录结束实现，并用结束时间-开始时间得到这次请求的处理时间。<br>问题：<br>我们的拦截器是单例，因此不管用户请求多少次都只有一个拦截器实现，即线程不安全，那我们应该怎么记录时间呢？<br>解决方案是使用ThreadLocal，它是线程绑定的变量，提供线程局部变量（一个线程一个ThreadLocal，A线程的ThreadLocal只能看到A线程的ThreadLocal，不能看到B线程的ThreadLocal）。</p><pre><code class="java"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StopWatchHandlerInterceptor</span> <span class="keyword">extends</span> <span class="title">HandlerInterceptorAdapter</span> </span>{      <span class="keyword">private</span> NamedThreadLocal&lt;Long&gt;  startTimeThreadLocal =   <span class="keyword">new</span> NamedThreadLocal&lt;Long&gt;(<span class="string">"StopWatch-StartTime"</span>);      <span class="meta">@Override</span>      <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response,   </span></span><span class="function"><span class="params">Object handler)</span> <span class="keyword">throws</span> Exception </span>{          <span class="keyword">long</span> beginTime = System.currentTimeMillis();<span class="comment">//1、开始时间  </span>        startTimeThreadLocal.set(beginTime);<span class="comment">//线程绑定变量（该数据只有当前请求的线程可见）  </span>        <span class="keyword">return</span> <span class="keyword">true</span>;<span class="comment">//继续流程  </span>    }      <span class="meta">@Override</span>      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response,   </span></span><span class="function"><span class="params">Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception </span>{          <span class="keyword">long</span> endTime = System.currentTimeMillis();<span class="comment">//2、结束时间  </span>        <span class="keyword">long</span> beginTime = startTimeThreadLocal.get();<span class="comment">//得到线程绑定的局部变量（开始时间）  </span>        <span class="keyword">long</span> consumeTime = endTime - beginTime;<span class="comment">//3、消耗的时间  </span>        <span class="keyword">if</span>(consumeTime &gt; <span class="number">500</span>) {<span class="comment">//此处认为处理时间超过500毫秒的请求为慢请求  </span>            <span class="comment">//TODO 记录到日志文件  </span>            System.out.println(  String.format(<span class="string">"%s consume %d millis"</span>, request.getRequestURI(), consumeTime));          }              }  }</code></pre><p>NamedThreadLocal：Spring提供的一个命名的ThreadLocal实现。<br>在测试时需要把stopWatchHandlerInterceptor放在拦截器链的第一个，这样得到的时间才是比较准确的。</p>]]></content>
      
      
      <categories>
          
          <category> spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
            <tag> 拦截器 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>java源码--ArrayDeque</title>
      <link href="/2017/08/14/java%E6%BA%90%E7%A0%81-ArrayDeque/"/>
      <url>/2017/08/14/java%E6%BA%90%E7%A0%81-ArrayDeque/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>Deque意为双端队列，ArrayDeque显然是基于数组实现的双端队列，而且作为双端队列时，效率比LinkList高。而且其特性使它还可以当做栈来使用，效率比Stack高。<br>ArrayDeque是非线程安全的（not thread-safe），当多个线程同时使用的时候，需要程序员手动同步；另外，该容器不允许放入null元素。<br><img src="http://i.imgur.com/SRn9K5h.png" alt=""><br><a id="more"></a><br>继承体系：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayDeque</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractCollection</span>&lt;<span class="title">E</span>&gt;  </span></span><br><span class="line"><span class="class">                           <span class="keyword">implements</span> <span class="title">Deque</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure></p><h1 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h1><p>从内部存储上，可以看到内部只有一个数组<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 底层用数组存储元素  </span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">transient</span> E[] elements;  </span><br><span class="line"> <span class="comment">// 队列的头部元素索引（即将pop出的一个）  </span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> head;  </span><br><span class="line"> <span class="comment">// 队列下一个要添加的元素索引 ，注意是下一个，不是最后一个元素</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> tail;  </span><br><span class="line"> <span class="comment">// 最小的初始化容量大小，需要为2的n次幂  </span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_INITIAL_CAPACITY = <span class="number">8</span>;</span><br></pre></td></tr></table></figure></p><p><img src="http://i.imgur.com/sxw4t8w.png" alt=""><br>上图中我们看到，head指向首端第一个有效元素，tail指向尾端第一个可以插入元素的空位，不是当前数组的元素位置。<br>因为是循环数组，所以head不一定总等于0，tail也不一定总是比head大。</p><h1 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 默认构造方法，数组的初始容量为16 </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayDeque</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    elements = (E[]) <span class="keyword">new</span> Object[<span class="number">16</span>];  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 使用一个指定的初始容量构造一个ArrayDeque,但是最终分配的容量并不是numElements，初始容量是大于指定numElements的最小的2的n次幂 </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayDeque</span><span class="params">( <span class="keyword">int</span> numElements)</span> </span>&#123;  </span><br><span class="line">    allocateElements(numElements);  </span><br><span class="line">&#125;  </span><br><span class="line">   </span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 构造一个指定Collection集合参数的ArrayDeque </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayDeque</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;  </span><br><span class="line">    allocateElements(c.size());  </span><br><span class="line">    addAll(c);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>allocateElements()是什么东西呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">    * 分配合适容量大小的数组，确保初始容量是大于指定numElements的最小的2的n次幂 </span></span><br><span class="line"><span class="comment">    */</span>  </span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">allocateElements</span><span class="params">(<span class="keyword">int</span> numElements)</span> </span>&#123;  </span><br><span class="line">       <span class="keyword">int</span> initialCapacity = MIN_INITIAL_CAPACITY;  <span class="comment">//初始容量为8</span></span><br><span class="line">       <span class="comment">// 找到大于指定容量的最小的2的n次幂  </span></span><br><span class="line">       <span class="comment">// Find the best power of two to hold elements.  </span></span><br><span class="line">       <span class="comment">// Tests "&lt;=" because arrays aren't kept full.  </span></span><br><span class="line">       <span class="comment">// 如果指定的容量小于初始容量8，则执行一下if中的逻辑操作  </span></span><br><span class="line">       <span class="keyword">if</span> (numElements &gt;= initialCapacity) &#123;  </span><br><span class="line">           initialCapacity = numElements;  </span><br><span class="line">           initialCapacity |= (initialCapacity &gt;&gt;&gt;  <span class="number">1</span>);  </span><br><span class="line">           initialCapacity |= (initialCapacity &gt;&gt;&gt;  <span class="number">2</span>);  </span><br><span class="line">           initialCapacity |= (initialCapacity &gt;&gt;&gt;  <span class="number">4</span>);  </span><br><span class="line">           initialCapacity |= (initialCapacity &gt;&gt;&gt;  <span class="number">8</span>);  </span><br><span class="line">           initialCapacity |= (initialCapacity &gt;&gt;&gt; <span class="number">16</span>);  </span><br><span class="line">           initialCapacity++;  </span><br><span class="line">  </span><br><span class="line">           <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)   <span class="comment">// Too many elements, must back off  </span></span><br><span class="line">               initialCapacity &gt;&gt;&gt;= <span class="number">1</span>; <span class="comment">// Good luck allocating 2 ^ 30 elements  </span></span><br><span class="line">       &#125;  </span><br><span class="line">      elements = (E[]) <span class="keyword">new</span> Object[initialCapacity];  </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>此方法是给数组分配初始容量，初始容量并不是numElements，而是大于指定长度的最小的2的幂正数<br>所以ArrayDeque的容量一定是2的幂整数.至于这是为什么，应该是计算机内存分配的关系吧。2的幂次方页空间分配的更快。（个人猜测）</p><h1 id="重要方法"><a href="#重要方法" class="headerlink" title="重要方法"></a>重要方法</h1><h2 id="入队（添加元素到队尾）"><a href="#入队（添加元素到队尾）" class="headerlink" title="入队（添加元素到队尾）"></a>入队（添加元素到队尾）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 增加一个元素，如果队列已满，则抛出一个IIIegaISlabEepeplian异常 </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;  </span><br><span class="line">        <span class="comment">// 调用addLast方法，将元素添加到队尾  </span></span><br><span class="line">        addLast(e);  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">* 把元素填入到队列前端.即在head的前面添加元素 </span><br><span class="line">*/  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFirst</span><span class="params">(E e)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>)  <span class="comment">//允许插入空值</span></span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();  </span><br><span class="line">   elements[head = (head - <span class="number">1</span>) &amp; (elements.length - <span class="number">1</span>)] = e;  </span><br><span class="line">   <span class="keyword">if</span> (head == tail)  <span class="comment">//表示队列已经满了</span></span><br><span class="line">       doubleCapacity();  <span class="comment">//扩充容量</span></span><br><span class="line">&#125;</span><br><span class="line">      <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 将元素添加到队尾 </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addLast</span><span class="params">(E e)</span> </span>&#123;  </span><br><span class="line">       <span class="comment">// 如果元素为null，咋抛出空指针异常  </span></span><br><span class="line">       <span class="keyword">if</span> (e == <span class="keyword">null</span>)  </span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();  </span><br><span class="line">       <span class="comment">// 将元素e放到数组的tail位置  </span></span><br><span class="line">        elements[tail] = e;  </span><br><span class="line">        <span class="comment">// 判断tail和head是否相等，如果相等则对数组进行扩容  </span></span><br><span class="line">        <span class="keyword">if</span> ( (tail = (tail + <span class="number">1</span>) &amp; ( elements.length - <span class="number">1</span>)) == head)  </span><br><span class="line">            <span class="comment">// 进行两倍扩容  </span></span><br><span class="line">           doubleCapacity();  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 添加一个元素 </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;  </span><br><span class="line">        <span class="comment">// 调用offerLast方法，将元素添加到队尾  </span></span><br><span class="line">        <span class="keyword">return</span> offerLast(e);  </span><br><span class="line">    &#125;  </span><br><span class="line">     <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * Inserts the specified element at the front of this deque. </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offerFirst</span><span class="params">(E e)</span> </span>&#123;  </span><br><span class="line">        addFirst(e);  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;  </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 在队尾添加一个元素 </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offerLast</span><span class="params">(E e)</span> </span>&#123;  </span><br><span class="line">        <span class="comment">// 调用addLast方法，将元素添加到队尾  </span></span><br><span class="line">        addLast(e);  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="addFirst"><a href="#addFirst" class="headerlink" title="addFirst()"></a>addFirst()</h2><p>addFirst(E e)的作用是在Deque的首端插入元素，也就是在head的前面插入元素，在空间足够且下标没有越界的情况下，只需要将elements[–head] = e即可。<br><img src="http://i.imgur.com/6oMsBPQ.png" alt=""><br>实际需要考虑：1.空间是否够用 2.下标是否越界的问题。上图中，如果head为0之后接着调用addFirst()，虽然空余空间还够用，但head为-1，下标越界了。下列代码很好的解决了这两个问题.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">* 把元素填入到队列前端.即在head的前面添加元素 </span><br><span class="line">*/  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFirst</span><span class="params">(E e)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>)  <span class="comment">//允许插入空值</span></span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();  </span><br><span class="line">   elements[head = (head - <span class="number">1</span>) &amp; (elements.length - <span class="number">1</span>)] = e;  </span><br><span class="line">   <span class="keyword">if</span> (head == tail)  <span class="comment">//表示队列已经满了</span></span><br><span class="line">       doubleCapacity();  <span class="comment">//扩充容量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码我们看到，空间问题是在插入之后解决的，因为tail总是指向下一个可插入的空位，也就意味着elements数组至少有一个空位，所以插入元素的时候不用考虑空间问题。<br>下标越界的处理解决起来非常简单，head = (head - 1) &amp; (elements.length - 1)就可以了，这段代码相当于取余，同时解决了head为负值的情况。因为elements.length必需是2的指数倍，elements - 1就是二进制低位全1，跟head - 1相与之后就起到了取模的作用，如果head - 1为负数（其实只可能是-1），则相当于对其取相对于elements.length的补码。<br>比如说，如果elements.length为8，则(elements.length - 1)为7，二进制为0111，对于负数-1，与7相与，结果为7，对于正数8，与7相与，结果为0，都能达到循环数组中找下一个正确位置的目的。<br>对于取与操作而言，有下面的结论：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">记mod = elements.length = 2^k, a为[-1,module+1]之间的一个整数，那么有：  </span><br><span class="line">  </span><br><span class="line">a == -1:  </span><br><span class="line">a &amp; (mod-1) == mod - 1;  </span><br><span class="line">0 &lt;= a &lt; mod:  </span><br><span class="line">a &amp; (mod - 1) == a  </span><br><span class="line">a == mod:  </span><br><span class="line">a &amp; (mod - 1) == 0</span><br></pre></td></tr></table></figure></p><p>下面再说说扩容函数doubleCapacity()，其逻辑是申请一个更大的数组（原数组的两倍），然后将原数组复制过去。过程如下图所示：<br> <img src="http://i.imgur.com/TXjfxNm.png" alt=""><br>图中我们看到，复制分两次进行，第一次复制head右边的元素，第二次复制head左边的元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/** 将队列的容量变成二倍</span></span><br><span class="line"><span class="comment"> * Doubles the capacity of this deque.  Call only when full, i.e., </span></span><br><span class="line"><span class="comment"> * when head and tail have wrapped around to become equal. </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doubleCapacity</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">assert</span> head == tail;  </span><br><span class="line">    <span class="keyword">int</span> p = head;  </span><br><span class="line">    <span class="keyword">int</span> n = elements.length;  </span><br><span class="line">    <span class="keyword">int</span> r = n - p; <span class="comment">// number of elements to the right of p  </span></span><br><span class="line">    <span class="keyword">int</span> newCapacity = n &lt;&lt; <span class="number">1</span>;  </span><br><span class="line">    <span class="keyword">if</span> (newCapacity &lt; <span class="number">0</span>)  </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Sorry, deque too big"</span>);  </span><br><span class="line">   Object[] a = <span class="keyword">new</span> Object[newCapacity];  </span><br><span class="line">    System.arraycopy(elements, p, a, <span class="number">0</span>, r);  </span><br><span class="line">    System.arraycopy(elements, <span class="number">0</span>, a, r, p);  </span><br><span class="line">    elements = a;  </span><br><span class="line">    head = <span class="number">0</span>;  </span><br><span class="line">   tail = n;</span><br></pre></td></tr></table></figure><h2 id="addLast"><a href="#addLast" class="headerlink" title="addLast()"></a>addLast()</h2><p>addLast(E e)的作用是在Deque的尾端插入元素，也就是在tail的位置插入元素，由于tail总是指向下一个可以插入的空位，因此只需要elements[tail] = e;即可。插入完成后再检查空间，如果空间已经用光，则调用doubleCapacity()进行扩容。<br> <img src="http://i.imgur.com/OMfipDU.png" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/** </span></span><br><span class="line"><span class="comment">  * Inserts the specified element at the end of this deque. </span></span><br><span class="line"><span class="comment">  */</span>  </span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addLast</span><span class="params">(E e)</span> </span>&#123;  </span><br><span class="line">     <span class="keyword">if</span> (e == <span class="keyword">null</span>)  </span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();  </span><br><span class="line">     elements[tail] = e;  </span><br><span class="line">     <span class="keyword">if</span> ( (tail = (tail + <span class="number">1</span>) &amp; (elements.length - <span class="number">1</span>)) == head) <span class="comment">//在tail位置后面加入元素 </span></span><br><span class="line">         doubleCapacity();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下标越界处理方式和addFirst()相同</p><h2 id="offerFirst-offerLast"><a href="#offerFirst-offerLast" class="headerlink" title="offerFirst(),offerLast()"></a>offerFirst(),offerLast()</h2><p>这两个方法从源码看的很清楚，与addxx()方法的区别就是:add()方法插入失败(插入一个null)会抛出异常，而offer()方法至于插入成功时才会返回true，可用于某些判断。</p><h2 id="出队（移除并返回队头元素）"><a href="#出队（移除并返回队头元素）" class="headerlink" title="出队（移除并返回队头元素）"></a>出队（移除并返回队头元素）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/** </span></span><br><span class="line"><span class="comment">   * 移除并返回队列头部的元素，如果队列为空，则抛出一个NoSuchElementException异常 </span></span><br><span class="line"><span class="comment">   */</span>  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">      <span class="comment">// 调用removeFirst方法，移除队头的元素  </span></span><br><span class="line">     <span class="keyword">return</span> removeFirst();  </span><br><span class="line">  &#125;  </span><br><span class="line"> </span><br><span class="line">  <span class="comment">/** </span></span><br><span class="line"><span class="comment">   * <span class="doctag">@throws</span> NoSuchElementException &#123;<span class="doctag">@inheritDoc</span>&#125; </span></span><br><span class="line"><span class="comment">   */</span>  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> E <span class="title">removeFirst</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">      <span class="comment">// 调用pollFirst方法，移除并返回队头的元素  </span></span><br><span class="line">      E x = pollFirst();  </span><br><span class="line">      <span class="comment">// 如果队列为空，则抛出NoSuchElementException异常  </span></span><br><span class="line">      <span class="keyword">if</span> (x == <span class="keyword">null</span>)  </span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();  </span><br><span class="line">      <span class="keyword">return</span> x;  </span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="comment">/** </span></span><br><span class="line"><span class="comment">  * <span class="doctag">@throws</span> NoSuchElementException &#123;<span class="doctag">@inheritDoc</span>&#125; </span></span><br><span class="line"><span class="comment">  */</span>  </span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">removeLast</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">     E x = pollLast();  </span><br><span class="line">    <span class="keyword">if</span> (x == <span class="keyword">null</span>)  </span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();  </span><br><span class="line">     <span class="keyword">return</span> x;  </span><br><span class="line"> &#125;     </span><br><span class="line">  <span class="comment">/** </span></span><br><span class="line"><span class="comment">   * 移除并返问队列头部的元素，如果队列为空，则返回null </span></span><br><span class="line"><span class="comment">   */</span>  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">      <span class="comment">// 调用pollFirst方法，移除并返回队头的元素  </span></span><br><span class="line">      <span class="keyword">return</span> pollFirst();  </span><br><span class="line">  &#125;  </span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> E <span class="title">pollFirst</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">     <span class="keyword">int</span> h = head ;  </span><br><span class="line">      <span class="comment">// 取出数组队头位置的元素  </span></span><br><span class="line">     E result = elements[h]; <span class="comment">// Element is null if deque empty  </span></span><br><span class="line">      <span class="comment">// 如果数组队头位置没有元素，则返回null值  </span></span><br><span class="line">      <span class="keyword">if</span> (result == <span class="keyword">null</span>)  </span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">null</span>;  </span><br><span class="line">      <span class="comment">// 将数组队头位置置空，也就是删除元素  </span></span><br><span class="line">     elements[h] = <span class="keyword">null</span>;     <span class="comment">// Must null out slot  </span></span><br><span class="line">      <span class="comment">// 将head指针往前移动一个位置  </span></span><br><span class="line">      head = (h + <span class="number">1</span>) &amp; (elements .length - <span class="number">1</span>);  </span><br><span class="line">      <span class="comment">// 将队头元素返回  </span></span><br><span class="line">      <span class="keyword">return</span> result;  </span><br><span class="line">  &#125;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">pollLast</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> t = (tail - <span class="number">1</span>) &amp; (elements.length - <span class="number">1</span>);  <span class="comment">//因为tail总是指向下一个队列元素，所以pollLast时候，实际取得是tail-1位置的元素</span></span><br><span class="line">     <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)  </span><br><span class="line">     E result = (E) elements[t];  </span><br><span class="line">     <span class="keyword">if</span> (result == <span class="keyword">null</span>)  <span class="comment">//null值意味着deque为空</span></span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">null</span>;  </span><br><span class="line">     elements[t] = <span class="keyword">null</span>;  </span><br><span class="line">     tail = t;  </span><br><span class="line">     <span class="keyword">return</span> result;  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>可以看到，remove方法和poll方法的区别是：如果没有出队元素(null)，remove方法抛出异常，而poll方法返回null;</p><h2 id="返回队列元素-不出队"><a href="#返回队列元素-不出队" class="headerlink" title="返回队列元素(不出队)"></a>返回队列元素(不出队)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     *  返回队列头部的元素，如果队列为空，则抛出一个NoSuchElementException异常 </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">element</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="comment">// 调用getFirst方法，获取队头的元素  </span></span><br><span class="line">        <span class="keyword">return</span> getFirst();  </span><br><span class="line">    &#125;  </span><br><span class="line">   </span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NoSuchElementException &#123;<span class="doctag">@inheritDoc</span>&#125; </span></span><br><span class="line"><span class="comment">.     */</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">getFirst</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="comment">// 取得数组head位置的元素  </span></span><br><span class="line">        E x = elements[head ];  </span><br><span class="line">        <span class="comment">// 如果数组head位置的元素为null，则抛出异常  </span></span><br><span class="line">        <span class="keyword">if</span> (x == <span class="keyword">null</span>)  </span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();  </span><br><span class="line">        <span class="keyword">return</span> x;  </span><br><span class="line">    &#125;  </span><br><span class="line">     <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NoSuchElementException &#123;<span class="doctag">@inheritDoc</span>&#125; </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">getLast</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)  </span><br><span class="line">        E result = (E) elements[(tail - <span class="number">1</span>) &amp; (elements.length - <span class="number">1</span>)];  </span><br><span class="line">        <span class="keyword">if</span> (result == <span class="keyword">null</span>)  </span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();  </span><br><span class="line">        <span class="keyword">return</span> result;  </span><br><span class="line">    &#125;  </span><br><span class="line">   </span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 返回队列头部的元素，如果队列为空，则返回null </span></span><br><span class="line"><span class="comment">     .     */</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">peek</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="comment">// 调用peekFirst方法，获取队头的元素  </span></span><br><span class="line">        <span class="keyword">return</span> peekFirst();  </span><br><span class="line">    &#125;  </span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">peekFirst</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">       <span class="comment">// 取得数组head位置的元素并返回  </span></span><br><span class="line">        <span class="keyword">return</span> elements [head]; <span class="comment">// elements[head] is null if deque empty  </span></span><br><span class="line">    &#125;  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> E <span class="title">peekLast</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">      <span class="keyword">return</span> (E) elements[(tail - <span class="number">1</span>) &amp; (elements.length - <span class="number">1</span>)];  </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>get()和peek()方法的区别在于：get()方法取到的元素是null(队列为空)时，抛出异常，而peek()方法返回null;</p><h2 id="push-pop"><a href="#push-pop" class="headerlink" title="push(),pop()"></a>push(),pop()</h2><p>显而易见的操作，把ArrayDeque当做堆栈使用时，push()即为在head处插入元素，pop（）即为删除head处元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(E e)</span> </span>&#123;  </span><br><span class="line">        addFirst(e);  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">pop</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> removeFirst();  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">    * Returns the number of elements in this deque. </span></span><br><span class="line"><span class="comment">    */</span>  </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">       <span class="keyword">return</span> (tail - head) &amp; (elements.length - <span class="number">1</span>);  </span><br><span class="line">   &#125;  </span><br><span class="line">     <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * Returns an array containing all of the elements in this deque </span></span><br><span class="line"><span class="comment">     * in proper sequence (from first to last element). </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="keyword">public</span> Object[] toArray() &#123;  </span><br><span class="line">        <span class="keyword">return</span> copyElements(<span class="keyword">new</span> Object[size()]);  </span><br><span class="line">   &#125;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;<span class="comment">//清空操作    </span></span><br><span class="line">    <span class="keyword">int</span> h = head;    </span><br><span class="line">    <span class="keyword">int</span> t = tail;    </span><br><span class="line">   <span class="keyword">if</span> (h != t) &#123; <span class="comment">// head != tail 表示队列元素 不为空    </span></span><br><span class="line">       head = tail = <span class="number">0</span>;<span class="comment">//设置head 和 tail 初始状态    </span></span><br><span class="line">        <span class="keyword">int</span> i = h;    </span><br><span class="line">        <span class="keyword">int</span> mask = elements.length - <span class="number">1</span>;    </span><br><span class="line">        <span class="keyword">do</span> &#123;    </span><br><span class="line">            elements[i] = <span class="keyword">null</span>;<span class="comment">//配合循环将所有元素设置为null    </span></span><br><span class="line">           i = (i + <span class="number">1</span>) &amp; mask;    </span><br><span class="line">        &#125; <span class="keyword">while</span> (i != t);    </span><br><span class="line">    &#125;    </span><br><span class="line">&#125;    </span><br><span class="line"><span class="comment">//遍历集合，正向遍历,从head -- tail</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> DeqIterator();  </span><br><span class="line">   &#125;  </span><br><span class="line"><span class="comment">//反向遍历</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">descendingIterator</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> DescendingIterator();  </span><br><span class="line">   &#125;  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;<span class="comment">//判断队列是否包含该元素    </span></span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>)    </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;    </span><br><span class="line">    <span class="keyword">int</span> mask = elements.length - <span class="number">1</span>;    </span><br><span class="line">    <span class="keyword">int</span> i = head;    </span><br><span class="line">    E x;    </span><br><span class="line">    <span class="keyword">while</span> ( (x = elements[i]) != <span class="keyword">null</span>) &#123;<span class="comment">//从head元素向后猪哥判断,是否equals    </span></span><br><span class="line">        <span class="keyword">if</span> (o.equals(x))    </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;    </span><br><span class="line">        i = (i + <span class="number">1</span>) &amp; mask;    </span><br><span class="line">   &#125;    </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;    </span><br><span class="line">&#125;    </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;<span class="comment">//获取队列元素个数,(tail - head) &amp; (elements.length - 1)保证大小在有效范围内。    </span></span><br><span class="line">        <span class="keyword">return</span> (tail - head) &amp; (elements.length - <span class="number">1</span>);    </span><br><span class="line">    &#125;    </span><br><span class="line">    </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;<span class="comment">//入队操作,tail+=1;出队操作head+=1;当一直出队元素的时候,head一直+，会==tail,此时head==tail都指向null元素。    </span></span><br><span class="line">        <span class="keyword">return</span> head == tail;    </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java源码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> ArrayDeque </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>SpringMVC使用@ResponseBody返回json 中文乱码</title>
      <link href="/2017/08/10/SpringMVC-%E4%BD%BF%E7%94%A8-ResponseBody%E8%BF%94%E5%9B%9Ejson-%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81/"/>
      <url>/2017/08/10/SpringMVC-%E4%BD%BF%E7%94%A8-ResponseBody%E8%BF%94%E5%9B%9Ejson-%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<p>Spring中解析字符串的转换器默认编码居然是ISO-8859-1,如何处理utf-8中文字符<br>下面这都两个可以<br><a id="more"></a><br>方法一，使用（produces = “application/json; charset=utf-8”）：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(value=<span class="string">"/getUsersByPage"</span>,produces = <span class="string">"application/json; charset=utf-8"</span>)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getUsersByPage</span><span class="params">(String page,String rows,String text,HttpServletRequest request,HttpServletResponse response)</span></span>&#123;</span><br></pre></td></tr></table></figure></p><p>方法二，在spring-mvc.xml中添加：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 处理请求返回json字符串的中文乱码问题 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:annotation-driven</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mvc:message-converters</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.http.converter.StringHttpMessageConverter"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"supportedMediaTypes"</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">value</span>&gt;</span>application/json;charset=UTF-8<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">mvc:message-converters</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mvc:annotation-driven</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>以上两种方式经过验证都没有问题。</p>]]></content>
      
      
      <categories>
          
          <category> spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springmvc </tag>
            
            <tag> json </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>SpringMVC 使用HandlerMethodArgumentResolver自定义解析器实现请求数据绑定方法入参</title>
      <link href="/2017/08/07/SpringMVC%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3%E5%92%8C%E6%8B%A6%E6%88%AA%E5%99%A8%E5%AE%9E%E7%8E%B0%E7%94%A8%E6%88%B7%E8%A1%8C%E4%B8%BA%E9%AA%8C%E8%AF%81/"/>
      <url>/2017/08/07/SpringMVC%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3%E5%92%8C%E6%8B%A6%E6%88%AA%E5%99%A8%E5%AE%9E%E7%8E%B0%E7%94%A8%E6%88%B7%E8%A1%8C%E4%B8%BA%E9%AA%8C%E8%AF%81/</url>
      
        <content type="html"><![CDATA[<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>首先，我们遇到的问题是，当我们需要在controller中频繁的从session中获取数据，比如向下面这样<br>在controller中需要从session中获取user对象，那么可能你会想到在controller里面或者其他类里面写这样的代码，然后在controller里面调用….<br><a id="more"></a><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">getLoginUser</span><span class="params">(HttpServletRequest request)</span> </span>&#123;  </span><br><span class="line">        HttpSession session = request.getSession();  </span><br><span class="line">        <span class="keyword">return</span> (User) session.getAttribute(<span class="string">"user"</span>);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>总感觉特别的不好…<br>现在如果我们看了下面介绍的HandlerMethodArgumentResolver自定义解析器实现的请求数据绑定方法入参，你就会看到像下面的代码只需要一个注解就能解决上面的问题↓<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/index"</span>)  </span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">index</span><span class="params">(@MyUser User user,ModelMap modelMap)</span></span>&#123;  </span><br><span class="line">    logger.info(user.getUsername()+<span class="string">"---------------------------"</span>);  </span><br><span class="line">    <span class="keyword">return</span> <span class="string">"login"</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="用HandlerMethodArgumentResolver解决"><a href="#用HandlerMethodArgumentResolver解决" class="headerlink" title="用HandlerMethodArgumentResolver解决"></a>用HandlerMethodArgumentResolver解决</h1><p>首先，我们需要知道一点的就是SpringMVC的工作流程，SpringMVC的DispatchServlet会根据请求来找到对应的HandlerMapping，最终spring会选择用RequestMappingHandlerMapping，然后根据RequestMappingHandlerMapping来获取HandlerMethod，然后来找支持的HandlerMethodArgumentResolver来处理对应controller的方法的入参。<br>首先，我们需要做的就是创建一个Annotation<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.PARAMETER)  </span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)  </span><br><span class="line"><span class="meta">@Documented</span> </span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyUser &#123;  </span><br><span class="line">  <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后我们要做的就是创建一个MyUserMethodArgumentResolver这个类来实现HandlerMethodArgumentResolver这个接口<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyUserMethodArgumentResolver</span> <span class="keyword">implements</span> <span class="title">HandlerMethodArgumentResolver</span> </span>&#123;  </span><br><span class="line"><span class="meta">@Override</span>  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supportsParameter</span><span class="params">(MethodParameter methodParameter)</span> </span>&#123;  </span><br><span class="line">      <span class="keyword">return</span> methodParameter.hasParameterAnnotation(ManyUser.class);  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="meta">@Override</span>  </span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">resolveArgument</span><span class="params">(MethodParameter methodParameter, ModelAndViewContainer   modelAndViewContainer, NativeWebRequest nativeWebRequest, WebDataBinderFactory webDataBinderFactory)</span> <span class="keyword">throws</span> Exception </span>&#123;  </span><br><span class="line"><span class="number">8</span>.         <span class="comment">//直接返回request域对象的user</span></span><br><span class="line"><span class="number">9</span>.        <span class="keyword">return</span> nativeWebRequest.getAttribute(<span class="string">"user"</span>, NativeWebRequest.SCOPE_REQUEST);;  </span><br><span class="line"><span class="number">10</span>.        <span class="comment">//或者这里你也可以直接返回自己创建的User对象 </span></span><br><span class="line"><span class="number">11</span>.        <span class="comment">/* </span></span><br><span class="line"><span class="comment">12.            User user = new User(); </span></span><br><span class="line"><span class="comment">13.            user.setUsername("yangpeng"); </span></span><br><span class="line"><span class="comment">14.            return user; </span></span><br><span class="line"><span class="comment">15.          */</span>  </span><br><span class="line"><span class="number">16</span>.         <span class="comment">/**自定义实现，比如参数是很多用户：如    custom?names=lyncc,fly,ted&amp;ids=1,2,3</span></span><br><span class="line"><span class="comment">17.   List&lt;User&gt; users = new ArrayList&lt;User&gt;();  </span></span><br><span class="line"><span class="comment">18.        String names = (String)webRequest.getParameter("names");  </span></span><br><span class="line"><span class="comment">19.        String ids = (String)webRequest.getParameter("ids");  </span></span><br><span class="line"><span class="comment">20.        if(null != names &amp;&amp; null != ids)&#123;  </span></span><br><span class="line"><span class="comment">21.            String[] nameStrs = names.trim().split(",");  </span></span><br><span class="line"><span class="comment">22.            String[] idStrs = ids.trim().split(",");  </span></span><br><span class="line"><span class="comment">23.            for(int i = 0;i&lt;nameStrs.length;i++)&#123;  </span></span><br><span class="line"><span class="comment">24.             User user = new User(Integer.parseInt(idStrs[i]), nameStrs[i]);</span></span><br><span class="line"><span class="comment">25.                users.add(user);  </span></span><br><span class="line"><span class="comment">26.            &#125;  </span></span><br><span class="line"><span class="comment">27.        &#125;  </span></span><br><span class="line"><span class="comment">28.        return users;  //返回list 例如注解式 <span class="doctag">@manyUser</span> List&lt;User&gt; users</span></span><br><span class="line"><span class="comment">29.    &#125;         </span></span><br><span class="line"><span class="comment">30.&#125;  &#125;</span></span><br></pre></td></tr></table></figure></p><p>Spring默认会注册多个HandlerMethodArgumentResolver来处理不同的请求，Spring会根据HandlerMethodArgumentResolver的supportsParameter()方法来判断是否支持处理当前请求。<br>第一个supportsParameter方法是判断这个MyUserMethodArgumentResolver是否支持传入的MethodParameter对象。<br>第二个resolveArgument方法是处理具体的需要绑定到方法入参，返回的对象就是需要绑定的对象，这里我是直接从session里面获取了一个user的对象直接返回，或者你也可以在这里直接创建一个User对象然后返回用于测试是一样的。<br>接下来就是在spring-mvc.xml中配置了</p><pre><code class="xml"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span>&gt;</span>     <span class="tag">&lt;<span class="name">mvc:argument-resolvers</span>&gt;</span>          <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"com.yp.code.common.bind.method.MyUserMethodArgumentResolver"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span>      <span class="tag">&lt;/<span class="name">mvc:argument-resolvers</span>&gt;</span>  <span class="tag">&lt;/<span class="name">mvc:annotation-driven</span>&gt;</span> </code></pre><p>最后就是使用创建的@MyUser这个Annotation来让SpringMVC自动的帮你绑定到Controller的方法里面了</p><pre><code class="java"><span class="meta">@RequestMapping</span>(<span class="string">"/index"</span>)  <span class="function"><span class="keyword">public</span> String <span class="title">index</span><span class="params">(@MyUser User user,ModelMap modelMap)</span></span>{      System.out.println(user.getUsername());      <span class="keyword">return</span> <span class="string">"login"</span>;  } </code></pre><p>这样就非常优雅的解决了上面的问题。</p>]]></content>
      
      
      <categories>
          
          <category> spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springmvc </tag>
            
            <tag> 自定义参数解析器 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>用@ExceptionHandler，@ControllerAdvice 来进行异常处理</title>
      <link href="/2017/08/05/%E7%94%A8-ExceptionHandler%EF%BC%8C-ControllerAdvice-%E6%9D%A5%E8%BF%9B%E8%A1%8C%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"/>
      <url>/2017/08/05/%E7%94%A8-ExceptionHandler%EF%BC%8C-ControllerAdvice-%E6%9D%A5%E8%BF%9B%E8%A1%8C%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>有时候我们想统一处理一个Controller中抛出的异常怎么搞呢？<br>直接在Controller里面加上用@ExceptionHandler标注一个处理异常的方法像下面这样子，@ExceptionHandler只在当前controller里面有效。当前controller中所有抛出指定异常的方法。<br><a id="more"></a><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>.<span class="meta">@ExceptionHandler</span>(MissingServletRequestParameterException.class)  </span><br><span class="line"><span class="number">2</span>.<span class="meta">@ResponseStatus</span>(HttpStatus.BAD_REQUEST)  </span><br><span class="line"><span class="number">3</span>.<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processMethod</span><span class="params">(MissingServletRequestParameterException ex,HttpServletRequest request ,HttpServletResponse response)</span> <span class="keyword">throws</span> IOException </span>&#123;  </span><br><span class="line"><span class="number">4</span>.    System.out.println(<span class="string">"抛异常了！"</span>+ex.getLocalizedMessage());  </span><br><span class="line"><span class="number">5</span>.    logger.error(<span class="string">"抛异常了！"</span>+ex.getLocalizedMessage());  </span><br><span class="line"><span class="number">6</span>.    response.getWriter().printf(ex.getMessage());  </span><br><span class="line"><span class="number">7</span>.    response.flushBuffer();  </span><br><span class="line">```  </span><br><span class="line">这样，Controller里面的方法抛出了MissingServletRequestParameterException异常就会执行上面的这个方法来进行异常处理。</span><br><span class="line">像我下面的代码`</span><br><span class="line">```java</span><br><span class="line"><span class="number">1</span>.<span class="meta">@RequestMapping</span>(<span class="string">"/index"</span>)  </span><br><span class="line"><span class="number">2</span>.<span class="function"><span class="keyword">public</span> String <span class="title">index</span><span class="params">(@RequestParam String id,ModelMap modelMap)</span></span>&#123;  </span><br><span class="line"><span class="number">3</span>.    <span class="keyword">if</span> (id==<span class="keyword">null</span>)&#123;</span><br><span class="line"><span class="number">4</span>.   <span class="keyword">throw</span> <span class="keyword">new</span> MissingServletRequestParameterException();</span><br><span class="line"><span class="number">5</span>.&#125;</span><br><span class="line"><span class="number">6</span>.    <span class="keyword">return</span> <span class="string">"login"</span>;  </span><br><span class="line"><span class="number">7</span>.&#125; </span><br><span class="line">``` </span><br><span class="line">如果我没有传入id值，那么就会抛出MissingServletRequestParameterException的异常，就会被上面的异常处理方法处理。</span><br><span class="line">上面的<span class="meta">@ExceptionHandler</span>(MissingServletRequestParameterException.class)这个注解的value的值是一个Class[]类型的，这里的ExceptionClass是你自己指定的，你也可以指定多个需要处理的异常类型，比如这样</span><br><span class="line"><span class="meta">@ExceptionHandler</span>(value = &#123;MissingServletRequestParameterException.class,BindException.class&#125;)，这样就会处理多个异常了。</span><br><span class="line">另一种更加通用的方法时：</span><br><span class="line">首先定义这样一个统一异常处理类</span><br><span class="line">```java</span><br><span class="line">ExceptionController.Java</span><br><span class="line"><span class="number">1</span>.<span class="keyword">import</span> net.sf.json.JSONObject;  </span><br><span class="line"><span class="number">2</span>.<span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ExceptionController</span> </span>&#123;  </span><br><span class="line"><span class="number">3</span>.    <span class="meta">@ExceptionHandler</span>  </span><br><span class="line"><span class="number">4</span>.    <span class="keyword">public</span> <span class="meta">@ResponseBody</span> <span class="function">String <span class="title">exceptionProcess</span><span class="params">(HttpServletRequest request, HttpServletResponse  </span></span></span><br><span class="line"><span class="function"><span class="params"><span class="number">5.</span>            response, RuntimeException ex)</span> </span>&#123;  </span><br><span class="line"><span class="number">6</span>.        JSONObject json = <span class="keyword">new</span> JSONObject();  </span><br><span class="line"><span class="number">7</span>.        json.put(<span class="string">"isError"</span>, <span class="keyword">true</span>);  </span><br><span class="line"><span class="number">8</span>.        json.put(<span class="string">"msg"</span>, ex.getMessage());  </span><br><span class="line"><span class="number">9</span>.        <span class="keyword">return</span> json.toString();  </span><br><span class="line"><span class="number">10</span>.    &#125;  </span><br><span class="line"><span class="number">11</span>.&#125;</span><br></pre></td></tr></table></figure></p><p>在需要进行统一处理的类中继承这个class</p><pre><code class="java"><span class="number">1</span>.    <span class="keyword">import</span> net.sf.json.JSONObject;  <span class="number">2</span>.    <span class="meta">@RequestMapping</span>(<span class="string">"/auth/customer"</span>)  <span class="number">3</span>.    <span class="meta">@Controller</span>  <span class="number">4</span>.    <span class="meta">@LoginAuth</span>  <span class="number">5</span>.    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomerController</span> <span class="keyword">extends</span> <span class="title">ExceptionController</span> </span>{  <span class="number">6</span>.        <span class="meta">@Resource</span>  <span class="number">7</span>.        <span class="keyword">private</span> CustomerService customerService;  <span class="number">8</span>.          <span class="number">9</span>.        <span class="comment">/** </span><span class="comment">10.         *  </span><span class="comment">11.         * <span class="doctag">@param</span> page 第几页，从1开始 </span><span class="comment">12.         * <span class="doctag">@param</span> rows 每页多少记录的行数 </span><span class="comment">13.         * <span class="doctag">@return</span> JSON String </span><span class="comment">14.         */</span>  <span class="number">15</span>.        <span class="meta">@RequestMapping</span>(<span class="string">"/querybypage"</span>)  <span class="number">16</span>.        <span class="meta">@ResponseBody</span>  <span class="number">17</span>.        <span class="function"><span class="keyword">public</span> String <span class="title">QueryByPage</span><span class="params">(<span class="keyword">int</span> page, <span class="keyword">int</span> rows)</span> </span>{  <span class="number">18</span>.            <span class="comment">//当为缺省值的时候进行赋值  </span><span class="number">19</span>.            <span class="keyword">int</span> currentpage = ( page == <span class="number">0</span>) ? <span class="number">1</span>: page;   <span class="comment">//第几页  </span><span class="number">20</span>.            <span class="keyword">int</span> pageSize = (rows == <span class="number">0</span>) ? <span class="number">5</span>: rows;   <span class="comment">//每页显示数量  </span><span class="number">21</span>.            <span class="keyword">int</span> index = (currentpage - <span class="number">1</span>) * pageSize;   <span class="comment">//从第几条开始显示  </span><span class="number">22</span>.            JSONObject map = customerService.queryByPage(index, pageSize);  <span class="number">23</span>.            <span class="keyword">return</span> map.toString();  <span class="number">24</span>.        }  <span class="number">25</span>.          <span class="number">26</span>.        <span class="meta">@RequestMapping</span>(<span class="string">"/test"</span>)  <span class="number">27</span>.        <span class="keyword">public</span> <span class="meta">@ResponseBody</span> <span class="function">Object <span class="title">test</span><span class="params">()</span> </span>{  <span class="number">28</span>.            JSONObject json = <span class="keyword">new</span> JSONObject();  <span class="number">29</span>.            json.put(<span class="string">"status"</span>, <span class="string">"success"</span>);  <span class="number">30</span>.            String str = <span class="keyword">null</span>;  <span class="number">31</span>.            str.toString();  <span class="number">32</span>.            <span class="keyword">return</span> json.toString();  <span class="number">33</span>.        }  <span class="number">34</span>.    } </code></pre><p>其中重要的一行是</p><ol><li>public class CustomerController extends ExceptionController<br>这样CustomController里的方法被访问的时候， 如果有异常，就会被exceptionProces()处理.因为继承之后，子类中都有这个标注的方法了。<br>但这个注解只会是在当前的Controller里面起作用，如果想在所有的Controller里面统一处理异常的话，可以用@ControllerAdvice来创建一个专门处理全局的的类。<br><code>`</code>java</li><li>@ControllerAdvice    </li><li>public class SpringExceptionHandler{    </li><li>/**  </li><li><ul><li>全局处理Exception  </li></ul></li><li><ul><li>错误的情况下返回500  </li></ul></li><li><ul><li>@param ex  </li></ul></li><li><ul><li>@param req  </li></ul></li><li><ul><li>@return  </li></ul></li><li>*/    </li><li>@ExceptionHandler(value = {Exception.class})    </li><li>public ResponseEntity<object> handleOtherExceptions(final Exception ex, final WebRequest req) {    </object></li><li>TResult tResult = new TResult();  //处理结果  </li><li>tResult.setStatus(CodeType.V_500);    </li><li>tResult.setErrorMessage(ex.getMessage());    </li><li>return new ResponseEntity<object>(tResult,HttpStatus.OK);    </object></li><li>}    </li><li>}<br><code>`</code><br>注意，这种注解在springmvc的配置文件中扫描是，要把@ControllerAdvice也包含进来，否则不起作用。<br>此外，@ControllerAdvice还可以用于全局的requestMapping，较少用。<br>参考：<a href="http://jinnianshilongnian.iteye.com/blog/1866350" target="_blank" rel="noopener">http://jinnianshilongnian.iteye.com/blog/1866350</a><br><a href="http://blog.csdn.net/u013632755/article/details/49908621" target="_blank" rel="noopener">http://blog.csdn.net/u013632755/article/details/49908621</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springmvc </tag>
            
            <tag> 异常处理 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>SpringMVC自定义注解和拦截器实现用户行为验证</title>
      <link href="/2017/08/01/SpringMVC%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3/"/>
      <url>/2017/08/01/SpringMVC%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>最近在进行项目开发的时候需要对接口做Session验证</p><h1 id="自定义一个注解-AuthCheckAnnotation"><a href="#自定义一个注解-AuthCheckAnnotation" class="headerlink" title="自定义一个注解@AuthCheckAnnotation"></a>自定义一个注解@AuthCheckAnnotation</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Target</span>(ElementType.METHOD)</span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> AuthCheckAnnotation &#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">check</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;<span class="comment">//默认不需要进行验证</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><h1 id="定义一个相应的拦截器，在springMVC配置文件中进行配置"><a href="#定义一个相应的拦截器，在springMVC配置文件中进行配置" class="headerlink" title="定义一个相应的拦截器，在springMVC配置文件中进行配置"></a>定义一个相应的拦截器，在springMVC配置文件中进行配置</h1><p>拦截器：<br>&emsp;spring为我们提供了org.springframework.web.servlet.handler.HandlerInterceptorAdapter这个适配器，继承此类，可以非常方便的实现自己的拦截器。可以根据我们的需要重写preHandle、postHandle、afterCompletio方法。<br>分别实现预处理、后处理（调用了Service并返回ModelAndView，但未进行页面渲染）、返回处理（已经渲染了页面）</p><ol><li>在preHandle中，可以进行编码、安全控制等处理；</li><li>在postHandle中，有机会修改ModelAndView；</li><li>在afterCompletion中，可以根据ex是否为null判断是否发生了异常，进行日志记录。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AuthCheckInteceptor</span> <span class="keyword">extends</span> <span class="title">HandlerInterceptorAdapter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    UserInfoService userInfoService ;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        </span><br><span class="line">        HandlerMethod methodHandler=(HandlerMethod) handler;</span><br><span class="line">        AuthCheckAnnotation auth=methodHandler.getMethodAnnotation(AuthCheckAnnotation.class);</span><br><span class="line">　　　　　<span class="comment">//如果方法中添加了@AuthCheckAnnotation 这里的auth不为null</span></span><br><span class="line">　　　　　<span class="comment">//如果@AuthCheckAnnotation(check=false) 这里的auth为false,即不用进行拦截验证，@AuthCheckAnnotation默认为前面定义的true　　</span></span><br><span class="line">        <span class="keyword">if</span>(auth!=<span class="keyword">null</span>&amp;&amp;!auth.check())&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;  </span><br><span class="line">        &#125;</span><br><span class="line">        UserInfo user=(UserInfo)request.getSession().getAttribute(Constants.SESSION_USER);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            userInfoService.login(request, user);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            request.getRequestDispatcher(<span class="string">"login.do"</span>).forward(request, response);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>在springMVC.xml文件中添加拦截器<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:interceptors</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mvc:mapping</span> <span class="attr">path</span>=<span class="string">"/*.do"</span>  /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span>  <span class="attr">class</span>=<span class="string">"com.party.common.interceptor.AuthCheckInteceptor"</span>/&gt;</span>        </span><br><span class="line">    <span class="tag">&lt;/<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mvc:interceptors</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h1 id="在springMVC-controller中使用实例"><a href="#在springMVC-controller中使用实例" class="headerlink" title="在springMVC controller中使用实例"></a>在springMVC controller中使用实例</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AuthCheckAnnotation</span>(check=<span class="keyword">true</span>)</span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"doLogin"</span>)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">doLogin</span><span class="params">(HttpServletRequest request,HttpServletResponse response)</span></span>&#123;</span><br><span class="line">    .......</span><br><span class="line">    <span class="keyword">return</span> RetMessage.toJson(responseBody);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>转：<a href="https://www.bbsmax.com/A/QV5Z1jwbJy/" target="_blank" rel="noopener">https://www.bbsmax.com/A/QV5Z1jwbJy/</a></p>]]></content>
      
      
      <categories>
          
          <category> spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springmvc </tag>
            
            <tag> 自定义注解 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>maven项目创建时出错</title>
      <link href="/2017/07/22/maven/"/>
      <url>/2017/07/22/maven/</url>
      
        <content type="html"><![CDATA[<p>哎，一些问题每次出错都要重新找方法解决。以后还是都记录下来把。</p><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>Eclipse创建Maven项目时，报错<br>Could not calculate build plan: Plugin org.apache.maven.plugins:maven-resources-plugin:2.6 or one of its dependencies could not be resolved: Failed to read artifact descriptor for org.apache.maven.plugins:maven-resources-plugin:jar:2.6<br>Plugin org.apache.maven.plugins:maven-resources-plugin:2.6 or one of its dependencies could not be resolved: Failed to read artifact descriptor for org.apache.maven.plugins:maven-resources-plugin:jar:2.6<br><a id="more"></a></p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>删除本地Maven仓库org.apache.maven.plugins:maven-resources-plugin所在目录文件夹。然后在一个maven项目中的pom.xml文件中增加以下依赖<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-resources-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>然后执行maven install重新下载maven-resources-plugin这个jar包即可。<br>同样的，有可能其他plugin会报类似的错误，解决方法和上面类似。</p>]]></content>
      
      
      <categories>
          
          <category> 奇怪的问题 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Xgboost参数</title>
      <link href="/2017/06/12/Xgboost%E5%8F%82%E6%95%B0/"/>
      <url>/2017/06/12/Xgboost%E5%8F%82%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="XGBoost的参数"><a href="#XGBoost的参数" class="headerlink" title="XGBoost的参数"></a>XGBoost的参数</h1><p>XGBoost的作者把所有的参数分成了三类：</p><ol><li>通用参数：宏观函数控制。</li><li>Booster参数：控制每一步的booster(tree/regression)。</li><li>学习目标参数：控制训练目标的表现。<br>在这里我会类比GBM来讲解，所以作为一种基础知识，强烈推荐先阅读这篇文章。<a id="more"></a><h2 id="通用参数"><a href="#通用参数" class="headerlink" title="通用参数"></a>通用参数</h2>这些参数用来控制XGBoost的宏观功能。<h3 id="booster-默认gbtree"><a href="#booster-默认gbtree" class="headerlink" title="booster[默认gbtree]"></a>booster[默认gbtree]</h3>选择每次迭代的模型，有两种选择：<br>gbtree：基于树的模型<br>gbliner：线性模型<h3 id="silent-默认0"><a href="#silent-默认0" class="headerlink" title="silent[默认0]"></a>silent[默认0]</h3>当这个参数值为1时，静默模式开启，不会输出任何信息。<br>一般这个参数就保持默认的0，因为这样能帮我们更好地理解模型。<h3 id="nthread-默认值为最大可能的线程数"><a href="#nthread-默认值为最大可能的线程数" class="headerlink" title="nthread[默认值为最大可能的线程数]"></a>nthread[默认值为最大可能的线程数]</h3>这个参数用来进行多线程控制，应当输入系统的核数。<br>如果你希望使用CPU全部的核，那就不要输入这个参数，算法会自动检测它。<br>还有两个参数，XGBoost会自动设置，目前你不用管它。接下来咱们一起看booster参数。<h2 id="booster参数"><a href="#booster参数" class="headerlink" title="booster参数"></a>booster参数</h2>尽管有两种booster可供选择，我这里只介绍tree booster，因为它的表现远远胜过linear booster，所以linear booster很少用到。<h3 id="eta-默认0-3"><a href="#eta-默认0-3" class="headerlink" title="eta[默认0.3]"></a>eta[默认0.3]</h3>和GBM中的 learning rate 参数类似。<br>通过减少每一步的权重，可以提高模型的鲁棒性。<br>典型值为0.01-0.2。<h3 id="min-child-weight-默认1"><a href="#min-child-weight-默认1" class="headerlink" title="min_child_weight[默认1]"></a>min_child_weight[默认1]</h3>决定最小叶子节点样本权重和。<br>和GBM的 min_child_leaf 参数类似，但不完全一样。XGBoost的这个参数是最小样本权重的和，而GBM参数是最小样本总数。<br>这个参数用于避免过拟合。当它的值较大时，可以避免模型学习到局部的特殊样本。<br>但是如果这个值过高，会导致欠拟合。这个参数需要使用CV来调整。<h3 id="max-depth-默认6"><a href="#max-depth-默认6" class="headerlink" title="max_depth[默认6]"></a>max_depth[默认6]</h3>和GBM中的参数相同，这个值为树的最大深度。<br>这个值也是用来避免过拟合的。max_depth越大，模型会学到更具体更局部的样本。<br>需要使用CV函数来进行调优。<br>典型值：3-10<h3 id="max-leaf-nodes"><a href="#max-leaf-nodes" class="headerlink" title="max_leaf_nodes"></a>max_leaf_nodes</h3>树上最大的节点或叶子的数量。<br>可以替代max_depth的作用。因为如果生成的是二叉树，一个深度为n的树最多生成n2个叶子。<br>如果定义了这个参数，GBM会忽略max_depth参数。<h3 id="gamma-默认0"><a href="#gamma-默认0" class="headerlink" title="gamma[默认0]"></a>gamma[默认0]</h3>在节点分裂时，只有分裂后损失函数的值下降了，才会分裂这个节点。Gamma指定了节点分裂所需的最小损失函数下降值。<br>这个参数的值越大，算法越保守。这个参数的值和损失函数息息相关，所以是需要调整的。<h3 id="max-delta-step-默认0"><a href="#max-delta-step-默认0" class="headerlink" title="max_delta_step[默认0]"></a>max_delta_step[默认0]</h3>这参数限制每棵树权重改变的最大步长。如果这个参数的值为0，那就意味着没有约束。如果它被赋予了某个正值，那么它会让这个算法更加保守。<br>通常，这个参数不需要设置。但是当各类别的样本十分不平衡时，它对逻辑回归是很有帮助的。<br>这个参数一般用不到，但是你可以挖掘出来它更多的用处。<h3 id="subsample-默认1"><a href="#subsample-默认1" class="headerlink" title="subsample[默认1]"></a>subsample[默认1]</h3>和GBM中的subsample参数一模一样。这个参数控制对于每棵树，随机采样的比例。<br>减小这个参数的值，算法会更加保守，避免过拟合。但是，如果这个值设置得过小，它可能会导致欠拟合。<br>典型值：0.5-1<h3 id="colsample-bytree-默认1"><a href="#colsample-bytree-默认1" class="headerlink" title="colsample_bytree[默认1]"></a>colsample_bytree[默认1]</h3>和GBM里面的max_features参数类似。用来控制每棵随机采样的列数的占比(每一列是一个特征)。<br>典型值：0.5-1<h3 id="colsample-bylevel-默认1"><a href="#colsample-bylevel-默认1" class="headerlink" title="colsample_bylevel[默认1]"></a>colsample_bylevel[默认1]</h3>用来控制树的每一级的每一次分裂，对列数的采样的占比。<br>我个人一般不太用这个参数，因为subsample参数和colsample_bytree参数可以起到相同的作用。但是如果感兴趣，可以挖掘这个参数更多的用处。<h3 id="lambda-默认1"><a href="#lambda-默认1" class="headerlink" title="lambda[默认1]"></a>lambda[默认1]</h3>权重的L2正则化项。(和Ridge regression类似)。<br>这个参数是用来控制XGBoost的正则化部分的。虽然大部分数据科学家很少用到这个参数，但是这个参数在减少过拟合上还是可以挖掘出更多用处的。<h3 id="alpha-默认1"><a href="#alpha-默认1" class="headerlink" title="alpha[默认1]"></a>alpha[默认1]</h3>权重的L1正则化项。(和Lasso regression类似)。<br>可以应用在很高维度的情况下，使得算法的速度更快。<h3 id="scale-pos-weight-默认1"><a href="#scale-pos-weight-默认1" class="headerlink" title="scale_pos_weight[默认1]"></a>scale_pos_weight[默认1]</h3>在各类别样本十分不平衡时，把这个参数设定为一个正值，可以使算法更快收敛。<h2 id="学习目标参数"><a href="#学习目标参数" class="headerlink" title="学习目标参数"></a>学习目标参数</h2>这个参数用来控制理想的优化目标和每一步结果的度量方法。<h3 id="objective-默认reg-linear"><a href="#objective-默认reg-linear" class="headerlink" title="objective[默认reg:linear]"></a>objective[默认reg:linear]</h3>这个参数定义需要被最小化的损失函数。最常用的值有： </li><li>binary:logistic 二分类的逻辑回归，返回预测的概率(不是类别)。</li><li>multi:softmax 使用softmax的多分类器，返回预测的类别(不是概率)。<br>在这种情况下，你还需要多设一个参数：num_class(类别数目)。</li><li>multi:softprob 和multi:softmax参数一样，但是返回的是每个数据属于各个类别的概率。<h3 id="eval-metric-默认值取决于objective参数的取值"><a href="#eval-metric-默认值取决于objective参数的取值" class="headerlink" title="eval_metric[默认值取决于objective参数的取值]"></a>eval_metric[默认值取决于objective参数的取值]</h3>对于有效数据的度量方法。<br>对于回归问题，默认值是rmse，对于分类问题，默认值是error。<br>典型值有： </li><li>rmse 均方根误差(∑Ni=1ϵ2N−−−−−−√)</li><li>mae 平均绝对误差(∑Ni=1|ϵ|N)</li><li>logloss 负对数似然函数值</li><li>error 二分类错误率(阈值为0.5)</li><li>merror 多分类错误率</li><li>mlogloss 多分类logloss损失函数</li><li>auc 曲线下面积<h3 id="seed-默认0"><a href="#seed-默认0" class="headerlink" title="seed(默认0)"></a>seed(默认0)</h3>随机数的种子<br>设置它可以复现随机数据的结果，也可以用于调整参数<br>如果你之前用的是Scikit-learn,你可能不太熟悉这些参数。但是有个好消息，python的XGBoost模块有一个sklearn包，XGBClassifier。这个包中的参数是按sklearn风格命名的。会改变的函数名是：<br>1、eta -&gt; learning_rate<br>2、lambda -&gt; reg_lambda<br>3、alpha -&gt; reg_alpha<br>你肯定在疑惑为啥咱们没有介绍和GBM中的n_estimators类似的参数。XGBClassifier中确实有一个类似的参数，但是，是在标准XGBoost实现中调用拟合函数时，把它作为num_boosting_rounds参数传入。<br>XGBoost Guide 的一些部分是我强烈推荐大家阅读的，通过它可以对代码和参数有一个更好的了解：<br><a href="http://xgboost.readthedocs.io/en/latest/parameter.html#general-parameters" target="_blank" rel="noopener">http://xgboost.readthedocs.io/en/latest/parameter.html#general-parameters</a><br><a href="https://github.com/dmlc/xgboost/tree/master/demo/guide-python" title="XGBoost Demo Codes" target="_blank" rel="noopener">https://github.com/dmlc/xgboost/tree/master/demo/guide-python</a><br><a href="http://xgboost.readthedocs.io/en/latest/python/python_api.html" title="Python Api" target="_blank" rel="noopener">http://xgboost.readthedocs.io/en/latest/python/python_api.html</a><br>本文参考：<a href="http://blog.csdn.net/han_xiaoyang/article/details/52665396" target="_blank" rel="noopener">http://blog.csdn.net/han_xiaoyang/article/details/52665396</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> Xgboost </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Xgboost </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>python求list的平均数、众数、最大值、最小值、极值、方差等</title>
      <link href="/2017/06/07/python%E6%B1%82list%E7%9A%84%E5%B9%B3%E5%9D%87%E6%95%B0%E3%80%81%E4%BC%97%E6%95%B0%E3%80%81%E6%9C%80%E5%A4%A7%E5%80%BC%E3%80%81%E6%9C%80%E5%B0%8F%E5%80%BC%E3%80%81%E6%9E%81%E5%80%BC%E3%80%81%E6%96%B9%E5%B7%AE%E7%AD%89/"/>
      <url>/2017/06/07/python%E6%B1%82list%E7%9A%84%E5%B9%B3%E5%9D%87%E6%95%B0%E3%80%81%E4%BC%97%E6%95%B0%E3%80%81%E6%9C%80%E5%A4%A7%E5%80%BC%E3%80%81%E6%9C%80%E5%B0%8F%E5%80%BC%E3%80%81%E6%9E%81%E5%80%BC%E3%80%81%E6%96%B9%E5%B7%AE%E7%AD%89/</url>
      
        <content type="html"><![CDATA[<p>数据挖掘中经常会用到一组数据(list)的相关特征。<br><a id="more"></a><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">feature.py</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="comment">#最大数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Get_Max</span><span class="params">(list)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> max(list)</span><br><span class="line"></span><br><span class="line"><span class="comment">#最小数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Get_Min</span><span class="params">(list)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> min(list)</span><br><span class="line"></span><br><span class="line"><span class="comment">#极差</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Get_Range</span><span class="params">(list)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> max(list) - min(list)</span><br><span class="line"></span><br><span class="line"><span class="comment">#中位数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_median</span><span class="params">(data)</span>:</span></span><br><span class="line">   data = sorted(data)</span><br><span class="line">   size = len(data)</span><br><span class="line">   <span class="keyword">if</span> size % <span class="number">2</span> == <span class="number">0</span>: <span class="comment"># 判断列表长度为偶数</span></span><br><span class="line">       median = (data[size//<span class="number">2</span>]+data[size//<span class="number">2</span><span class="number">-1</span>])/<span class="number">2</span></span><br><span class="line">   <span class="keyword">if</span> size % <span class="number">2</span> == <span class="number">1</span>: <span class="comment"># 判断列表长度为奇数</span></span><br><span class="line">       median = data[(size<span class="number">-1</span>)//<span class="number">2</span>]</span><br><span class="line">   <span class="keyword">return</span> median</span><br><span class="line"></span><br><span class="line"><span class="comment">#众数(返回多个众数的平均值)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Get_Most</span><span class="params">(list)</span>:</span></span><br><span class="line">    most=[]</span><br><span class="line">    item_num = dict((item, list.count(item)) <span class="keyword">for</span> item <span class="keyword">in</span> list)</span><br><span class="line">    <span class="keyword">for</span> k,v <span class="keyword">in</span> item_num.items():</span><br><span class="line">        <span class="keyword">if</span> v == max(item_num.values()):</span><br><span class="line">           most.append(k)</span><br><span class="line">    <span class="keyword">return</span> sum(most)/len(most)</span><br><span class="line"></span><br><span class="line"><span class="comment">#获取平均数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Get_Average</span><span class="params">(list)</span>:</span></span><br><span class="line">sum = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> list:</span><br><span class="line">sum += item</span><br><span class="line"><span class="keyword">return</span> sum/len(list)</span><br><span class="line"></span><br><span class="line"><span class="comment">#获取方差</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Get_Variance</span><span class="params">(list)</span>:</span></span><br><span class="line">sum = <span class="number">0</span></span><br><span class="line">average = Get_Average(list)</span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> list:</span><br><span class="line">sum += (item - average)**<span class="number">2</span></span><br><span class="line"><span class="keyword">return</span> sum/len(list)</span><br><span class="line"></span><br><span class="line"><span class="comment">#获取n阶原点距</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Get_NMoment</span><span class="params">(list,n)</span>:</span></span><br><span class="line">    sum=<span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> list:</span><br><span class="line">        sum += item**n</span><br><span class="line">    <span class="keyword">return</span> sum/len(list)</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>使用sklearn优雅地进行数据挖掘</title>
      <link href="/2017/06/07/%E4%BD%BF%E7%94%A8sklearn%E4%BC%98%E9%9B%85%E5%9C%B0%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/"/>
      <url>/2017/06/07/%E4%BD%BF%E7%94%A8sklearn%E4%BC%98%E9%9B%85%E5%9C%B0%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/</url>
      
        <content type="html"><![CDATA[<p>今天找资料的时候，发现一个很牛的大神。写的博客是真的好。慢慢的汲取养分。<br>转自：<a href="http://www.cnblogs.com/jasonfreak/p/5448462.html" target="_blank" rel="noopener">http://www.cnblogs.com/jasonfreak/p/5448462.html</a></p><h1 id="使用sklearn进行数据挖掘"><a href="#使用sklearn进行数据挖掘" class="headerlink" title="使用sklearn进行数据挖掘"></a>使用sklearn进行数据挖掘</h1><h2 id="数据挖掘的步骤"><a href="#数据挖掘的步骤" class="headerlink" title="数据挖掘的步骤"></a>数据挖掘的步骤</h2><p>数据挖掘通常包括数据采集，数据分析，特征工程，训练模型，模型评估等步骤。使用sklearn工具可以方便地进行特征工程和模型训练工作，在《使用sklearn做单机特征工程》中，我们最后留下了一些疑问：特征处理类都有三个方法fit、transform和fit_transform，fit方法居然和模型训练方法fit同名（不光同名，参数列表都一样），这难道都是巧合？<br>显然，这不是巧合，这正是sklearn的设计风格。我们能够更加优雅地使用sklearn进行特征工程和模型训练工作。此时，不妨从一个基本的数据挖掘场景入手：<br><a id="more"></a><br><img src="http://i.imgur.com/Tru96mm.png" alt=""><br>我们使用sklearn进行虚线框内的工作（sklearn也可以进行文本特征提取）。通过分析sklearn源码，我们可以看到除训练，预测和评估以外，处理其他工作的类都实现了3个方法：fit、transform和fit_transform。从命名中可以看到，fit_transform方法是先调用fit然后调用transform，我们只需要关注fit方法和transform方法即可。</p><p>transform方法主要用来对特征进行转换。从可利用信息的角度来说，转换分为无信息转换和有信息转换。无信息转换是指不利用任何其他信息进行转换，比如指数、对数函数转换等。有信息转换从是否利用目标值向量又可分为无监督转换和有监督转换。无监督转换指只利用特征的统计信息的转换，统计信息包括均值、标准差、边界等等，比如标准化、PCA法降维等。有监督转换指既利用了特征信息又利用了目标值信息的转换，比如通过模型选择特征、LDA法降维等。通过总结常用的转换类，我们得到下表：<br><img src="http://i.imgur.com/Eo7KOEI.png" alt=""><br>不难看到，只有有信息的转换类的fit方法才实际有用，显然fit方法的主要工作是获取特征信息和目标值信息，在这点上，fit方法和模型训练时的fit方法就能够联系在一起了：都是通过分析特征和目标值，提取有价值的信息，对于转换类来说是某些统计量，对于模型来说可能是特征的权值系数等。另外，只有有监督的转换类的fit和transform方法才需要特征和目标值两个参数。fit方法无用不代表其没实现，而是除合法性校验以外，其并没有对特征和目标值进行任何处理，Normalizer的fit方法实现如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="function"><span class="keyword">def</span> <span class="title">fit</span><span class="params">(self, X, y=None)</span>:</span></span><br><span class="line"><span class="number">2</span>         <span class="string">"""Do nothing and return the estimator unchanged</span></span><br><span class="line"><span class="string">3         This method is just there to implement the usual API and hence</span></span><br><span class="line"><span class="string">4         work in pipelines.</span></span><br><span class="line"><span class="string">5         """</span></span><br><span class="line"><span class="number">6</span>         X = check_array(X, accept_sparse=<span class="string">'csr'</span>)</span><br><span class="line"><span class="number">7</span>         <span class="keyword">return</span> self</span><br></pre></td></tr></table></figure></p><p>基于这些特征处理工作都有共同的方法，那么试想可不可以将他们组合在一起？在本文假设的场景中，我们可以看到这些工作的组合形式有两种：流水线式和并行式。基于流水线组合的工作需要依次进行，前一个工作的输出是后一个工作的输入；基于并行式的工作可以同时进行，其使用同样的输入，所有工作完成后将各自的输出合并之后输出。sklearn提供了包pipeline来完成流水线式和并行式的工作。</p><h2 id="数据初貌"><a href="#数据初貌" class="headerlink" title="数据初貌"></a>数据初貌</h2><p>在此，我们仍然使用IRIS数据集来进行说明。为了适应提出的场景，对原数据集需要稍微加工：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">1</span> <span class="keyword">from</span> numpy <span class="keyword">import</span> hstack, vstack, array, median, nan</span><br><span class="line"> <span class="number">2</span> <span class="keyword">from</span> numpy.random <span class="keyword">import</span> choice</span><br><span class="line"> <span class="number">3</span> <span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_iris</span><br><span class="line"> <span class="number">4</span> </span><br><span class="line"> <span class="number">5</span> <span class="comment">#特征矩阵加工</span></span><br><span class="line"> <span class="number">6</span> <span class="comment">#使用vstack增加一行含缺失值的样本(nan, nan, nan, nan)</span></span><br><span class="line"> <span class="number">7</span> <span class="comment">#使用hstack增加一列表示花的颜色（0-白、1-黄、2-红），花的颜色是随机的，意味着颜色并不影响花的分类</span></span><br><span class="line"> <span class="number">8</span> iris.data = hstack((choice([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>], size=iris.data.shape[<span class="number">0</span>]+<span class="number">1</span>).reshape(<span class="number">-1</span>,<span class="number">1</span>), vstack((iris.data, array([nan, nan, nan, nan]).reshape(<span class="number">1</span>,<span class="number">-1</span>)))))</span><br><span class="line"> <span class="number">9</span> <span class="comment">#目标值向量加工</span></span><br><span class="line"><span class="number">10</span> <span class="comment">#增加一个目标值，对应含缺失值的样本，值为众数</span></span><br><span class="line"><span class="number">11</span> iris.target = hstack((iris.target, array([median(iris.target)])))</span><br></pre></td></tr></table></figure></p><h2 id="关键技术"><a href="#关键技术" class="headerlink" title="关键技术"></a>关键技术</h2><h2 id="并行处理，流水线处理，自动化调参，持久化是使用sklearn优雅地进行数据挖掘的核心。并行处理和流水线处理将多个特征处理工作，甚至包括模型训练工作组合成一个工作（从代码的角度来说，即将多个对象组合成了一个对象）。在组合的前提下，自动化调参技术帮我们省去了人工调参的反锁。训练好的模型是贮存在内存中的数据，持久化能够将这些数据保存在文件系统中，之后使用时无需再进行训练，直接从文件系统中加载即可。"><a href="#并行处理，流水线处理，自动化调参，持久化是使用sklearn优雅地进行数据挖掘的核心。并行处理和流水线处理将多个特征处理工作，甚至包括模型训练工作组合成一个工作（从代码的角度来说，即将多个对象组合成了一个对象）。在组合的前提下，自动化调参技术帮我们省去了人工调参的反锁。训练好的模型是贮存在内存中的数据，持久化能够将这些数据保存在文件系统中，之后使用时无需再进行训练，直接从文件系统中加载即可。" class="headerlink" title="并行处理，流水线处理，自动化调参，持久化是使用sklearn优雅地进行数据挖掘的核心。并行处理和流水线处理将多个特征处理工作，甚至包括模型训练工作组合成一个工作（从代码的角度来说，即将多个对象组合成了一个对象）。在组合的前提下，自动化调参技术帮我们省去了人工调参的反锁。训练好的模型是贮存在内存中的数据，持久化能够将这些数据保存在文件系统中，之后使用时无需再进行训练，直接从文件系统中加载即可。"></a>并行处理，流水线处理，自动化调参，持久化是使用sklearn优雅地进行数据挖掘的核心。并行处理和流水线处理将多个特征处理工作，甚至包括模型训练工作组合成一个工作（从代码的角度来说，即将多个对象组合成了一个对象）。在组合的前提下，自动化调参技术帮我们省去了人工调参的反锁。训练好的模型是贮存在内存中的数据，持久化能够将这些数据保存在文件系统中，之后使用时无需再进行训练，直接从文件系统中加载即可。</h2><h1 id="并行处理"><a href="#并行处理" class="headerlink" title="并行处理"></a>并行处理</h1><p>并行处理使得多个特征处理工作能够并行地进行。根据对特征矩阵的读取方式不同，可分为整体并行处理和部分并行处理。整体并行处理，即并行处理的每个工作的输入都是特征矩阵的整体；部分并行处理，即可定义每个工作需要输入的特征矩阵的列。</p><h2 id="整体并行处理"><a href="#整体并行处理" class="headerlink" title="整体并行处理"></a>整体并行处理</h2><p>pipeline包提供了FeatureUnion类来进行整体并行处理：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">1</span> <span class="keyword">from</span> numpy <span class="keyword">import</span> log1p</span><br><span class="line"> <span class="number">2</span> <span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> FunctionTransformer</span><br><span class="line"> <span class="number">3</span> <span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> Binarizer</span><br><span class="line"> <span class="number">4</span> <span class="keyword">from</span> sklearn.pipeline <span class="keyword">import</span> FeatureUnion</span><br><span class="line"> <span class="number">5</span> </span><br><span class="line"> <span class="number">6</span> <span class="comment">#新建将整体特征矩阵进行对数函数转换的对象</span></span><br><span class="line"> <span class="number">7</span> step2_1 = (<span class="string">'ToLog'</span>, FunctionTransformer(log1p))</span><br><span class="line"> <span class="number">8</span> <span class="comment">#新建将整体特征矩阵进行二值化类的对象</span></span><br><span class="line"> <span class="number">9</span> step2_2 = (<span class="string">'ToBinary'</span>, Binarizer())</span><br><span class="line"><span class="number">10</span> <span class="comment">#新建整体并行处理对象</span></span><br><span class="line"><span class="number">11</span> <span class="comment">#该对象也有fit和transform方法，fit和transform方法均是并行地调用需要并行处理的对象的fit和transform方法</span></span><br><span class="line"><span class="number">12</span> <span class="comment">#参数transformer_list为需要并行处理的对象列表，该列表为二元组列表，第一元为对象的名称，第二元为对象</span></span><br><span class="line"><span class="number">13</span> step2 = (<span class="string">'FeatureUnion'</span>, FeatureUnion(transformer_list=[step2_1, step2_2, step2_3]))</span><br></pre></td></tr></table></figure></p><h2 id="部分并行处理"><a href="#部分并行处理" class="headerlink" title="部分并行处理"></a>部分并行处理</h2><p>整体并行处理有其缺陷，在一些场景下，我们只需要对特征矩阵的某些列进行转换，而不是所有列。pipeline并没有提供相应的类（仅OneHotEncoder类实现了该功能），需要我们在FeatureUnion的基础上进行优化：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">1</span> <span class="keyword">from</span> sklearn.pipeline <span class="keyword">import</span> FeatureUnion, _fit_one_transformer, _fit_transform_one, _transform_one </span><br><span class="line"> <span class="number">2</span> <span class="keyword">from</span> sklearn.externals.joblib <span class="keyword">import</span> Parallel, delayed</span><br><span class="line"> <span class="number">3</span> <span class="keyword">from</span> scipy <span class="keyword">import</span> sparse</span><br><span class="line"> <span class="number">4</span> <span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"> <span class="number">5</span> </span><br><span class="line"> <span class="number">6</span> <span class="comment">#部分并行处理，继承FeatureUnion</span></span><br><span class="line"> <span class="number">7</span> <span class="class"><span class="keyword">class</span> <span class="title">FeatureUnionExt</span><span class="params">(FeatureUnion)</span>:</span></span><br><span class="line"> <span class="number">8</span>     <span class="comment">#相比FeatureUnion，多了idx_list参数，其表示每个并行工作需要读取的特征矩阵的列</span></span><br><span class="line"> <span class="number">9</span>     <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, transformer_list, idx_list, n_jobs=<span class="number">1</span>, transformer_weights=None)</span>:</span></span><br><span class="line"><span class="number">10</span>         self.idx_list = idx_list</span><br><span class="line"><span class="number">11</span>         FeatureUnion.__init__(self, transformer_list=map(<span class="keyword">lambda</span> trans:(trans[<span class="number">0</span>], trans[<span class="number">1</span>]), transformer_list), n_jobs=n_jobs, transformer_weights=transformer_weights)</span><br><span class="line"><span class="number">12</span> </span><br><span class="line"><span class="number">13</span>     <span class="comment">#由于只部分读取特征矩阵，方法fit需要重构</span></span><br><span class="line"><span class="number">14</span>     <span class="function"><span class="keyword">def</span> <span class="title">fit</span><span class="params">(self, X, y=None)</span>:</span></span><br><span class="line"><span class="number">15</span>         transformer_idx_list = map(<span class="keyword">lambda</span> trans, idx:(trans[<span class="number">0</span>], trans[<span class="number">1</span>], idx), self.transformer_list, self.idx_list)</span><br><span class="line"><span class="number">16</span>         transformers = Parallel(n_jobs=self.n_jobs)(</span><br><span class="line"><span class="number">17</span>             <span class="comment">#从特征矩阵中提取部分输入fit方法</span></span><br><span class="line"><span class="number">18</span>             delayed(_fit_one_transformer)(trans, X[:,idx], y)</span><br><span class="line"><span class="number">19</span>             <span class="keyword">for</span> name, trans, idx <span class="keyword">in</span> transformer_idx_list)</span><br><span class="line"><span class="number">20</span>         self._update_transformer_list(transformers)</span><br><span class="line"><span class="number">21</span>         <span class="keyword">return</span> self</span><br><span class="line"><span class="number">22</span> </span><br><span class="line"><span class="number">23</span>     <span class="comment">#由于只部分读取特征矩阵，方法fit_transform需要重构</span></span><br><span class="line"><span class="number">24</span>     <span class="function"><span class="keyword">def</span> <span class="title">fit_transform</span><span class="params">(self, X, y=None, **fit_params)</span>:</span></span><br><span class="line"><span class="number">25</span>         transformer_idx_list = map(<span class="keyword">lambda</span> trans, idx:(trans[<span class="number">0</span>], trans[<span class="number">1</span>], idx), self.transformer_list, self.idx_list)</span><br><span class="line"><span class="number">26</span>         result = Parallel(n_jobs=self.n_jobs)(</span><br><span class="line"><span class="number">27</span>             <span class="comment">#从特征矩阵中提取部分输入fit_transform方法</span></span><br><span class="line"><span class="number">28</span>             delayed(_fit_transform_one)(trans, name, X[:,idx], y,</span><br><span class="line"><span class="number">29</span>                                         self.transformer_weights, **fit_params)</span><br><span class="line"><span class="number">30</span>             <span class="keyword">for</span> name, trans, idx <span class="keyword">in</span> transformer_idx_list)</span><br><span class="line"><span class="number">31</span> </span><br><span class="line"><span class="number">32</span>         Xs, transformers = zip(*result)</span><br><span class="line"><span class="number">33</span>         self._update_transformer_list(transformers)</span><br><span class="line"><span class="number">34</span>         <span class="keyword">if</span> any(sparse.issparse(f) <span class="keyword">for</span> f <span class="keyword">in</span> Xs):</span><br><span class="line"><span class="number">35</span>             Xs = sparse.hstack(Xs).tocsr()</span><br><span class="line"><span class="number">36</span>         <span class="keyword">else</span>:</span><br><span class="line"><span class="number">37</span>             Xs = np.hstack(Xs)</span><br><span class="line"><span class="number">38</span>         <span class="keyword">return</span> Xs</span><br><span class="line"><span class="number">39</span> </span><br><span class="line"><span class="number">40</span>     <span class="comment">#由于只部分读取特征矩阵，方法transform需要重构</span></span><br><span class="line"><span class="number">41</span>     <span class="function"><span class="keyword">def</span> <span class="title">transform</span><span class="params">(self, X)</span>:</span></span><br><span class="line"><span class="number">42</span>         transformer_idx_list = map(<span class="keyword">lambda</span> trans, idx:(trans[<span class="number">0</span>], trans[<span class="number">1</span>], idx), self.transformer_list, self.idx_list)</span><br><span class="line"><span class="number">43</span>         Xs = Parallel(n_jobs=self.n_jobs)(</span><br><span class="line"><span class="number">44</span>             <span class="comment">#从特征矩阵中提取部分输入transform方法</span></span><br><span class="line"><span class="number">45</span>             delayed(_transform_one)(trans, name, X[:,idx], self.transformer_weights)</span><br><span class="line"><span class="number">46</span>             <span class="keyword">for</span> name, trans, idx <span class="keyword">in</span> transformer_idx_list)</span><br><span class="line"><span class="number">47</span>         <span class="keyword">if</span> any(sparse.issparse(f) <span class="keyword">for</span> f <span class="keyword">in</span> Xs):</span><br><span class="line"><span class="number">48</span>             Xs = sparse.hstack(Xs).tocsr()</span><br><span class="line"><span class="number">49</span>         <span class="keyword">else</span>:</span><br><span class="line"><span class="number">50</span>             Xs = np.hstack(Xs)</span><br><span class="line"><span class="number">51</span>         <span class="keyword">return</span> Xs</span><br></pre></td></tr></table></figure></p><p>在本文提出的场景中，我们对特征矩阵的第1列（花的颜色）进行定性特征编码，对第2、3、4列进行对数函数转换，对第5列进行定量特征二值化处理。使用FeatureUnionExt类进行部分并行处理的代码如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">1</span> <span class="keyword">from</span> numpy <span class="keyword">import</span> log1p</span><br><span class="line"> <span class="number">2</span> <span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> OneHotEncoder</span><br><span class="line"> <span class="number">3</span> <span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> FunctionTransformer</span><br><span class="line"> <span class="number">4</span> <span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> Binarizer</span><br><span class="line"> <span class="number">5</span> </span><br><span class="line"> <span class="number">6</span> <span class="comment">#新建将部分特征矩阵进行定性特征编码的对象</span></span><br><span class="line"> <span class="number">7</span> step2_1 = (<span class="string">'OneHotEncoder'</span>, OneHotEncoder(sparse=<span class="keyword">False</span>))</span><br><span class="line"> <span class="number">8</span> <span class="comment">#新建将部分特征矩阵进行对数函数转换的对象</span></span><br><span class="line"> <span class="number">9</span> step2_2 = (<span class="string">'ToLog'</span>, FunctionTransformer(log1p))</span><br><span class="line"><span class="number">10</span> <span class="comment">#新建将部分特征矩阵进行二值化类的对象</span></span><br><span class="line"><span class="number">11</span> step2_3 = (<span class="string">'ToBinary'</span>, Binarizer())</span><br><span class="line"><span class="number">12</span> <span class="comment">#新建部分并行处理对象</span></span><br><span class="line"><span class="number">13</span> <span class="comment">#参数transformer_list为需要并行处理的对象列表，该列表为二元组列表，第一元为对象的名称，第二元为对象</span></span><br><span class="line"><span class="number">14</span> <span class="comment">#参数idx_list为相应的需要读取的特征矩阵的列</span></span><br><span class="line"><span class="number">15</span> step2 = (<span class="string">'FeatureUnionExt'</span>, FeatureUnionExt(transformer_list=[step2_1, step2_2, step2_3], idx_list=[[<span class="number">0</span>], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>]]))</span><br></pre></td></tr></table></figure></p><h1 id="流水线处理"><a href="#流水线处理" class="headerlink" title="流水线处理"></a>流水线处理</h1><p>pipeline包提供了Pipeline类来进行流水线处理。流水线上除最后一个工作以外，其他都要执行fit_transform方法，且上一个工作输出作为下一个工作的输入。最后一个工作必须实现fit方法，输入为上一个工作的输出；但是不限定一定有transform方法，因为流水线的最后一个工作可能是训练！<br>根据本文提出的场景，结合并行处理，构建完整的流水线的代码如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">1</span> <span class="keyword">from</span> numpy <span class="keyword">import</span> log1p</span><br><span class="line"> <span class="number">2</span> <span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> Imputer</span><br><span class="line"> <span class="number">3</span> <span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> OneHotEncoder</span><br><span class="line"> <span class="number">4</span> <span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> FunctionTransformer</span><br><span class="line"> <span class="number">5</span> <span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> Binarizer</span><br><span class="line"> <span class="number">6</span> <span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> MinMaxScaler</span><br><span class="line"> <span class="number">7</span> <span class="keyword">from</span> sklearn.feature_selection <span class="keyword">import</span> SelectKBest</span><br><span class="line"> <span class="number">8</span> <span class="keyword">from</span> sklearn.feature_selection <span class="keyword">import</span> chi2</span><br><span class="line"> <span class="number">9</span> <span class="keyword">from</span> sklearn.decomposition <span class="keyword">import</span> PCA</span><br><span class="line"><span class="number">10</span> <span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LogisticRegression</span><br><span class="line"><span class="number">11</span> <span class="keyword">from</span> sklearn.pipeline <span class="keyword">import</span> Pipeline</span><br><span class="line"><span class="number">12</span> </span><br><span class="line"><span class="number">13</span> <span class="comment">#新建计算缺失值的对象</span></span><br><span class="line"><span class="number">14</span> step1 = (<span class="string">'Imputer'</span>, Imputer())</span><br><span class="line"><span class="number">15</span> <span class="comment">#新建将部分特征矩阵进行定性特征编码的对象</span></span><br><span class="line"><span class="number">16</span> step2_1 = (<span class="string">'OneHotEncoder'</span>, OneHotEncoder(sparse=<span class="keyword">False</span>))</span><br><span class="line"><span class="number">17</span> <span class="comment">#新建将部分特征矩阵进行对数函数转换的对象</span></span><br><span class="line"><span class="number">18</span> step2_2 = (<span class="string">'ToLog'</span>, FunctionTransformer(log1p))</span><br><span class="line"><span class="number">19</span> <span class="comment">#新建将部分特征矩阵进行二值化类的对象</span></span><br><span class="line"><span class="number">20</span> step2_3 = (<span class="string">'ToBinary'</span>, Binarizer())</span><br><span class="line"><span class="number">21</span> <span class="comment">#新建部分并行处理对象，返回值为每个并行工作的输出的合并</span></span><br><span class="line"><span class="number">22</span> step2 = (<span class="string">'FeatureUnionExt'</span>, FeatureUnionExt(transformer_list=[step2_1, step2_2, step2_3], idx_list=[[<span class="number">0</span>], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>]]))</span><br><span class="line"><span class="number">23</span> <span class="comment">#新建无量纲化对象</span></span><br><span class="line"><span class="number">24</span> step3 = (<span class="string">'MinMaxScaler'</span>, MinMaxScaler())</span><br><span class="line"><span class="number">25</span> <span class="comment">#新建卡方校验选择特征的对象</span></span><br><span class="line"><span class="number">26</span> step4 = (<span class="string">'SelectKBest'</span>, SelectKBest(chi2, k=<span class="number">3</span>))</span><br><span class="line"><span class="number">27</span> <span class="comment">#新建PCA降维的对象</span></span><br><span class="line"><span class="number">28</span> step5 = (<span class="string">'PCA'</span>, PCA(n_components=<span class="number">2</span>))</span><br><span class="line"><span class="number">29</span> <span class="comment">#新建逻辑回归的对象，其为待训练的模型作为流水线的最后一步</span></span><br><span class="line"><span class="number">30</span> step6 = (<span class="string">'LogisticRegression'</span>, LogisticRegression(penalty=<span class="string">'l2'</span>))</span><br><span class="line"><span class="number">31</span> <span class="comment">#新建流水线处理对象</span></span><br><span class="line"><span class="number">32</span> <span class="comment">#参数steps为需要流水线处理的对象列表，该列表为二元组列表，第一元为对象的名称，第二元为对象</span></span><br><span class="line"><span class="number">33</span> pipeline = Pipeline(steps=[step1, step2, step3, step4, step5, step6])</span><br></pre></td></tr></table></figure></p><h1 id="自动化调参"><a href="#自动化调参" class="headerlink" title="自动化调参"></a>自动化调参</h1><p>网格搜索为自动化调参的常见技术之一，grid_search包提供了自动化调参的工具，包括GridSearchCV类。对组合好的对象进行训练以及调参的代码如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="keyword">from</span> sklearn.grid_search <span class="keyword">import</span> GridSearchCV</span><br><span class="line"><span class="number">2</span> </span><br><span class="line"><span class="number">3</span> <span class="comment">#新建网格搜索对象</span></span><br><span class="line"><span class="number">4</span> <span class="comment">#第一参数为待训练的模型</span></span><br><span class="line"><span class="number">5</span>  <span class="comment">#param_grid为待调参数组成的网格，字典格式，键为参数名称（格式“对象名称__子对象名称__参数名称”），值为可取的参数值列表</span></span><br><span class="line"><span class="number">6</span>  grid_search = GridSearchCV(pipeline, param_grid=&#123;<span class="string">'FeatureUnionExt__ToBinary__threshold'</span>:[<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>, <span class="number">4.0</span>], <span class="string">'LogisticRegression__C'</span>:[<span class="number">0.1</span>, <span class="number">0.2</span>, <span class="number">0.4</span>, <span class="number">0.8</span>]&#125;)</span><br><span class="line"><span class="number">7</span> <span class="comment">#训练以及调参</span></span><br><span class="line"><span class="number">8</span> grid_search.fit(iris.data, iris.target)</span><br></pre></td></tr></table></figure></p><h1 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h1><p>externals.joblib包提供了dump和load方法来持久化和加载内存数据：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="comment">#持久化数据</span></span><br><span class="line"><span class="number">2</span> <span class="comment">#第一个参数为内存中的对象</span></span><br><span class="line"><span class="number">3</span> <span class="comment">#第二个参数为保存在文件系统中的名称</span></span><br><span class="line"><span class="number">4</span> <span class="comment">#第三个参数为压缩级别，0为不压缩，3为合适的压缩级别</span></span><br><span class="line"><span class="number">5</span> dump(grid_search, <span class="string">'grid_search.dmp'</span>, compress=<span class="number">3</span>)</span><br><span class="line"><span class="number">6</span> <span class="comment">#从文件系统中加载数据到内存中</span></span><br><span class="line"><span class="number">7</span> grid_search = load(<span class="string">'grid_search.dmp'</span>)</span><br></pre></td></tr></table></figure></p><h1 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h1><p><img src="http://i.imgur.com/U20pnnw.png" alt=""><br>注意：组合和持久化都会涉及pickle技术，在sklearn的技术文档中有说明，将lambda定义的函数作为FunctionTransformer的自定义转换函数将不能pickle化。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>2015年我设计了一个基于sklearn的自动化特征工程的工具，其以Mysql数据库作为原始数据源，提供了“灵活的”特征提取、特征处理的配置方法，同时重新封装了数据、特征和模型，以方便调度系统识别。说灵活，其实也只是通过配置文件的方式定义每个特征的提取和处理的sql语句。但是纯粹使用sql语句来进行特征处理是很勉强的，除去特征提取以外，我又造了一回轮子，原来sklearn提供了这么优秀的特征处理、工作组合等功能。所以，我在这个博客中先不提任何算法和模型，先从数据挖掘工作的第一步开始，使用基于Python的各个工具把大部分步骤都走了一遍（抱歉，我暂时忽略了特征提取），希望这样的梳理能够少让初学者走弯路吧。</p>]]></content>
      
      
      <categories>
          
          <category> sklearn学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据挖掘 </tag>
            
            <tag> sklearn </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>用sklearn做数据预处理</title>
      <link href="/2017/06/06/%E7%94%A8sklearn%E5%81%9A%E6%95%B0%E6%8D%AE%E9%A2%84%E5%A4%84%E7%90%86/"/>
      <url>/2017/06/06/%E7%94%A8sklearn%E5%81%9A%E6%95%B0%E6%8D%AE%E9%A2%84%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>用sklearn做机器学习的时候，一直都是用的时候再去网上找资料，结果每次都要重新找，很麻烦。终于下决心好好总结一下，平时经常用的一些sklearn的东西（或其他相关知识），希望能写成一个系列的笔记。</p><h1 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h1><p>这次就总结下sklearn数据预处理。主要是别人博客的知识，汇总一下。<br>sklearn是一个常用的机器学习库，其中的sklearn.preprocessing模块包含了常用的预处理函数，包括数据的清洗，如缺失值和零值的填充，数据标准化，二值化和哑编码等。</p><h1 id="数据预处理"><a href="#数据预处理" class="headerlink" title="数据预处理"></a>数据预处理</h1><h2 id="1-标准化（均值去除和按方差比例缩放）"><a href="#1-标准化（均值去除和按方差比例缩放）" class="headerlink" title="1.标准化（均值去除和按方差比例缩放）"></a>1.标准化（均值去除和按方差比例缩放）</h2><p>将数据转化为均值为零，方差为一的数据，形如标准正态分布（高斯分布）。实际操作中，经常忽略特征数据的分布形状，移除每个特征均值，划分离散特征的标准差，从而等级化，进而实现数据中心化。在利用机器学习算法（例如SVM）的过程中，如果目标函数中的一个特征的方差的阶数的量级高于其他特征的方差，那么这一特征就会在目标函数中占主导地位，从而“淹没”其他特征的作用。<br>数据标准化的意义：</p><ol><li>消除量纲影响和变量自身变异大小和数值大小的影响。</li><li>数据同趋化，主要解决不同性质数据问题，对不同性质指标直接加总不能正确反映不同作用力的综合结果<h3 id="Z-score标准化"><a href="#Z-score标准化" class="headerlink" title="Z-score标准化"></a>Z-score标准化</h3>基于原始数据的均值（mean）和标准差（standard deviation）进行数据的标准化。<br>公式为：(X-mean)/std  （mean为均值，std为标准差）<br>计算时对每个属性/每列分别进行。<br>将数据按期属性（按列进行）减去其均值，并处以其方差。得到的结果是，对于每个属性/每列来说所有数据都聚集在0附近，方差为1。<br>用sklearn实现有两种方式：<br>1.使用sklearn.preprocessing.scale()函数，可以直接将给定数据进行标准化。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> sklearn <span class="keyword">import</span> preprocessing</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>X = np.array([[ <span class="number">1.</span>, <span class="number">-1.</span>,  <span class="number">2.</span>],</span><br><span class="line"><span class="meta">... </span>              [ <span class="number">2.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>],</span><br><span class="line"><span class="meta">... </span>              [ <span class="number">0.</span>,  <span class="number">1.</span>, <span class="number">-1.</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>X_scaled = preprocessing.scale(X)</span><br><span class="line"> </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>X_scaled                                          </span><br><span class="line">array([[ <span class="number">0.</span>  ..., <span class="number">-1.22</span>...,  <span class="number">1.33</span>...],</span><br><span class="line">       [ <span class="number">1.22</span>...,  <span class="number">0.</span>  ..., <span class="number">-0.26</span>...],</span><br><span class="line">       [<span class="number">-1.22</span>...,  <span class="number">1.22</span>..., <span class="number">-1.06</span>...]])</span><br><span class="line"> </span><br><span class="line">&gt;&gt;&gt;<span class="comment">#处理后数据的均值和方差</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>X_scaled.mean(axis=<span class="number">0</span>)</span><br><span class="line">array([ <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>])<span class="comment">#零均值</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>X_scaled.std(axis=<span class="number">0</span>)</span><br><span class="line">array([ <span class="number">1.</span>,  <span class="number">1.</span>,  <span class="number">1.</span>])<span class="comment">#单位方差</span></span><br></pre></td></tr></table></figure></li></ol><p>2.使用sklearn.preprocessing.StandardScaler类，使用该类的好处在于可以保存训练集中的参数（均值、方差）直接使用其对象转换测试集数据。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>scaler = preprocessing.StandardScaler().fit(X)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>scaler</span><br><span class="line">StandardScaler(copy=<span class="keyword">True</span>, with_mean=<span class="keyword">True</span>, with_std=<span class="keyword">True</span>)</span><br><span class="line"> </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>scaler.mean_                                      </span><br><span class="line">array([ <span class="number">1.</span> ...,  <span class="number">0.</span> ...,  <span class="number">0.33</span>...])</span><br><span class="line"> </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>scaler.std_                                       </span><br><span class="line">array([ <span class="number">0.81</span>...,  <span class="number">0.81</span>...,  <span class="number">1.24</span>...])</span><br><span class="line"> </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>scaler.transform(X)                               </span><br><span class="line">array([[ <span class="number">0.</span>  ..., <span class="number">-1.22</span>...,  <span class="number">1.33</span>...],</span><br><span class="line">       [ <span class="number">1.22</span>...,  <span class="number">0.</span>  ..., <span class="number">-0.26</span>...],</span><br><span class="line">       [<span class="number">-1.22</span>...,  <span class="number">1.22</span>..., <span class="number">-1.06</span>...]])</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">&gt;&gt;&gt;<span class="comment">#可以直接使用训练集对测试集数据进行转换</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>scaler.transform([[<span class="number">-1.</span>,  <span class="number">1.</span>, <span class="number">0.</span>]])                </span><br><span class="line">array([[<span class="number">-2.44</span>...,  <span class="number">1.22</span>..., <span class="number">-0.26</span>...]])</span><br></pre></td></tr></table></figure></p><h3 id="MinMax标准化-最小最大值标准化"><a href="#MinMax标准化-最小最大值标准化" class="headerlink" title="MinMax标准化(最小最大值标准化)"></a>MinMax标准化(最小最大值标准化)</h3><p>将数据缩放至给定的最小值与最大值之间，通常是０与１之间，可用MinMaxScaler实现。或者将最大的绝对值缩放至单位大小，可用MaxAbsScaler实现。<br>对原始数据的线性变换，使结果落到[0,1]区间，转换函数如下：<br>x ＝ (x - min)/(max - min)<br>max: 样本数据的最大值<br>min: 为样本数据的最小值<br>使用这种方法的目的包括：<br>1、对于方差非常小的属性可以增强其稳定性。<br>2、维持稀疏矩阵中为0的条目。<br>sklearn实现MinMax标准化：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>X_train = np.array([[ <span class="number">1.</span>, <span class="number">-1.</span>,  <span class="number">2.</span>],</span><br><span class="line"><span class="meta">... </span>                    [ <span class="number">2.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>],</span><br><span class="line"><span class="meta">... </span>                    [ <span class="number">0.</span>,  <span class="number">1.</span>, <span class="number">-1.</span>]])</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>min_max_scaler = preprocessing.MinMaxScaler()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>X_train_minmax = min_max_scaler.fit_transform(X_train)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>X_train_minmax</span><br><span class="line">array([[ <span class="number">0.5</span>       ,  <span class="number">0.</span>        ,  <span class="number">1.</span>        ],</span><br><span class="line">       [ <span class="number">1.</span>        ,  <span class="number">0.5</span>       ,  <span class="number">0.33333333</span>],</span><br><span class="line">       [ <span class="number">0.</span>        ,  <span class="number">1.</span>        ,  <span class="number">0.</span>        ]])</span><br><span class="line"> </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment">#将相同的缩放应用到测试集数据中</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>X_test = np.array([[ <span class="number">-3.</span>, <span class="number">-1.</span>,  <span class="number">4.</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>X_test_minmax = min_max_scaler.transform(X_test)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>X_test_minmax</span><br><span class="line">array([[<span class="number">-1.5</span>       ,  <span class="number">0.</span>        ,  <span class="number">1.66666667</span>]])</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment">#缩放因子等属性</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>min_max_scaler.scale_                             </span><br><span class="line">array([ <span class="number">0.5</span>       ,  <span class="number">0.5</span>       ,  <span class="number">0.33</span>...])</span><br><span class="line"> </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>min_max_scaler.min_                               </span><br><span class="line">array([ <span class="number">0.</span>        ,  <span class="number">0.5</span>       ,  <span class="number">0.33</span>...])</span><br></pre></td></tr></table></figure></p><p>MinMaxScaler()默认的缩放范围是（0,1）。在构造类对象的时候也可以直接指定最大最小值的范围：feature_range=(min, max)<br>例如：min_max_scaler = preprocessing.MinMaxScaler(feature_range=(min, max))</p><h3 id="MaxAbsScaler（绝对值最大标准化）"><a href="#MaxAbsScaler（绝对值最大标准化）" class="headerlink" title="MaxAbsScaler（绝对值最大标准化）"></a>MaxAbsScaler（绝对值最大标准化）</h3><p>与上述标准化方法相似，但是它通过除以最大值将训练集缩放至[-1,1]<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">X_train = np.array([[ <span class="number">1.</span>, <span class="number">-1.</span>,  <span class="number">2.</span>],  </span><br><span class="line">                     [ <span class="number">2.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>],  </span><br><span class="line">                    [ <span class="number">0.</span>,  <span class="number">1.</span>, <span class="number">-1.</span>]])  </span><br><span class="line">max_abs_scaler = preprocessing.MaxAbsScaler()  </span><br><span class="line">X_train_maxabs = max_abs_scaler.fit_transform(X_train)  </span><br><span class="line"><span class="comment"># doctest +NORMALIZE_WHITESPACE^, out: array([[ 0.5, -1.,  1. ], [ 1. , 0. ,  0. ],       [ 0. ,  1. , -0.5]])  </span></span><br><span class="line">X_test = np.array([[ <span class="number">-3.</span>, <span class="number">-1.</span>,  <span class="number">4.</span>]])  </span><br><span class="line">X_test_maxabs = max_abs_scaler.transform(X_test) <span class="comment">#out: array([[-1.5, -1. ,  2. ]])  </span></span><br><span class="line">max_abs_scaler.scale_  <span class="comment">#out: array([ 2.,  1.,  2.])</span></span><br></pre></td></tr></table></figure></p><h2 id="正则化（Normalization）规范化"><a href="#正则化（Normalization）规范化" class="headerlink" title="正则化（Normalization）规范化"></a>正则化（Normalization）规范化</h2><p>这个本人理解的不是很透，先把别人的结论放上来。而且从找到的资料来看，这个翻译比较模糊。<br>文档上说：Normalization is the process of scaling individual samples to have unit norm.<br>正则化的过程是将每个样本缩放到单位范数（每个样本的范数为1），如果后面要使用如二次型（点积）或者其它核方法计算两个样本之间的相似性这个方法会很有用。<br>将样本缩放成单位向量，标准化数据是针对特征来说的，而现在正则化是对样本来做的，是用样本数据除以他的范式。<br>sklearn实现使用preprocessing.normalize(x, norm = ‘l1’)方法，具体的参数说明详见sklearn文档<br><a href="http://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.normalize.html#sklearn.preprocessing.normalize" target="_blank" rel="noopener">http://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.normalize.html#sklearn.preprocessing.normalize</a><br>1.使用preprocessing.normalize()函数对指定数据进行转换：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>X = [[ <span class="number">1.</span>, <span class="number">-1.</span>,  <span class="number">2.</span>],</span><br><span class="line"><span class="meta">... </span>     [ <span class="number">2.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>],</span><br><span class="line"><span class="meta">... </span>     [ <span class="number">0.</span>,  <span class="number">1.</span>, <span class="number">-1.</span>]]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>X_normalized = preprocessing.normalize(X, norm=<span class="string">'l2'</span>)</span><br><span class="line"> </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>X_normalized                                      </span><br><span class="line">array([[ <span class="number">0.40</span>..., <span class="number">-0.40</span>...,  <span class="number">0.81</span>...],</span><br><span class="line">       [ <span class="number">1.</span>  ...,  <span class="number">0.</span>  ...,  <span class="number">0.</span>  ...],</span><br><span class="line">       [ <span class="number">0.</span>  ...,  <span class="number">0.70</span>..., <span class="number">-0.70</span>...]])</span><br></pre></td></tr></table></figure></p><p>2.使用processing.Normalizer()类实现对训练集和测试集的拟合和转换：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>normalizer = preprocessing.Normalizer().fit(X)  <span class="comment"># fit does nothing</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>normalizer</span><br><span class="line">Normalizer(copy=<span class="keyword">True</span>, norm=<span class="string">'l2'</span>)</span><br><span class="line"> </span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>normalizer.transform(X)                            </span><br><span class="line">array([[ <span class="number">0.40</span>..., <span class="number">-0.40</span>...,  <span class="number">0.81</span>...],</span><br><span class="line">       [ <span class="number">1.</span>  ...,  <span class="number">0.</span>  ...,  <span class="number">0.</span>  ...],</span><br><span class="line">       [ <span class="number">0.</span>  ...,  <span class="number">0.70</span>..., <span class="number">-0.70</span>...]])</span><br><span class="line"> </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>normalizer.transform([[<span class="number">-1.</span>,  <span class="number">1.</span>, <span class="number">0.</span>]])             </span><br><span class="line">array([[<span class="number">-0.70</span>...,  <span class="number">0.70</span>...,  <span class="number">0.</span>  ...]])</span><br></pre></td></tr></table></figure></p><p>对于l2 norm,变换后每个样本的各维特征的平方和为1。类似地，L1 norm则是变换后每个样本的各维特征的绝对值和为1。还有max norm，则是将每个样本的各维特征除以该样本各维特征的最大值.</p><h2 id="二值化（Binarization）"><a href="#二值化（Binarization）" class="headerlink" title="二值化（Binarization）"></a>二值化（Binarization）</h2><p>将数值型数据转化为布尔型的二值数据，可以设置一个阈值（threshold）<br>在sklearn中，sklearn.preprocessing.Binarizer函数可以实现<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>X = [[ <span class="number">1.</span>, <span class="number">-1.</span>,  <span class="number">2.</span>],</span><br><span class="line"><span class="meta">... </span>     [ <span class="number">2.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>],</span><br><span class="line"><span class="meta">... </span>     [ <span class="number">0.</span>,  <span class="number">1.</span>, <span class="number">-1.</span>]]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>binarizer = preprocessing.Binarizer().fit(X)  <span class="comment"># fit does nothing</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>binarizer</span><br><span class="line">Binarizer(copy=<span class="keyword">True</span>, threshold=<span class="number">0.0</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>binarizer.transform(X)</span><br><span class="line">array([[ <span class="number">1.</span>,  <span class="number">0.</span>,  <span class="number">1.</span>],</span><br><span class="line">       [ <span class="number">1.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>],</span><br><span class="line">       [ <span class="number">0.</span>,  <span class="number">1.</span>,  <span class="number">0.</span>]])</span><br></pre></td></tr></table></figure></p><p>而且还可以调整阈值<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>binarizer = preprocessing.Binarizer(threshold=<span class="number">1.1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>binarizer.transform(X)</span><br><span class="line">array([[ <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">1.</span>],</span><br><span class="line">       [ <span class="number">1.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>],</span><br><span class="line">       [ <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>]])</span><br></pre></td></tr></table></figure></p><h2 id="标签预处理（Label-preprocessing）"><a href="#标签预处理（Label-preprocessing）" class="headerlink" title="标签预处理（Label preprocessing）"></a>标签预处理（Label preprocessing）</h2><h3 id="标签二值化（Label-binarization）"><a href="#标签二值化（Label-binarization）" class="headerlink" title="标签二值化（Label binarization）"></a>标签二值化（Label binarization）</h3><p>LabelBinarizer通常用于通过一个多类标签（label）列表，创建一个label指示器矩阵<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>lb = preprocessing.LabelBinarizer()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lb.fit([<span class="number">1</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">2</span>])</span><br><span class="line">LabelBinarizer(neg_label=<span class="number">0</span>, pos_label=<span class="number">1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lb.classes_</span><br><span class="line">array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lb.transform([<span class="number">1</span>, <span class="number">6</span>])</span><br><span class="line">array([[<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">       [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>]])</span><br></pre></td></tr></table></figure></p><p>上例中每个实例中只有一个标签（label），LabelBinarizer也支持每个实例数据显示多个标签：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>lb.fit_transform([(<span class="number">1</span>, <span class="number">2</span>), (<span class="number">3</span>,)]) <span class="comment">#(1,2)实例中就包含两个label</span></span><br><span class="line">array([[<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>],</span><br><span class="line">       [<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lb.classes_</span><br><span class="line">array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br></pre></td></tr></table></figure></p><h3 id="标签编码（Label-encoding）"><a href="#标签编码（Label-encoding）" class="headerlink" title="标签编码（Label encoding）"></a>标签编码（Label encoding）</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> sklearn <span class="keyword">import</span> preprocessing</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>le = preprocessing.LabelEncoder()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>le.fit([<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">6</span>])</span><br><span class="line">LabelEncoder()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>le.classes_</span><br><span class="line">array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">6</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>le.transform([<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">6</span>])</span><br><span class="line">array([<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>le.inverse_transform([<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>])</span><br><span class="line">array([<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">6</span>])</span><br></pre></td></tr></table></figure><p>也可以用于非数值类型的标签到数值类型标签的转化：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>le = preprocessing.LabelEncoder()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>le.fit([<span class="string">"paris"</span>, <span class="string">"paris"</span>, <span class="string">"tokyo"</span>, <span class="string">"amsterdam"</span>])</span><br><span class="line">LabelEncoder()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(le.classes_)</span><br><span class="line">[<span class="string">'amsterdam'</span>, <span class="string">'paris'</span>, <span class="string">'tokyo'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>le.transform([<span class="string">"tokyo"</span>, <span class="string">"tokyo"</span>, <span class="string">"paris"</span>])</span><br><span class="line">array([<span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(le.inverse_transform([<span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>]))</span><br><span class="line">[<span class="string">'tokyo'</span>, <span class="string">'tokyo'</span>, <span class="string">'paris'</span>]</span><br></pre></td></tr></table></figure></p><h2 id="离散变量编码"><a href="#离散变量编码" class="headerlink" title="离散变量编码"></a>离散变量编码</h2><p>例如性别有‘男’， ‘女’，然而计算机的许多模型都只能在数值型数据当中进行计算，如果我们简单的将‘男’为1，‘女’为0，虽然也可以完成转换，但是在转换的过程当中我们引入了大小关系，就是‘女’ &lt; ‘男’，这会对后续模型应用造成不必要的困扰。<br>解决方法为OneHotEncode，就是将其转化为二进制串，除了当前值所在位置为1，其他全部为0，如[0,0,1,0,0], [0,1,0,0,0].。性别可表示为男为[1,0]，女为[0,1]，这样一个性别特征就转化成了两个特征。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">df = pd.DataFrame(&#123;<span class="string">'pet'</span>: [<span class="string">'cat'</span>, <span class="string">'dog'</span>, <span class="string">'dog'</span>, <span class="string">'fish'</span>],<span class="string">'age'</span>: [<span class="number">4</span> , <span class="number">6</span>, <span class="number">3</span>, <span class="number">3</span>],</span><br><span class="line"><span class="string">'salary'</span>:[<span class="number">4</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">1</span>]&#125;)</span><br><span class="line"><span class="comment">#例如有数据比较大，OneHotEncoder会生成非常多的特征，或者为字符串数据，先转化为数字，所以先用LabelEncoder处理。</span></span><br><span class="line">label = preprocessing.LabelEncoder()</span><br><span class="line">df[<span class="string">'pet'</span>] = label.fit_transform(df[<span class="string">'pet'</span>])</span><br><span class="line">one_hot = preprocessing.OneHotEncoder(sparse = <span class="keyword">False</span>)</span><br><span class="line"><span class="keyword">print</span> one_hot.fit_transform(df[[<span class="string">'pet'</span>]])</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">before</span><br><span class="line">   age  pet  salary</span><br><span class="line">0    4    0       4</span><br><span class="line">1    6    1       5</span><br><span class="line">2    3    1       1</span><br><span class="line">3    3    2       1</span><br><span class="line">after</span><br><span class="line">[[ 1.  0.  0.]</span><br><span class="line"> [ 0.  1.  0.]</span><br><span class="line"> [ 0.  1.  0.]</span><br><span class="line"> [ 0.  0.  1.]]</span><br></pre></td></tr></table></figure><h2 id="缺失值处理"><a href="#缺失值处理" class="headerlink" title="缺失值处理"></a>缺失值处理</h2><p>sklearn中的Imputer类提供了一些基本的方法来处理缺失值，如使用均值、中位值或者缺失值所在列中频繁出现的值来替换。<br>例如使用均值来处理的实例：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> numpy <span class="keyword">as</span> np  </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> Imputer  </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>imp = Imputer(missing_values=<span class="string">'NaN'</span>, strategy=<span class="string">'mean'</span>, axis=<span class="number">0</span>)  </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>imp.fit([[<span class="number">1</span>, <span class="number">2</span>], [np.nan, <span class="number">3</span>], [<span class="number">7</span>, <span class="number">6</span>]])  </span><br><span class="line">Imputer(axis=<span class="number">0</span>, copy=<span class="keyword">True</span>, missing_values=<span class="string">'NaN'</span>, strategy=<span class="string">'mean'</span>, verbose=<span class="number">0</span>)  </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>X = [[np.nan, <span class="number">2</span>], [<span class="number">6</span>, np.nan], [<span class="number">7</span>, <span class="number">6</span>]]  </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(imp.transform(X))                             </span><br><span class="line">[[ <span class="number">4.</span>          <span class="number">2.</span>        ]  </span><br><span class="line"> [ <span class="number">6.</span>          <span class="number">3.666</span>...]  </span><br><span class="line"> [ <span class="number">7.</span>          <span class="number">6.</span>        ]]</span><br></pre></td></tr></table></figure></p><p>Imputer也支持稀疏矩阵作为输入：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> scipy.sparse <span class="keyword">as</span> sp</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>X = sp.csc_matrix([[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">0</span>, <span class="number">3</span>], [<span class="number">7</span>, <span class="number">6</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>imp = Imputer(missing_values=<span class="number">0</span>, strategy=<span class="string">'mean'</span>, axis=<span class="number">0</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>imp.fit(X)</span><br><span class="line">Imputer(axis=<span class="number">0</span>, copy=<span class="keyword">True</span>, missing_values=<span class="number">0</span>, strategy=<span class="string">'mean'</span>, verbose=<span class="number">0</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>X_test = sp.csc_matrix([[<span class="number">0</span>, <span class="number">2</span>], [<span class="number">6</span>, <span class="number">0</span>], [<span class="number">7</span>, <span class="number">6</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(imp.transform(X_test))                      </span><br><span class="line">[[ <span class="number">4.</span>          <span class="number">2.</span>        ]</span><br><span class="line"> [ <span class="number">6.</span>          <span class="number">3.666</span>...]</span><br><span class="line"> [ <span class="number">7.</span>          <span class="number">6.</span>        ]]</span><br></pre></td></tr></table></figure></p><h2 id="维度拓展"><a href="#维度拓展" class="headerlink" title="维度拓展"></a>维度拓展</h2><p>考虑复杂化非线性特征，就是生成多项式特征，例如(x1,x2)−&gt;(x1,x2,x21,x1x2,x22)，会使特征数量增加<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">poly = PolynomialFeatures(<span class="number">2</span>)<span class="comment">#参数为阶数</span></span><br><span class="line">poly.fit_transform(X) </span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">before </span></span><br><span class="line"><span class="string">[[0, 1],</span></span><br><span class="line"><span class="string"> [2, 3],</span></span><br><span class="line"><span class="string"> [4, 5]]</span></span><br><span class="line"><span class="string">after</span></span><br><span class="line"><span class="string">[[  1.,   0.,   1.,   0.,   0.,   1.],</span></span><br><span class="line"><span class="string"> [  1.,   2.,   3.,   4.,   6.,   9.],</span></span><br><span class="line"><span class="string"> [  1.,   4.,   5.,  16.,  20.,  25.]]</span></span><br></pre></td></tr></table></figure></p><p>参考：<br><a href="http://scikit-learn.org/stable/modules/preprocessing.html#preprocessing-normalization" target="_blank" rel="noopener">http://scikit-learn.org/stable/modules/preprocessing.html#preprocessing-normalization</a><br><a href="http://blog.csdn.net/u010787640/article/details/60956164" target="_blank" rel="noopener">http://blog.csdn.net/u010787640/article/details/60956164</a><br><a href="http://blog.csdn.net/shmily_skx/article/details/52946414" target="_blank" rel="noopener">http://blog.csdn.net/shmily_skx/article/details/52946414</a><br><a href="http://www.cnblogs.com/chaosimple/p/4153167.html" target="_blank" rel="noopener">http://www.cnblogs.com/chaosimple/p/4153167.html</a><br><a href="http://blog.csdn.net/csmqq/article/details/51461696" target="_blank" rel="noopener">http://blog.csdn.net/csmqq/article/details/51461696</a></p>]]></content>
      
      
      <categories>
          
          <category> sklearn学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> sklearn </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>记一次坑爹的windows下安装xgboost的经历</title>
      <link href="/2017/06/05/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%9D%91%E7%88%B9%E7%9A%84windows%E4%B8%8B%E5%AE%89%E8%A3%85xgboost%E7%9A%84%E7%BB%8F%E5%8E%86/"/>
      <url>/2017/06/05/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%9D%91%E7%88%B9%E7%9A%84windows%E4%B8%8B%E5%AE%89%E8%A3%85xgboost%E7%9A%84%E7%BB%8F%E5%8E%86/</url>
      
        <content type="html"><![CDATA[<p>近来做一个比赛，一个识别鼠标轨迹是人还是机器的二分类问题。自己用SVM和神经网络等传统的机器学习的方法都试过了，但是提交之后的结果发现并不好。正好前几天研究过几个别人做的其他比赛的解决方案，发现用的boosting方法比较多,其中尤其是xgboost。于是打算再用xgboost的模型做一下，看看结果怎么样。<br>但是，安装xgboost的过程并不轻松。试了好几种方法，最后花了一下午时间，终于安装成功。<br><a id="more"></a></p><h1 id="1-使用纯命令行安装"><a href="#1-使用纯命令行安装" class="headerlink" title="1.使用纯命令行安装"></a>1.使用纯命令行安装</h1><p>参考：<a href="http://www.th7.cn/system/win/201603/157092.shtml" target="_blank" rel="noopener">http://www.th7.cn/system/win/201603/157092.shtml</a><br><a href="http://blog.csdn.net/ychanmy/article/details/50972530" target="_blank" rel="noopener">http://blog.csdn.net/ychanmy/article/details/50972530</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git clone --recursive https://github.com/dmlc/xgboost$ cd xgboost</span><br><span class="line">$ git submodule init</span><br><span class="line">$ git submodule update</span><br><span class="line">$cp make/mingw64.mk config.mk</span><br><span class="line">$make -j4</span><br><span class="line"></span><br><span class="line">$cd python-package</span><br><span class="line">$python setup.py install</span><br></pre></td></tr></table></figure></p><p>但是，为毛别人都能成功，我就是一直报错呢，而且google不到答案，哎。。。<br><img src="http://i.imgur.com/wMngVUt.png" alt=""><br>看来这个东西看人品的，没办法，找其他的办法吧！</p><h1 id="2-使用旧版本的xgboost"><a href="#2-使用旧版本的xgboost" class="headerlink" title="2.使用旧版本的xgboost"></a>2.使用旧版本的xgboost</h1><p>最终，在<a href="http://m.blog.csdn.net/article/details?id=53118803找到一个可用的解决方法。" target="_blank" rel="noopener">http://m.blog.csdn.net/article/details?id=53118803找到一个可用的解决方法。</a><br>下载旧版本的xgboost,<a href="http://download.csdn.net/detail/zhuqiuhui/9476012" target="_blank" rel="noopener">http://download.csdn.net/detail/zhuqiuhui/9476012</a><br>然后就很简单。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$cd xgboost</span><br><span class="line">$make -j4</span><br><span class="line"></span><br><span class="line">$cd python-package</span><br><span class="line">$python setup.py install</span><br></pre></td></tr></table></figure></p><p><img src="http://i.imgur.com/9VfyKQV.png" alt=""><br>终于！不知道旧版本的xgbosot有没有什么问题，先用用试试吧！</p>]]></content>
      
      
      <categories>
          
          <category> 大数据比赛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> xgboost </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>sklearn PCA降维</title>
      <link href="/2017/06/01/sklearn-PCA%E9%99%8D%E7%BB%B4/"/>
      <url>/2017/06/01/sklearn-PCA%E9%99%8D%E7%BB%B4/</url>
      
        <content type="html"><![CDATA[<p>对于太多的特征，一般需要进行降维处理。PCA是最常用的降维的方法，sklearn提供了PCA降维的方法。</p><h1 id="函数原型"><a href="#函数原型" class="headerlink" title="函数原型"></a>函数原型</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class sklearn.decomposition.PCA(n_components=None, copy=True, whiten=False, svd_solver=&apos;auto&apos;, tol=0.0, iterated_power=&apos;auto&apos;, random_state=None)</span><br></pre></td></tr></table></figure><a id="more"></a><h1 id="主要参数"><a href="#主要参数" class="headerlink" title="主要参数"></a>主要参数</h1><ol><li>n_components:<br>意义：PCA算法中所要保留的主成分个数n，也即保留下来的特征个数n<br>类型：int 或者 string，缺省时默认为None，所有成分被保留。<br> 赋值为int，比如n_components=1，将把原始数据降到一个维度。<br> 赋值为string，比如n_components=’mle’，将自动选取特征个数n，使得满足所要求的方差百分比。</li><li>copy:<br>类型：bool，True或者False，缺省时默认为True。<br>意义：表示是否在运行算法时，将原始训练数据复制一份。若为True，则运行PCA算法后，原始训练数据的值不            会有任何改变，因为是在原始数据的副本上进行运算；若为False，则运行PCA算法后，原始训练数据的              值会改，因为是在原始数据上进行降维计算。</li><li>whiten:<br>类型：bool，缺省时默认为False<br>意义：白化，使得每个特征具有相同的方差。</li></ol><h1 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h1><p>和参数差不多，参考<a href="http://scikit-learn.org/stable/modules/generated/sklearn.decomposition.PCA.html" target="_blank" rel="noopener">http://scikit-learn.org/stable/modules/generated/sklearn.decomposition.PCA.html</a></p><h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><p>fit(X[, y]) —— Fit the model with X.<br>fit_transform(X[, y])—— Fit the model with X and apply the dimensionality reduction on X.<br>get_covariance() —— Compute data covariance with the generative model.<br>get_params([deep]) —— Get parameters for this estimator.<br>get_precision() —— Compute data precision matrix with the generative model.<br>inverse_transform(X) —— Transform data back to its original space, i.e.,<br>score(X[, y]) —— Return the average log-likelihood of all samples<br>score_samples(X) —— Return the log-likelihood of each sample<br>set_params(**params) —— Set the parameters of this estimator.<br>transform(X) —— Apply the dimensionality reduction on X.<br>详细说明：</p><ol><li>fit(X,y=None)<br>fit()可以说是scikit-learn中通用的方法，每个需要训练的算法都会有fit()方法，它其实就是算法中的“训练”这一步骤。因为PCA是无监督学习算法，此处y自然等于None。</li><li>fit(X)，表示用数据X来训练PCA模型。<br>函数返回值：调用fit方法的对象本身。比如pca.fit(X)，表示用X对pca这个对象进行训练。</li><li>fit_transform(X)<br>用X来训练PCA模型，同时返回降维后的数据。<br>newX=pca.fit_transform(X)，newX就是降维后的数据。</li><li>inverse_transform()<br>将降维后的数据转换成原始数据，X=pca.inverse_transform(newX)</li><li>transform(X)<br>将数据X转换成降维后的数据。当模型训练好后，对于新输入的数据，都可以用transform方法来降维。<br>此外，还有get_covariance()、get_precision()、get_params(deep=True)、score(X, y=None)等方法，参考上面的英文。<h1 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h1>以一组二维的数据data为例，data如下，一共12个样本（x,y），其实就是分布在直线y=x上的点，并且聚集在x=1、2、3、4上，各3个。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>data  </span><br><span class="line">array([[ <span class="number">1.</span>  ,  <span class="number">1.</span>  ],  </span><br><span class="line">       [ <span class="number">0.9</span> ,  <span class="number">0.95</span>],  </span><br><span class="line">       [ <span class="number">1.01</span>,  <span class="number">1.03</span>],  </span><br><span class="line">       [ <span class="number">2.</span>  ,  <span class="number">2.</span>  ],  </span><br><span class="line">       [ <span class="number">2.03</span>,  <span class="number">2.06</span>],  </span><br><span class="line">       [ <span class="number">1.98</span>,  <span class="number">1.89</span>],  </span><br><span class="line">       [ <span class="number">3.</span>  ,  <span class="number">3.</span>  ],  </span><br><span class="line">       [ <span class="number">3.03</span>,  <span class="number">3.05</span>],  </span><br><span class="line">       [ <span class="number">2.89</span>,  <span class="number">3.1</span> ],  </span><br><span class="line">       [ <span class="number">4.</span>  ,  <span class="number">4.</span>  ],  </span><br><span class="line">       [ <span class="number">4.06</span>,  <span class="number">4.02</span>],  </span><br><span class="line">       [ <span class="number">3.97</span>,  <span class="number">4.01</span>]])</span><br></pre></td></tr></table></figure></li></ol><p>data这组数据，有两个特征，因为两个特征是近似相等的，所以用一个特征就能表示了，即可以降到一维。下面就来看看怎么用sklearn中的PCA算法包。<br>（1）n_components设置为1，copy默认为True，可以看到原始数据data并未改变，newData是一维的，并且明显地将原始数据分成了四类。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> sklearn.decomposition <span class="keyword">import</span> PCA   </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pca=PCA(n_components=<span class="number">1</span>)  </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>newData=pca.fit_transform(data)  </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>newData  </span><br><span class="line">array([[<span class="number">-2.12015916</span>],  </span><br><span class="line">       [<span class="number">-2.22617682</span>],  </span><br><span class="line">       [<span class="number">-2.09185561</span>],  </span><br><span class="line">       [<span class="number">-0.70594692</span>],  </span><br><span class="line">       [<span class="number">-0.64227841</span>],  </span><br><span class="line">       [<span class="number">-0.79795758</span>],  </span><br><span class="line">       [ <span class="number">0.70826533</span>],  </span><br><span class="line">       [ <span class="number">0.76485312</span>],  </span><br><span class="line">       [ <span class="number">0.70139695</span>],  </span><br><span class="line">       [ <span class="number">2.12247757</span>],  </span><br><span class="line">       [ <span class="number">2.17900746</span>],  </span><br><span class="line">       [ <span class="number">2.10837406</span>]])  </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>data  </span><br><span class="line">array([[ <span class="number">1.</span>  ,  <span class="number">1.</span>  ],  </span><br><span class="line">       [ <span class="number">0.9</span> ,  <span class="number">0.95</span>],  </span><br><span class="line">       [ <span class="number">1.01</span>,  <span class="number">1.03</span>],  </span><br><span class="line">       [ <span class="number">2.</span>  ,  <span class="number">2.</span>  ],  </span><br><span class="line">       [ <span class="number">2.03</span>,  <span class="number">2.06</span>],  </span><br><span class="line">       [ <span class="number">1.98</span>,  <span class="number">1.89</span>],  </span><br><span class="line">       [ <span class="number">3.</span>  ,  <span class="number">3.</span>  ],  </span><br><span class="line">       [ <span class="number">3.03</span>,  <span class="number">3.05</span>],  </span><br><span class="line">       [ <span class="number">2.89</span>,  <span class="number">3.1</span> ],  </span><br><span class="line">       [ <span class="number">4.</span>  ,  <span class="number">4.</span>  ],  </span><br><span class="line">       [ <span class="number">4.06</span>,  <span class="number">4.02</span>],  </span><br><span class="line">       [ <span class="number">3.97</span>,  <span class="number">4.01</span>]])</span><br></pre></td></tr></table></figure></p><p>（2）将copy设置为False，原始数据data将发生改变。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>pca=PCA(n_components=<span class="number">1</span>,copy=<span class="keyword">False</span>)  </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>newData=pca.fit_transform(data)  </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>data  </span><br><span class="line">array([[<span class="number">-1.48916667</span>, <span class="number">-1.50916667</span>],  </span><br><span class="line">       [<span class="number">-1.58916667</span>, <span class="number">-1.55916667</span>],  </span><br><span class="line">       [<span class="number">-1.47916667</span>, <span class="number">-1.47916667</span>],  </span><br><span class="line">       [<span class="number">-0.48916667</span>, <span class="number">-0.50916667</span>],  </span><br><span class="line">       [<span class="number">-0.45916667</span>, <span class="number">-0.44916667</span>],  </span><br><span class="line">       [<span class="number">-0.50916667</span>, <span class="number">-0.61916667</span>],  </span><br><span class="line">       [ <span class="number">0.51083333</span>,  <span class="number">0.49083333</span>],  </span><br><span class="line">       [ <span class="number">0.54083333</span>,  <span class="number">0.54083333</span>],  </span><br><span class="line">       [ <span class="number">0.40083333</span>,  <span class="number">0.59083333</span>],  </span><br><span class="line">       [ <span class="number">1.51083333</span>,  <span class="number">1.49083333</span>],  </span><br><span class="line">       [ <span class="number">1.57083333</span>,  <span class="number">1.51083333</span>],  </span><br><span class="line">       [ <span class="number">1.48083333</span>,  <span class="number">1.50083333</span>]])</span><br></pre></td></tr></table></figure></p><p>（3）n_components设置为’mle’，看看效果，自动降到了1维。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>pca=PCA(n_components=<span class="string">'mle'</span>)  </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>newData=pca.fit_transform(data)  </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>newData  </span><br><span class="line">array([[<span class="number">-2.12015916</span>],  </span><br><span class="line">       [<span class="number">-2.22617682</span>],  </span><br><span class="line">       [<span class="number">-2.09185561</span>],  </span><br><span class="line">       [<span class="number">-0.70594692</span>],  </span><br><span class="line">       [<span class="number">-0.64227841</span>],  </span><br><span class="line">       [<span class="number">-0.79795758</span>],  </span><br><span class="line">       [ <span class="number">0.70826533</span>],  </span><br><span class="line">       [ <span class="number">0.76485312</span>],  </span><br><span class="line">       [ <span class="number">0.70139695</span>],  </span><br><span class="line">       [ <span class="number">2.12247757</span>],  </span><br><span class="line">       [ <span class="number">2.17900746</span>],  </span><br><span class="line">       [ <span class="number">2.10837406</span>]])</span><br></pre></td></tr></table></figure></p><p>（4）对象的属性值<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>pca.n_components  </span><br><span class="line"><span class="number">1</span>  </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pca.explained_variance_ratio_  </span><br><span class="line">array([ <span class="number">0.99910873</span>])  </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pca.explained_variance_  </span><br><span class="line">array([ <span class="number">2.55427003</span>])  </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pca.get_params  </span><br><span class="line">&lt;bound method PCA.get_params of PCA(copy=<span class="keyword">True</span>, n_components=<span class="number">1</span>, whiten=<span class="keyword">False</span>)&gt;</span><br></pre></td></tr></table></figure></p><p>我们所训练的pca对象的n_components值为1，即保留1个特征，该特征的方差为2.55427003，占所有特征的方差百分比为0.99910873，意味着几乎保留了所有的信息。get_params返回各个参数的值。<br>（5）对象的方法<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>newA=pca.transform(A)</span><br><span class="line">```  </span><br><span class="line">对新的数据A，用已训练好的pca模型进行降维。</span><br><span class="line">```python</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pca.set_params(copy=<span class="keyword">False</span>)  </span><br><span class="line">PCA(copy=<span class="keyword">False</span>, n_components=<span class="number">1</span>, whiten=<span class="keyword">False</span>)</span><br></pre></td></tr></table></figure></p><p>设置参数。</p><h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><p>在一个论坛上看到的例子<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#导入数值计算库</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="comment">#导入科学计算库</span></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="comment">#导入数据预处理库</span></span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> StandardScaler</span><br><span class="line"><span class="comment">#导入PCA算法库</span></span><br><span class="line"><span class="keyword">from</span> sklearn.decomposition <span class="keyword">import</span> PCA</span><br><span class="line"></span><br><span class="line"><span class="comment">#读取贷款状态数据从创建名为LoanStats3a的数据表</span></span><br><span class="line">LoanStats3a=pd.DataFrame(pd.read_csv(<span class="string">'LoanStats3a.csv'</span>))</span><br><span class="line"> </span><br><span class="line"><span class="comment">#查看数据表内容</span></span><br><span class="line">LoanStats3a.head()</span><br><span class="line"></span><br><span class="line"><span class="comment">#删除包含空值的特征</span></span><br><span class="line">LoanStats3a=LoanStats3a.dropna()</span><br><span class="line"></span><br><span class="line"><span class="comment">#设置特征表X</span></span><br><span class="line"><span class="comment">#将贷款数据表中的贷款特征数据单独提取出来，用于后面的降维操作。</span></span><br><span class="line">X = np.array(LoanStats3a[[<span class="string">'loan_amnt'</span>, <span class="string">'funded_amnt_inv'</span>, <span class="string">'installment'</span>,</span><br><span class="line"><span class="string">'annual_inc'</span>, <span class="string">'dti'</span>, <span class="string">'delinq_2yrs'</span>, <span class="string">'inq_last_6mths'</span>, <span class="string">'open_acc'</span>,</span><br><span class="line"><span class="string">'pub_rec'</span>, <span class="string">'revol_bal'</span>, <span class="string">'total_acc'</span>, <span class="string">'out_prncp'</span>, <span class="string">'out_prncp_inv'</span>,</span><br><span class="line"><span class="string">'total_pymnt'</span>, <span class="string">'total_pymnt_inv'</span>, <span class="string">'total_rec_prncp'</span>, <span class="string">'total_rec_int'</span>,</span><br><span class="line"><span class="string">'total_rec_late_fee'</span>, <span class="string">'recoveries'</span>, <span class="string">'collection_recovery_fee'</span>,</span><br><span class="line"><span class="string">'last_pymnt_amnt'</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment">#对特征数据进行标准化处理,去除不同数据的单位限制，将它们转化为无量纲的纯数值。</span></span><br><span class="line">sc = StandardScaler()</span><br><span class="line">X_std = sc.fit_transform(X)</span><br><span class="line"></span><br><span class="line"><span class="comment">#创建PCA对象，n_components=3</span></span><br><span class="line">pca = decomposition.PCA(n_components=<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#使用PCA对特征进行降维</span></span><br><span class="line">X_std_pca = pca.fit_transform(X_std)</span><br><span class="line"></span><br><span class="line"><span class="comment">#下面的写法与上面相同,下面进行了白化变换，数据还原之后进行了方差的归一化</span></span><br><span class="line">pca=PCA(n_components=<span class="number">6</span>,whiten=<span class="keyword">True</span>)</span><br><span class="line">pca.fit(X_std)</span><br><span class="line">newData=pca.transform(X_std)</span><br><span class="line">X=pca.inverse_transform(newData)</span><br></pre></td></tr></table></figure></p><p>本文参考：<a href="http://blog.csdn.net/u012162613/article/details/42192293" target="_blank" rel="noopener">http://blog.csdn.net/u012162613/article/details/42192293</a><br>        <a href="http://www.aboutyun.com/thread-21655-1-1.html" target="_blank" rel="noopener">http://www.aboutyun.com/thread-21655-1-1.html</a></p>]]></content>
      
      
      <categories>
          
          <category> sklearn学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> sklearn </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>lightgbm python接口的安装</title>
      <link href="/2017/05/31/lightgbm-python%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%AE%89%E8%A3%85/"/>
      <url>/2017/05/31/lightgbm-python%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<p>最近看一些大数据比赛大神们开源的解决方案，发现他们经常使用所谓数据挖掘三驾马车。恶补了一下boosting方法.现在把lightgbm的python接口的安装过程记录下来，免得以后忘了。<br>LightGBM（Light Gradient Boosting Machine）是一个基于决策树算法的快速的、分布式的、高性能 gradient boosting（GBDT、GBRT、GBM 或 MART）框架，可被用于排行、分类以及其他许多机器学习任务中。<br>开源项目地址： <a href="https://github.com/Microsoft/LightGBM" target="_blank" rel="noopener">https://github.com/Microsoft/LightGBM</a><br><a id="more"></a><br>优势：</p><blockquote><p>更快的训练效率<br>低内存使用<br>更好的准确率<br>支持并行学习<br>可处理大规模数据</p></blockquote><h1 id="1-下载源码"><a href="#1-下载源码" class="headerlink" title="1.下载源码"></a>1.下载源码</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone --recursive https://github.com/Microsoft/LightGBM</span><br></pre></td></tr></table></figure><h1 id="2-编译dll"><a href="#2-编译dll" class="headerlink" title="2.编译dll"></a>2.编译dll</h1><p>进入下载的LightGBM目录下，用VS打开windows/LightGBM.sln，生成时选择DLL和x64，然后进行编译。dll文件就会在windows/x64/DLL/目录里。<br><img src="http://i.imgur.com/lRW0CwU.png" alt=""></p><h1 id="3-安装python包"><a href="#3-安装python包" class="headerlink" title="3.安装python包"></a>3.安装python包</h1><p>进入目录python-package，执行命令<br><code>python setup.py install</code></p><h1 id="4-测试是否安装成功"><a href="#4-测试是否安装成功" class="headerlink" title="4.测试是否安装成功"></a>4.测试是否安装成功</h1><p>进入examples\python-guide，执行样例<br><code>python .\simple_example.py</code><br>如果没有报错，那就说明安装成功了！</p>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> 数据挖掘 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>hexo个人域名配置</title>
      <link href="/2017/05/31/hexo%E4%B8%AA%E4%BA%BA%E5%9F%9F%E5%90%8D%E9%85%8D%E7%BD%AE/"/>
      <url>/2017/05/31/hexo%E4%B8%AA%E4%BA%BA%E5%9F%9F%E5%90%8D%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="1-在万网上购买域名"><a href="#1-在万网上购买域名" class="headerlink" title="1.在万网上购买域名"></a>1.在万网上购买域名</h1><p><a href="https://wanwang.aliyun.com" target="_blank" rel="noopener">https://wanwang.aliyun.com</a>  或者其他域名购买网站</p><h1 id="2-配置域名解析"><a href="#2-配置域名解析" class="headerlink" title="2.配置域名解析"></a>2.配置域名解析</h1><p>进入你的管理后台<br><a id="more"></a><br><img src="http://i.imgur.com/8TZJ4q9.png" alt="管理后台"></p><h1 id="3-添加域名解析"><a href="#3-添加域名解析" class="headerlink" title="3.添加域名解析"></a>3.添加域名解析</h1><p>按下图所示添加域名解析。<br><img src="http://i.imgur.com/sRLsOBt.png" alt="添加域名解析"><br>其中，记录类型选A或CNAME，A记录的记录值就是ip地址，github(官方文档)提供了两个IP地址，192.30.252.153和192.30.252.154，这两个IP地址为github的服务器地址，两个都要填上，解析记录设置两个www和@，线路就默认就行了，CNAME记录值填你的github博客网址。</p><h1 id="4-创建CNAME文件"><a href="#4-创建CNAME文件" class="headerlink" title="4.创建CNAME文件"></a>4.创建CNAME文件</h1><p> 这些全部设置完成后，此时你并不能要申请的域名访问你的博客。接着你需要做的是在hexo根目录的source文件夹里创建CNAME文件，不带任何后缀，里面添加你的域名信息，如：xiaoyb.me。</p><h1 id="5-发布并访问"><a href="#5-发布并访问" class="headerlink" title="5.发布并访问"></a>5.发布并访问</h1><p>重新发布hexo d -g然后就可以访问你的新域名了。<br>快点试试吧！</p>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> 域名 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>eclipse下创建maven webapp项目</title>
      <link href="/2017/04/22/eclipse%E4%B8%8B%E5%88%9B%E5%BB%BAmaven-webapp%E9%A1%B9%E7%9B%AE/"/>
      <url>/2017/04/22/eclipse%E4%B8%8B%E5%88%9B%E5%BB%BAmaven-webapp%E9%A1%B9%E7%9B%AE/</url>
      
        <content type="html"><![CDATA[<p>1、开启eclipse，右键new——》other，如下图找到maven project<br><a id="more"></a><br><img src="http://i.imgur.com/tLozsmT.jpg" alt=""><br>2、选择maven project，显示创建maven项目的窗口，勾选如图所示，Create a simple project<br><img src="http://i.imgur.com/8RBxu5E.jpg" alt=""><br>3、输入maven项目的基本信息，如下图所示：<br><img src="http://i.imgur.com/m69rSeD.jpg" alt=""><br>4、完成maven项目的创建，生成相应的maven项目结果，如下所示，此处有部分结构是项目不需要的，我们需要去掉：<br><img src="http://i.imgur.com/MzkoXcz.jpg" alt=""><br>5、选择项目，右键选择Properties，进入属性页面，选择到Maven菜单下，如下图所示：<br><img src="http://i.imgur.com/wMgDBuy.jpg" alt=""><br>6、选择java版本为1.7，并去掉其他两项，如下图：<br><img src="http://i.imgur.com/SXeVRQJ.jpg" alt=""><br>7、点击ok之后，再次回到项目结构，此时项目结构比较清晰，符合我们想要创建的maven项目<br><img src="http://i.imgur.com/335DCN2.jpg" alt=""><br>8、此时webapp下的结果还没有显示出来，因为此时我们还没有配置此的项目为web项目，再次进去Properties配置，如下图所示：<br><img src="http://i.imgur.com/rNzAT8S.jpg" alt=""><br>9、点击Further configuration available…，如下：<br><img src="http://i.imgur.com/ZD9GThf.jpg" alt=""><br>10、配置src/main/webapp，并勾选生成web.xml的选项，如下：<br><img src="http://i.imgur.com/WRO3v9x.jpg" alt=""><br>11、确定之后，返回到maven菜单下去掉Dynamic Web Module的勾选，点击ok，如下所示，webapp目录结构显示出来了：<br><img src="http://i.imgur.com/XMUM5u7.jpg" alt=""><br>12、此时还需要配置，src/main/webapp为“/”项目的根目录，如下所示：<br><img src="http://i.imgur.com/VfwJFIP.jpg" alt=""><br>13、完成如上配置后，最后完成maven webapp项目结构如下图所示：<br><img src="http://i.imgur.com/ZNSDos7.jpg" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> javaweb </category>
          
      </categories>
      
      
        <tags>
            
            <tag> maven </tag>
            
            <tag> javaweb </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>为什么新生代需要两个Survivor区</title>
      <link href="/2017/04/12/%E4%B8%BA%E4%BB%80%E4%B9%88%E6%96%B0%E7%94%9F%E4%BB%A3%E9%9C%80%E8%A6%81%E4%B8%A4%E4%B8%AASurvivor%E5%8C%BA/"/>
      <url>/2017/04/12/%E4%B8%BA%E4%BB%80%E4%B9%88%E6%96%B0%E7%94%9F%E4%BB%A3%E9%9C%80%E8%A6%81%E4%B8%A4%E4%B8%AASurvivor%E5%8C%BA/</url>
      
        <content type="html"><![CDATA[<p>在JVM的新生代内存中，为什么除了Eden区，还要设置两个Survivor区？</p><h1 id="为什么要有Survivor区"><a href="#为什么要有Survivor区" class="headerlink" title="为什么要有Survivor区"></a>为什么要有Survivor区</h1><p>先不去想为什么有两个Survivor区，第一个问题是，设置Survivor区的意义在哪里？<br><a id="more"></a><br>堆内存分类<br><img src="http://i.imgur.com/SYmUFnA.png" alt="堆内存分类"><br>如果没有Survivor，Eden区每进行一次Minor GC，存活的对象就会被送到老年代。老年代很快被填满，触发Major GC（因为Major GC一般伴随着Minor GC，也可以看做触发了Full GC）。老年代的内存空间远大于新生代，进行一次Full GC消耗的时间比Minor GC长得多。你也许会问，执行时间长有什么坏处？频发的Full GC消耗的时间是非常可观的，这一点会影响大型程序的执行和响应速度，更不要说某些连接会因为超时发生连接错误了。</p><p>好，那我们来想想在没有Survivor的情况下，有没有什么解决办法，可以避免上述情况：<br><img src="http://i.imgur.com/e1qd82c.png" alt=""><br>显而易见，没有Survivor的话，上述两种解决方案都不能从根本上解决问题。</p><p>我们可以得到第一条结论：<font color="red" size="2"><strong>Survivor的存在意义，就是减少被送到老年代的对象，进而减少Full GC的发生，Survivor的预筛选保证，只有经历16次Minor GC还能在新生代中存活的对象，才会被送到老年代。</strong></font></p><h1 id="为什么要设置两个Survivor区"><a href="#为什么要设置两个Survivor区" class="headerlink" title="为什么要设置两个Survivor区"></a>为什么要设置两个Survivor区</h1><font color="red" size="2"><strong>设置两个Survivor区最大的好处就是解决了碎片化</strong></font><p>下面我们来分析一下。</p><p>为什么一个Survivor区不行？第一部分中，我们知道了必须设置Survivor区。假设现在只有一个survivor区，我们来模拟一下流程：<br>刚刚新建的对象在Eden中，一旦Eden满了，触发一次Minor GC，Eden中的存活对象就会被移动到Survivor区。这样继续循环下去，下一次Eden满了的时候，问题来了，此时进行Minor GC，Eden和Survivor各有一些存活对象，如果此时把Eden区的存活对象硬放到Survivor区，很明显这两部分对象所占有的内存是不连续的，也就导致了内存碎片化。<br>我绘制了一幅图来表明这个过程。其中色块代表对象，白色框分别代表Eden区（大）和Survivor区（小）。Eden区理所当然大一些，否则新建对象很快就导致Eden区满，进而触发Minor GC，有悖于初衷。<br><img src="http://i.imgur.com/NmSEUK3.png" alt=""><br>一个Survivor区带来碎片化</p><p>碎片化带来的风险是极大的，严重影响Java程序的性能。堆空间被散布的对象占据不连续的内存，最直接的结果就是，堆中没有足够大的连续内存空间，接下去如果程序需要给一个内存需求很大的对象分配内存。。。画面太美不敢看。。。这就好比我们爬山的时候，背包里所有东西紧挨着放，最后就可能省出一块完整的空间放相机。如果每件行李之间隔一点空隙乱放，很可能最后就要一路把相机挂在脖子上了。</p><p>那么，顺理成章的，应该建立两块Survivor区，刚刚新建的对象在Eden中，经历一次Minor GC，Eden中的存活对象就会被移动到第一块survivor space S0，Eden被清空；等Eden区再满了，就再触发一次Minor GC，Eden和S0中的存活对象又会被复制送入第二块survivor space S1（这个过程非常重要，因为这种复制算法保证了S1中来自S0和Eden两部分的存活对象占用连续的内存空间，避免了碎片化的发生）。S0和Eden被清空，然后下一轮S0与S1交换角色，如此循环往复。如果对象的复制次数达到16次，该对象就会被送到老年代中。下图中每部分的意义和上一张图一样，就不加注释了。<br><img src="http://i.imgur.com/Y0x3nl1.png" alt=""><br>两块Survivor避免碎片化<br>上述机制最大的好处就是，整个过程中，永远有一个survivor space是空的，另一个非空的survivor space无碎片。</p><p>那么，Survivor为什么不分更多块呢？比方说分成三个、四个、五个?显然，如果Survivor区再细分下去，每一块的空间就会比较小，很容易导致Survivor区满，因此，我认为两块Survivor区是经过权衡之后的最佳方案。</p><p>转自：<a href="http://blog.csdn.net/antony9118/article/details/51425581" target="_blank" rel="noopener">http://blog.csdn.net/antony9118/article/details/51425581</a></p>]]></content>
      
      
      <categories>
          
          <category> java虚拟机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java虚拟机 </tag>
            
            <tag> 垃圾回收 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>回溯算法详解</title>
      <link href="/2017/04/11/%E5%9B%9E%E6%9C%94%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3/"/>
      <url>/2017/04/11/%E5%9B%9E%E6%9C%94%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>刷题的时候碰到一个很常见的算法-回溯法，看了一些博客，感觉这个讲得通俗易懂。转过来，后面有些自己的补充。<br>&emsp;&emsp;回溯法（探索与回溯法）是一种选优搜索法，又称为试探法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法，而满足回溯条件的某个状态的点称为“回溯点”。<br><a id="more"></a><br>首先我们来看一道题目：<br>Combinations：Given two integers n and k,return all possible combinations of k numbersout of 1 … n. For example, If n = 4 and k =2, a solution is:</p><p>[<br> [2,4],<br> [3,4],<br> [2,3],<br> [1,2],<br> [1,3],<br> [1,4],<br>]<br>（做一个白话版的描述，给你两个整数 n和k，从1-n中选择k个数字的组合。比如n=4，那么从1,2,3,4中选取两个数字的组合，包括图上所述的四种。）<br>然后我们看看题目给出的框架：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combine(<span class="keyword">int</span> n, <span class="keyword">int</span> k) &#123; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>要求返回的类型是List&lt;List<integer>&gt; 也就是说将所有可能的组合list（由整数构成）放入另一个list（由list构成）中。<br>现在进行套路教学：要求返回List&lt;List<integer>&gt;，那我就给你一个List&lt;List<integer>&gt;，因此</integer></integer></integer></p><ol><li>定义一个全局List&lt;List<integer>&gt; result=new ArrayList&lt;List<integer>&gt;();</integer></integer></li><li>定义一个辅助的方法（函数）public void backtracking(int n,int k, List<integer>list){}<br>n k 总是要有的吧，加上这两个参数，前面提到List<integer> 是数字的组合，也是需要的吧，这三个是必须的，没问题吧。（可以尝试性地写参数，最后不需要的删除）</integer></integer></li><li>接着就是我们的重头戏了，如何实现这个算法？对于n=4，k=2，1,2,3,4中选2个数字，我们可以做如下尝试，加入先选择1，那我们只需要再选择一个数字，注意这时候k=1了（此时只需要选择1个数字啦）。当然，我们也可以先选择2,3 或者4，通俗化一点，我们可以选择（1-n）的所有数字，这个是可以用一个循环来描述？每次选择一个加入我们的链表list中，下一次只要再选择k-1个数字。那什么时候结束呢？当然是k&lt;0的时候啦，这时候都选完了。<br>有了上面的分析，我们可以开始填写public void backtracking(int n,int k, List<integer> list){}中的内容。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">backtracking</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> k,<span class="keyword">int</span> start,List&lt;Integer&gt; list)</span></span>&#123;  </span><br><span class="line">        <span class="keyword">if</span>(k&lt;<span class="number">0</span>)    <span class="keyword">return</span>;  </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(k==<span class="number">0</span>)&#123;  <span class="comment">//k==0表示已经找到了k个数字的组合，这时候加入全局result中  </span></span><br><span class="line">            result.add(<span class="keyword">new</span> ArrayList(list));  </span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;  </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=start;i&lt;=n;i++)&#123;  </span><br><span class="line">                list.add(i);<span class="comment">//尝试性的加入i  </span></span><br><span class="line">                <span class="comment">//开始回溯啦，下一次要找的数字减少一个所以用k-1，i+1见后面分析  </span></span><br><span class="line">                backtracking(n,k-<span class="number">1</span>,i+<span class="number">1</span>,list);  </span><br><span class="line">                <span class="comment">//（留白，有用=。=）  </span></span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></integer></li></ol><p>观察一下上述代码，我们加入了一个start变量，它是i的起点。为什么要加入它呢？比如我们第一次加入了1，下一次搜索的时候还能再搜索1了么？肯定不可以啊！我们必须从他的下一个数字开始，也就是2 、3或者4啦。所以start就是一个开始标记这个很重要啦！<br>这时候我们在主方法中加入backtracking(n,k,1,list);调试后发现答案不对啊！为什么我的答案比他长那么多？</p><p>回溯回溯当然要退回再走啦，你不退回，当然又臭又长了！所以我们要在刚才代码注释留白处加上退回语句。仔细分析刚才的过程，我们每次找到了1,2这一对答案以后，下一次希望2退出然后让3进来，1 3就是我们要找的下一个组合。如果不回退，找到了2 ，3又进来，找到了3，4又进来，所以就出现了我们的错误答案。正确的做法就是加上：list.remove(list.size()-1);他的作用就是每次清除一个空位 让后续元素加入。寻找成功，最后一个元素要退位，寻找不到，方法不可行，那么我们回退，也要移除最后一个元素。<br>所以完整的程序如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;  </span><br><span class="line">   List&lt;List&lt;Integer&gt;&gt; result=<span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();  </span><br><span class="line">   <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combine(<span class="keyword">int</span> n, <span class="keyword">int</span> k) &#123;  </span><br><span class="line">       List&lt;Integer&gt; list=<span class="keyword">new</span> ArrayList&lt;Integer&gt;();  </span><br><span class="line">       backtracking(n,k,<span class="number">1</span>,list);  </span><br><span class="line">       <span class="keyword">return</span> result;  </span><br><span class="line">    &#125;  </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">backtracking</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> k,<span class="keyword">int</span> start,List&lt;Integer&gt;list)</span></span>&#123;  </span><br><span class="line">       <span class="keyword">if</span>(k&lt;<span class="number">0</span>) <span class="keyword">return</span> ;  </span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span>(k==<span class="number">0</span>)&#123;  </span><br><span class="line">           result.add(<span class="keyword">new</span> ArrayList(list));  </span><br><span class="line">       &#125;<span class="keyword">else</span>&#123;  </span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> i=start;i&lt;=n;i++)&#123;  </span><br><span class="line">                list.add(i);  </span><br><span class="line">                backtracking(n,k-<span class="number">1</span>,i+<span class="number">1</span>,list);  </span><br><span class="line">                list.remove(list.size()-<span class="number">1</span>);  </span><br><span class="line">            &#125;  </span><br><span class="line">       &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>是不是有点想法了？那么我们操刀一下。<br>Combination Sum<br>Given a set ofcandidate numbers (C) and a target number (T), findall unique combinations in C where thecandidate numbers sums toT.<br>The same repeated numbermay be chosen from C unlimited numberof times.<br>Note:<br>All numbers (including target) will be positive integers.<br>The solution set must not contain duplicate combinations.<br>For example,given candidate set [2, 3, 6, 7] and target 7,<br>A solution set is:<br>[<br> [7],<br> [2,2, 3]<br>]<br>（容我啰嗦地白话下，给你一个正数数组candidate[],一个目标值target，寻找里面所有的不重复组合，让其和等于target，给你[2,3,6,7] 2+2+3=7 ,7=7,所以可能组合为[2,2,3],[7]）<br>按照前述的套路走一遍：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   List&lt;List&lt;Integer&gt;&gt; result=<span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">   <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum(<span class="keyword">int</span>[] candidates,<span class="keyword">int</span> target) &#123;</span><br><span class="line">       Arrays.sort(candidates);</span><br><span class="line">       List&lt;Integer&gt; list=<span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">       <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">backtracking</span><span class="params">(<span class="keyword">int</span>[] candidates,<span class="keyword">int</span> target,<span class="keyword">int</span> start,)</span></span>&#123;       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ol><li>全局List&lt;List<integer>&gt; result先定义</integer></li><li>回溯backtracking方法要定义，数组candidates 目标target 开头start 辅助链表List<integer> list都加上。</integer></li><li>分析算法：以[2,3,6,7]  每次尝试加入数组任何一个值，用循环来描述，表示依次选定一个值<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(inti=start;i&lt;candidates.length;i++)&#123;</span><br><span class="line">       list.add(candidates[i]);</span><br><span class="line">           &#125;</span><br></pre></td></tr></table></figure></li></ol><p>接下来回溯方法再调用。比如第一次选了2，下次还能再选2是吧，所以每次start都可以从当前i开始（ps：如果不允许重复，从i+1开始）。第一次选择2，下一次要凑的数就不是7了，而是7-2，也就是5，一般化就是remain=target-candidates[i],所以回溯方法为：<br>backtracking(candidates,target-candidates[i],i,list);<br>然后加上退回语句：list.remove(list.size()-1);<br>那么什么时候找到的解符合要求呢？自然是remain（注意区分初始的target）=0了，表示之前的组合恰好能凑出target。如果remain<0 表示凑的数太大了，组合不可行，要回退。当remain="">0 说明凑的还不够，继续凑。<br>所以完整方法如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;  </span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result=newArrayList&lt;List&lt;Integer&gt;&gt;();  </span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt;combinationSum(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target) &#123;  </span><br><span class="line">        Arrays.sort(candidates);<span class="comment">//所给数组可能无序，排序保证解按照非递减组合  </span></span><br><span class="line">        List&lt;Integer&gt; list=newArrayList&lt;Integer&gt;();  </span><br><span class="line">        backtracking(candidates,target,<span class="number">0</span>,list);<span class="comment">//给定target，start=0表示从数组第一个开始  </span></span><br><span class="line">        <span class="keyword">return</span> result;<span class="comment">//返回解的组合链表  </span></span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">backtracking</span><span class="params">(<span class="keyword">int</span>[]candidates,<span class="keyword">int</span> target,<span class="keyword">int</span> start,List&lt;Integer&gt; list)</span></span>&#123;  </span><br><span class="line">         </span><br><span class="line">            <span class="keyword">if</span>(target&lt;<span class="number">0</span>)    <span class="keyword">return</span>;<span class="comment">//凑过头了  </span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(target==<span class="number">0</span>)&#123;  </span><br><span class="line">                result.add(newArrayList&lt;&gt;(list));<span class="comment">//正好凑出答案，开心地加入解的链表    </span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;  </span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=start;i&lt;candidates.length;i++)&#123;<span class="comment">//循环试探每个数  </span></span><br><span class="line">                    list.add(candidates[i]);<span class="comment">//尝试加入  </span></span><br><span class="line">           <span class="comment">//下一次凑target-candidates[i]，允许重复，还是从i开始  </span></span><br><span class="line">                   backtracking(candidates,target-candidates[i],i,list);                     </span><br><span class="line">              list.remove(list.size()-<span class="number">1</span>);<span class="comment">//回退  </span></span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">         </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></0></p><p>是不是觉得还是有迹可循的？下一篇博客将部分回溯算法拿出来，供大家更好地发现其中的套路。<br>This structure might apply to many other backtracking questions, but here I am just going to demonstrate Subsets, Permutations, and Combination Sum.</p><p>Subsets : <a href="https://leetcode.com/problems/subsets/" target="_blank" rel="noopener">https://leetcode.com/problems/subsets/</a><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; subsets(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    backtrack(list, <span class="keyword">new</span> ArrayList&lt;&gt;(), nums, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; list , List&lt;Integer&gt; tempList, <span class="keyword">int</span> [] nums, <span class="keyword">int</span> start)</span></span>&#123;</span><br><span class="line">    list.add(<span class="keyword">new</span> ArrayList&lt;&gt;(tempList));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt; nums.length; i++)&#123;</span><br><span class="line">        tempList.add(nums[i]);</span><br><span class="line">        backtrack(list, tempList, nums, i + <span class="number">1</span>);</span><br><span class="line">        tempList.remove(tempList.size() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Subsets II (contains duplicates) : <a href="https://leetcode.com/problems/subsets-ii/" target="_blank" rel="noopener">https://leetcode.com/problems/subsets-ii/</a><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; subsetsWithDup(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    backtrack(list, <span class="keyword">new</span> ArrayList&lt;&gt;(), nums, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; list, List&lt;Integer&gt; tempList, <span class="keyword">int</span> [] nums, <span class="keyword">int</span> start)</span></span>&#123;</span><br><span class="line">    list.add(<span class="keyword">new</span> ArrayList&lt;&gt;(tempList));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt; nums.length; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i &gt; start &amp;&amp; nums[i] == nums[i-<span class="number">1</span>]) <span class="keyword">continue</span>; <span class="comment">// skip duplicates</span></span><br><span class="line">        tempList.add(nums[i]);</span><br><span class="line">        backtrack(list, tempList, nums, i + <span class="number">1</span>);</span><br><span class="line">        tempList.remove(tempList.size() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Permutations : <a href="https://leetcode.com/problems/permutations/" target="_blank" rel="noopener">https://leetcode.com/problems/permutations/</a><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permute(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">   List&lt;List&lt;Integer&gt;&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">   <span class="comment">// Arrays.sort(nums); // not necessary</span></span><br><span class="line">   backtrack(list, <span class="keyword">new</span> ArrayList&lt;&gt;(), nums);</span><br><span class="line">   <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; list, List&lt;Integer&gt; tempList, <span class="keyword">int</span> [] nums)</span></span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(tempList.size() == nums.length)&#123;</span><br><span class="line">      list.add(<span class="keyword">new</span> ArrayList&lt;&gt;(tempList));</span><br><span class="line">   &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123; </span><br><span class="line">         <span class="keyword">if</span>(tempList.contains(nums[i])) <span class="keyword">continue</span>; <span class="comment">// element already exists, skip</span></span><br><span class="line">         tempList.add(nums[i]);</span><br><span class="line">         backtrack(list, tempList, nums);</span><br><span class="line">         tempList.remove(tempList.size() - <span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Permutations II (contains duplicates) : <a href="https://leetcode.com/problems/permutations-ii/" target="_blank" rel="noopener">https://leetcode.com/problems/permutations-ii/</a><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permuteUnique(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    backtrack(list, <span class="keyword">new</span> ArrayList&lt;&gt;(), nums, <span class="keyword">new</span> <span class="keyword">boolean</span>[nums.length]);</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; list, List&lt;Integer&gt; tempList, <span class="keyword">int</span> [] nums, <span class="keyword">boolean</span> [] used)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tempList.size() == nums.length)&#123;</span><br><span class="line">        list.add(<span class="keyword">new</span> ArrayList&lt;&gt;(tempList));</span><br><span class="line">    &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(used[i] || i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i-<span class="number">1</span>] &amp;&amp; !used[i - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            used[i] = <span class="keyword">true</span>; </span><br><span class="line">            tempList.add(nums[i]);</span><br><span class="line">            backtrack(list, tempList, nums, used);</span><br><span class="line">            used[i] = <span class="keyword">false</span>; </span><br><span class="line">            tempList.remove(tempList.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Combination Sum : <a href="https://leetcode.com/problems/combination-sum/" target="_blank" rel="noopener">https://leetcode.com/problems/combination-sum/</a><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    backtrack(list, <span class="keyword">new</span> ArrayList&lt;&gt;(), nums, target, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; list, List&lt;Integer&gt; tempList, <span class="keyword">int</span> [] nums, <span class="keyword">int</span> remain, <span class="keyword">int</span> start)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(remain &lt; <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(remain == <span class="number">0</span>) list.add(<span class="keyword">new</span> ArrayList&lt;&gt;(tempList));</span><br><span class="line">    <span class="keyword">else</span>&#123; </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt; nums.length; i++)&#123;</span><br><span class="line">            tempList.add(nums[i]);</span><br><span class="line">            backtrack(list, tempList, nums, remain - nums[i], i); <span class="comment">// not i + 1 because we can reuse same elements</span></span><br><span class="line">            tempList.remove(tempList.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Combination Sum II (can’t reuse same element) : <a href="https://leetcode.com/problems/combination-sum-ii/" target="_blank" rel="noopener">https://leetcode.com/problems/combination-sum-ii/</a><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum2(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    backtrack(list, <span class="keyword">new</span> ArrayList&lt;&gt;(), nums, target, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; list, List&lt;Integer&gt; tempList, <span class="keyword">int</span> [] nums, <span class="keyword">int</span> remain, <span class="keyword">int</span> start)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(remain &lt; <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(remain == <span class="number">0</span>) list.add(<span class="keyword">new</span> ArrayList&lt;&gt;(tempList));</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; start &amp;&amp; nums[i] == nums[i-<span class="number">1</span>]) <span class="keyword">continue</span>; <span class="comment">// skip duplicates</span></span><br><span class="line">            tempList.add(nums[i]);</span><br><span class="line">            backtrack(list, tempList, nums, remain - nums[i], i + <span class="number">1</span>);</span><br><span class="line">            tempList.remove(tempList.size() - <span class="number">1</span>); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Palindrome Partitioning : <a href="https://leetcode.com/problems/palindrome-partitioning/" target="_blank" rel="noopener">https://leetcode.com/problems/palindrome-partitioning/</a></p><pre><code class="java"><span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; partition(String s) {   List&lt;List&lt;String&gt;&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();   backtrack(list, <span class="keyword">new</span> ArrayList&lt;&gt;(), s, <span class="number">0</span>);   <span class="keyword">return</span> list;}<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(List&lt;List&lt;String&gt;&gt; list, List&lt;String&gt; tempList, String s, <span class="keyword">int</span> start)</span></span>{   <span class="keyword">if</span>(start == s.length())      list.add(<span class="keyword">new</span> ArrayList&lt;&gt;(tempList));   <span class="keyword">else</span>{      <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt; s.length(); i++){         <span class="keyword">if</span>(isPalindrome(s, start, i)){            tempList.add(s.substring(start, i + <span class="number">1</span>));            backtrack(list, tempList, s, i + <span class="number">1</span>);            tempList.remove(tempList.size() - <span class="number">1</span>);         }      }   }}<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(String s, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span>{   <span class="keyword">while</span>(low &lt; high)      <span class="keyword">if</span>(s.charAt(low++) != s.charAt(high--)) <span class="keyword">return</span> <span class="keyword">false</span>;   <span class="keyword">return</span> <span class="keyword">true</span>;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 回溯法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java源码之StringBuffer,StringBuilder</title>
      <link href="/2017/04/10/Java%E6%BA%90%E7%A0%81%E4%B9%8BStringBuffer-StringBuilder/"/>
      <url>/2017/04/10/Java%E6%BA%90%E7%A0%81%E4%B9%8BStringBuffer-StringBuilder/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> java源码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java源码 </tag>
            
            <tag> StringBuffer </tag>
            
            <tag> StringBuilder </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java源码之HashSet</title>
      <link href="/2017/04/07/Java%E6%BA%90%E7%A0%81%E4%B9%8BHashSet/"/>
      <url>/2017/04/07/Java%E6%BA%90%E7%A0%81%E4%B9%8BHashSet/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>1.HashSet 是一个没有重复元素的集合。它是由HashMap实现的，不保证元素的顺序，特别是它不保证该顺序恒久不变。而且HashSet允许使用 null 元素。<br>2.HashSet是非同步的。如果多个线程同时访问一个哈希 set，而其中至少一个线程修改了该 set，那么它必须保持外部同步。这通常是通过对自然封装该 set 的对象执行同步操作来完成的。如果不存在这样的对象，则应该使用 Collections.synchronizedSet 方法来“包装” Set。最好在创建时完成这一操作，以防止对该 set 进行意外的不同步访问：<br><a id="more"></a><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set s = Collections.synchronizedSet(<span class="keyword">new</span> HashSet(...));</span><br></pre></td></tr></table></figure></p><p>3.HashSet通过iterator()返回的迭代器是fail-fast的。<br>4.HashSet的继承关系如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashSet</span>&lt;<span class="title">E</span>&gt;  </span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">E</span>&gt;  </span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Set</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure></p><h1 id="HashSet实现"><a href="#HashSet实现" class="headerlink" title="HashSet实现"></a>HashSet实现</h1><p>HashSet是基于HashMap实现的，底层使用HashMap来保存所有元素，相关HashSet的操作，基本上都是直接调用底层HashMap的相关方法来完成.</p><h2 id="HashSet属性"><a href="#HashSet属性" class="headerlink" title="HashSet属性"></a>HashSet属性</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>.<span class="keyword">private</span> <span class="keyword">transient</span> HashMap&lt;E,Object&gt; map;  </span><br><span class="line"><span class="number">2</span>.  <span class="comment">// Dummy value to associate with an Object in the backing Map </span></span><br><span class="line"><span class="number">3</span>.<span class="comment">// 定义一个虚拟的Object对象作为HashMap的value，将此对象定义为static final。  </span></span><br><span class="line"><span class="number">4</span>.<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object PRESENT = <span class="keyword">new</span> Object();</span><br></pre></td></tr></table></figure><p>可以看到，HashSet 实际上是使用 HashMap 来保存数据的。而且主要用的是 HashMap的 key。<br>PRESENT是什么东西呢？看上面的注释。dummy的意思是 挂名代表，傀儡。所以，可知：<br>PRESENT是向map中插入key-value对应的value<br>因为HashSet中只需要用到key，而HashMap是key-value键值对；<br>所以，向map中添加键值对时，键值对的值固定是PRESENT。每个set集合<br>中的元素都是HashMap的key 值（这也就保证了HashSet集合中不能有重复元素），而    它们的value值都是 PRESENT。</p><h2 id="HashSet构造函数"><a href="#HashSet构造函数" class="headerlink" title="HashSet构造函数"></a>HashSet构造函数</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>. <span class="comment">/**  </span></span><br><span class="line"><span class="comment">2.     * 默认的无参构造器，构造一个空的HashSet。</span></span><br><span class="line"><span class="comment">3.     *  </span></span><br><span class="line"><span class="comment">4.     * 实际底层会初始化一个空的HashMap，并使用默认初始容量为16和加载因子0.75。  </span></span><br><span class="line"><span class="comment">5.     */</span>    </span><br><span class="line"><span class="number">6</span>.    <span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">()</span> </span>&#123;    </span><br><span class="line"><span class="number">7</span>.    map = <span class="keyword">new</span> HashMap&lt;E,Object&gt;();    </span><br><span class="line"><span class="number">8</span>.    &#125;    </span><br><span class="line"><span class="number">9</span>.    <span class="comment">/**  </span></span><br><span class="line"><span class="comment">10.     * 构造一个包含指定collection中的元素的新set。  </span></span><br><span class="line"><span class="comment">11.     * 实际底层使用默认的加载因子0.75和足以包含指定  </span></span><br><span class="line"><span class="comment">12.     * collection中所有元素的初始容量来创建一个HashMap。  </span></span><br><span class="line"><span class="comment">13.     * <span class="doctag">@param</span> c 其中的元素将存放在此set中的collection。  </span></span><br><span class="line"><span class="comment">14.     */</span>    </span><br><span class="line"><span class="number">15</span>.    <span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;    </span><br><span class="line"><span class="number">16</span>.     <span class="comment">//为什么是Math.max((int) (c.size()/.75f) + 1, 16)？</span></span><br><span class="line"><span class="number">17</span>.    <span class="comment">//实际上默认的HashMap的加载因子是0.75,c.size()/0.75 就是HashMap的实际容量，而 16 是默认的HashMap的初始容量。所以取两者的较大值作为 HashSet的容量。</span></span><br><span class="line"><span class="number">18</span>.    map = <span class="keyword">new</span> HashMap&lt;E,Object&gt;(Math.max((<span class="keyword">int</span>) (c.size()/.<span class="number">75f</span>) + <span class="number">1</span>, <span class="number">16</span>));   </span><br><span class="line"><span class="number">19</span>.    <span class="comment">// 使用Collection实现的Iterator迭代器，将集合c的元素一个个加入HashSet中</span></span><br><span class="line"><span class="number">20</span>.    addAll(c);    </span><br><span class="line"><span class="number">21</span>.   &#125;    </span><br><span class="line"><span class="number">22</span>.    <span class="comment">/**  </span></span><br><span class="line"><span class="comment">23.     * 以指定的initialCapacity和loadFactor构造一个空的HashSet。  </span></span><br><span class="line"><span class="comment">24.     *  </span></span><br><span class="line"><span class="comment">25.     * 实际底层以以指定的initialCapacity和loadFactor构造一个空的HashMap。  </span></span><br><span class="line"><span class="comment">26.     * <span class="doctag">@param</span> initialCapacity 初始容量。  </span></span><br><span class="line"><span class="comment">27.     * <span class="doctag">@param</span> loadFactor 加载因子。  </span></span><br><span class="line"><span class="comment">28.    */</span>    </span><br><span class="line"><span class="number">29</span>.    <span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;    </span><br><span class="line"><span class="number">30</span>.   map = <span class="keyword">new</span> HashMap&lt;E,Object&gt;(initialCapacity, loadFactor);    </span><br><span class="line"><span class="number">31</span>.    &#125;    </span><br><span class="line"><span class="number">32</span>.    <span class="comment">/**  </span></span><br><span class="line"><span class="comment">33.     * 以指定的initialCapacity构造一个空的HashSet。  </span></span><br><span class="line"><span class="comment">34.    *  </span></span><br><span class="line"><span class="comment">35.     * 实际底层以相应的参数及加载因子loadFactor为0.75构造一个空的HashMap。  </span></span><br><span class="line"><span class="comment">36.     * <span class="doctag">@param</span> initialCapacity 初始容量。  </span></span><br><span class="line"><span class="comment">37.     */</span>    </span><br><span class="line"><span class="number">38</span>.   <span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;    </span><br><span class="line"><span class="number">39</span>.    map = <span class="keyword">new</span> HashMap&lt;E,Object&gt;(initialCapacity);    </span><br><span class="line"><span class="number">40</span>.    &#125;    </span><br><span class="line"><span class="number">41</span>.    <span class="comment">/**  </span></span><br><span class="line"><span class="comment">42.     * 以指定的initialCapacity和loadFactor构造一个新的空链接哈希集合。  </span></span><br><span class="line"><span class="comment">43.    * 此构造函数为包访问权限，不对外公开，实际只是是对LinkedHashSet的支持。  </span></span><br><span class="line"><span class="comment">44.     *  </span></span><br><span class="line"><span class="comment">45.     * 实际底层会以指定的参数构造一个空LinkedHashMap实例来实现。  </span></span><br><span class="line"><span class="comment">46.     * <span class="doctag">@param</span> initialCapacity 初始容量。  </span></span><br><span class="line"><span class="comment">47.     * <span class="doctag">@param</span> loadFactor 加载因子。  </span></span><br><span class="line"><span class="comment">48.     * <span class="doctag">@param</span> dummy 标记。  没有实际意义</span></span><br><span class="line"><span class="comment">49.    */</span>    </span><br><span class="line"><span class="number">50</span>.   HashSet(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor, <span class="keyword">boolean</span> dummy) &#123;    </span><br><span class="line"><span class="number">51</span>.   map = <span class="keyword">new</span> LinkedHashMap&lt;E,Object&gt;(initialCapacity, loadFactor);    </span><br><span class="line"><span class="number">52</span>.    &#125;</span><br></pre></td></tr></table></figure><h2 id="HashSet方法"><a href="#HashSet方法" class="headerlink" title="HashSet方法"></a>HashSet方法</h2><p>因为HashSet底层是HashMap实现，所以它的方法大都是直接调用HashMap的方法。</p><h3 id="add-remove"><a href="#add-remove" class="headerlink" title="add(),remove()"></a>add(),remove()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>.<span class="comment">// 将元素(e)添加到HashSet中，也就是将元素作为Key放入HashMap中public boolean add(E e) &#123;  </span></span><br><span class="line"><span class="number">2</span>.      <span class="keyword">return</span> map.put(e, PRESENT)==<span class="keyword">null</span>;  <span class="comment">//可以看到PRESENT是value值。</span></span><br><span class="line"><span class="number">3</span>.  &#125;  </span><br><span class="line"><span class="number">4</span>.<span class="comment">//  删除HashSet中的元素(o)，其实是在HashMap中删除了以o为key的Entry</span></span><br><span class="line"><span class="number">5</span>.<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;  </span><br><span class="line"><span class="number">6</span>.      <span class="keyword">return</span> map.remove(o)==PRESENT;  </span><br><span class="line"><span class="number">7</span>.  &#125;  </span><br><span class="line"><span class="number">1</span>.  <span class="comment">// 清空HashMap,的clear方法清空所有Entry</span></span><br><span class="line"><span class="number">2</span>.<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="number">3</span>.        map.clear();    </span><br><span class="line"><span class="number">4</span>.  &#125;</span><br></pre></td></tr></table></figure><p>具体可参考HashMap的源码。</p><h3 id="iterator-size-，isEmpty"><a href="#iterator-size-，isEmpty" class="headerlink" title="iterator(),size()，isEmpty()"></a>iterator(),size()，isEmpty()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>.<span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;  </span><br><span class="line"><span class="number">2</span>.     <span class="comment">// 实际上返回的是HashMap的“key集合”的迭代器</span></span><br><span class="line"><span class="number">3</span>.       <span class="keyword">return</span> map.keySet().iterator();  </span><br><span class="line"><span class="number">4</span>.   &#125;  </span><br><span class="line"><span class="number">5</span>.<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;  </span><br><span class="line"><span class="number">6</span>.       <span class="keyword">return</span> map.size();  </span><br><span class="line"><span class="number">7</span>.   &#125;  </span><br><span class="line"><span class="number">8</span>. <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;  </span><br><span class="line"><span class="number">9</span>.       <span class="keyword">return</span> map.isEmpty(); <span class="comment">//查看map是否是空 </span></span><br><span class="line"><span class="number">10</span>.   &#125;  </span><br><span class="line"><span class="number">11</span>.   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;  </span><br><span class="line"><span class="number">12</span>.       <span class="keyword">return</span> map.containsKey(o); <span class="comment">//map中是否包含键 0 </span></span><br><span class="line"><span class="number">13</span>.   &#125;</span><br></pre></td></tr></table></figure><p>看名字很容易就知道是干嘛的，都是直接用的HashMap的方法。</p><h3 id="clone"><a href="#clone" class="headerlink" title="clone()"></a>clone()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>.<span class="comment">/** </span></span><br><span class="line"><span class="comment">2.     * 返回此HashSet实例的浅表副本：并没有复制这些元素本身。 </span></span><br><span class="line"><span class="comment">3.    * 底层实际调用HashMap的clone()方法，获取HashMap的浅表副本，并设置到  HashSet中。 </span></span><br><span class="line"><span class="comment">4.     */</span>  </span><br><span class="line"><span class="number">5</span>.<span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> </span>&#123;  </span><br><span class="line"><span class="number">6</span>.      <span class="keyword">try</span> &#123;  </span><br><span class="line"><span class="number">7</span>.          HashSet&lt;E&gt; newSet = (HashSet&lt;E&gt;) <span class="keyword">super</span>.clone();  </span><br><span class="line"><span class="number">8</span>.          newSet.map = (HashMap&lt;E, Object&gt;) map.clone();  </span><br><span class="line"><span class="number">9</span>.          <span class="keyword">return</span> newSet;  </span><br><span class="line"><span class="number">10</span>.      &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;  </span><br><span class="line"><span class="number">11</span>.          <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(e);  </span><br><span class="line"><span class="number">12</span>.      &#125;  </span><br><span class="line"><span class="number">13</span>.  &#125;</span><br></pre></td></tr></table></figure><h3 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>.     <span class="comment">// java.io.Serializable的写入流中 </span></span><br><span class="line"><span class="number">2</span>.    <span class="comment">// 将HashSet的“总的容量，加载因子，实际容量，所有的元素”都写入到输出流中  </span></span><br><span class="line"><span class="number">3</span>.    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(java.io.ObjectOutputStream s)</span>  </span></span><br><span class="line"><span class="function">4.        <span class="keyword">throws</span> java.io.IOException </span>&#123;  </span><br><span class="line"><span class="number">5</span>.        <span class="comment">// Write out any hidden serialization magic  </span></span><br><span class="line"><span class="number">6</span>.        s.defaultWriteObject();  </span><br><span class="line"><span class="number">7</span>.        s.writeInt(map.capacity());  </span><br><span class="line"><span class="number">8</span>.        s.writeFloat(map.loadFactor());  </span><br><span class="line"><span class="number">9</span>.        <span class="comment">// Write out size  </span></span><br><span class="line"><span class="number">10</span>.        s.writeInt(map.size());  </span><br><span class="line"><span class="number">11</span>.        <span class="comment">// Write out all elements in the proper order.  </span></span><br><span class="line"><span class="number">12</span>.        <span class="keyword">for</span> (Iterator i=map.keySet().iterator(); i.hasNext(); )  </span><br><span class="line"><span class="number">13</span>.            s.writeObject(i.next());  </span><br><span class="line"><span class="number">14</span>.    &#125;  </span><br><span class="line"><span class="number">15</span>.    <span class="comment">// java.io.Serializable 从流中读取 HashSet对象 </span></span><br><span class="line"><span class="number">16</span>.    <span class="comment">// 将HashSet的“总的容量，加载因子，实际容量，所有的元素”依次读出  </span></span><br><span class="line"><span class="number">17</span>.    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(java.io.ObjectInputStream s)</span>  </span></span><br><span class="line"><span class="function">18.        <span class="keyword">throws</span> java.io.IOException, ClassNotFoundException </span>&#123;  </span><br><span class="line"><span class="number">19</span>.        <span class="comment">// Read in any hidden serialization magic  </span></span><br><span class="line"><span class="number">20</span>.        s.defaultReadObject();  </span><br><span class="line"><span class="number">21</span>. </span><br><span class="line"><span class="number">22</span>.        <span class="keyword">int</span> capacity = s.readInt();  </span><br><span class="line"><span class="number">23</span>.        <span class="keyword">float</span> loadFactor = s.readFloat();  </span><br><span class="line"><span class="number">24</span>.        map = (((HashSet)<span class="keyword">this</span>) <span class="keyword">instanceof</span> LinkedHashSet ?  </span><br><span class="line"><span class="number">25</span>.               <span class="keyword">new</span> LinkedHashMap&lt;E,Object&gt;(capacity, loadFactor) :  </span><br><span class="line"><span class="number">26</span>.               <span class="keyword">new</span> HashMap&lt;E,Object&gt;(capacity, loadFactor));  </span><br><span class="line"><span class="number">27</span>.        <span class="comment">// Read in size  </span></span><br><span class="line"><span class="number">28</span>.        <span class="keyword">int</span> size = s.readInt();  </span><br><span class="line"><span class="number">29</span>.        <span class="comment">// Read in all elements in the proper order.  </span></span><br><span class="line"><span class="number">30</span>.        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; i++) &#123;  </span><br><span class="line"><span class="number">31</span>.            E e = (E) s.readObject();  </span><br><span class="line"><span class="number">32</span>.            map.put(e, PRESENT);  </span><br><span class="line"><span class="number">33</span>.        &#125;  </span><br><span class="line"><span class="number">34</span>.    &#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>  总体来说，HashSet是比较简单的，底层是HashMap实现的，使用的都是HashMap的方法。</p><h2 id="HashSet遍历："><a href="#HashSet遍历：" class="headerlink" title="HashSet遍历："></a>HashSet遍历：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">      <span class="comment">//遍历  </span></span><br><span class="line"><span class="number">2</span>.        Iterator iterator = set.iterator();  </span><br><span class="line"><span class="number">3</span>.        <span class="keyword">while</span> (iterator.hasNext()) &#123;  </span><br><span class="line"><span class="number">4</span>.            System.out.println(iterator.next());              </span><br><span class="line"><span class="number">5</span>.        &#125;     </span><br><span class="line"><span class="number">6</span>.          </span><br><span class="line"><span class="number">7</span>.        <span class="comment">//或者这样  </span></span><br><span class="line"><span class="number">8</span>.        <span class="keyword">for</span> (String s:set) &#123;  </span><br><span class="line"><span class="number">9</span>.            System.out.println(s);  </span><br><span class="line"><span class="number">10</span>.        &#125;</span><br></pre></td></tr></table></figure><p>要注意的是：当我们要将一个类作为HashMap的key或者存储在HashSet的时候。通过重写hashCode()和equals(Object object)方法很重要，并且保证这两个方法的返回值一致。当两个类的hashCode()返回一致时，应该保证equasl()方法也返回true。<br>HashMap源码整理中…</p>]]></content>
      
      
      <categories>
          
          <category> java源码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> HashSet </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>java源码之ArrayList</title>
      <link href="/2017/04/06/java%E6%BA%90%E7%A0%81%E4%B9%8BArrayList/"/>
      <url>/2017/04/06/java%E6%BA%90%E7%A0%81%E4%B9%8BArrayList/</url>
      
        <content type="html"><![CDATA[<h1 id="ArrayList概述："><a href="#ArrayList概述：" class="headerlink" title="ArrayList概述："></a>ArrayList概述：</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure><p>ArrayList是基于数组实现的，Object[] elementData;是一个动态数组，其容量能自动增长。<br><a id="more"></a><br>ArrayList与Collection关系如下图：<br>　　 <img src="http://i.imgur.com/10g3wby.jpg" alt="ArrayList和Collection"></p><p>１．ArrayList不是线程安全的，只能用在单线程环境下，多线程环境下可以考虑用Collections.synchronizedList(List l)函数返回一个线程安全的ArrayList类，也可以使用concurrent并发包下的CopyOnWriteArrayList类。<br>２．ArrayList实现了Serializable接口，因此它支持序列化，能够通过序列化传输，实现了RandomAccess接口，支持快速随机访问，实际上就是通过下标序号进行快速访问，实现了Cloneable接口，能被克隆。<br>３．每个ArrayList实例都有一个容量，该容量是指用来存储列表元素的数组的大小。它总是至少等于列表的大小。随着向ArrayList中不断添加元素，其容量也自动增长。自动增长会带来数据向新数组的重新拷贝，因此，如果可预知数据量的多少，可在构造ArrayList时指定其容量。在添加大量元素前，应用程序也可以使用ensureCapacity操作来增加ArrayList实例的容量，这可以减少递增式再分配的数量。<br>注意，此实现不是同步的。如果多个线程同时访问一个ArrayList实例，而其中至少一个线程从结构上修改了列表，那么它必须保持外部同步。 </p><h1 id="ArrayList的实现："><a href="#ArrayList的实现：" class="headerlink" title="ArrayList的实现："></a>ArrayList的实现：</h1><p>对于ArrayList而言，它实现List接口、底层使用数组保存所有元素。其操作基本上是对数组的操作。下面我们来分析ArrayList的源代码：</p><h2 id="私有属性："><a href="#私有属性：" class="headerlink" title="私有属性："></a>私有属性：</h2><p>ArrayList定义只定义类两个私有属性：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment">* The array buffer into which the elements of the ArrayList are stored</span></span><br><span class="line"><span class="comment">* The capacity of the ArrayList is the length of this array buffer.  </span></span><br><span class="line"><span class="comment"> */</span>    </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Object[] elementData;    </span><br><span class="line"></span><br><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment">* The size of the ArrayList (the number of elements it contains).  </span></span><br><span class="line"><span class="comment">* <span class="doctag">@serial</span>  </span></span><br><span class="line"><span class="comment">*/</span>    </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> size;</span><br></pre></td></tr></table></figure></p><p>很容易理解，elementData存储ArrayList内的元素，size表示它包含的元素的数量。<br>有个关键字需要解释：transient。<br>Java的serialization提供了一种持久化对象实例的机制。当持久化对象时，可能有一个特殊的对象数据成员，我们不想用serialization机制来保存它。为了在一个特定对象的一个域上关闭serialization，可以在这个域前加上关键字transient。被标记为transient的属性在对象被序列化的时候不会被保存。<br>接着回到ArrayList的分析中……</p><h2 id="modCount和Array-copyof-，System-arraycopy。"><a href="#modCount和Array-copyof-，System-arraycopy。" class="headerlink" title="modCount和Array.copyof()，System.arraycopy。"></a>modCount和Array.copyof()，System.arraycopy。</h2><p>在父类AbstractList中定义了一个int型的属性：modCount，记录了ArrayList结构性变化的次数。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">transient</span> <span class="keyword">int</span> modCount = <span class="number">0</span>;</span><br></pre></td></tr></table></figure></p><p>在ArrayList的所有涉及结构变化的方法中都增加modCount的值，包括：add()、remove()、addAll()、removeRange()及clear()方法。这些方法每调用一次，modCount的值就加1。<br>注：add()及addAll()方法的modCount的值是在其中调用的ensureCapacity()方法中增加的。<br>然后，先了解一个方法，下面到处都会用到。Array.copyof()，System.arraycopy。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T[] copyOf(T[] original, <span class="keyword">int</span> newLength) &#123;    </span><br><span class="line">    <span class="keyword">return</span> (T[]) copyOf(original, newLength, original.getClass());    </span><br><span class="line">&#125;    </span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T,U&gt; T[] copyOf(U[] original, <span class="keyword">int</span> newLength, Class&lt;? extends T[]&gt; newType) &#123;    </span><br><span class="line">    T[] copy = ((Object)newType == (Object)Object[].class)    </span><br><span class="line">        ? (T[]) <span class="keyword">new</span> Object[newLength]   <span class="comment">// 类型相同，则重新生成一个大小为newLength的数组实例    </span></span><br><span class="line">        : (T[]) Array.newInstance(newType.getComponentType(), newLength);  <span class="comment">// 类型不同，重新生成一个大小为newLength的新类型数组实例    </span></span><br><span class="line">    System.arraycopy(original, <span class="number">0</span>, copy, <span class="number">0</span>, Math.min(original.length, newLength)); <span class="comment">//将原数组内容拷贝到新数组中,新数组取最小的数组长度    </span></span><br><span class="line">    <span class="keyword">return</span> copy;  <span class="comment">// 返回新数组的引用     </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>而其中的System.arraycopy(Object src, int srcPos, Object dest, int destPos, int length)的声明：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">arraycopy</span><span class="params">(Object src,  <span class="keyword">int</span>  srcPos,  </span></span></span><br><span class="line"><span class="function"><span class="params">                                        Object dest, <span class="keyword">int</span> destPos,  </span></span></span><br><span class="line"><span class="function"><span class="params">                                        <span class="keyword">int</span> length)</span></span>;</span><br></pre></td></tr></table></figure></p><p>src - 源数组。<br>srcPos - 源数组中的起始位置。<br>dest - 目标数组。<br>destPos - 目标数据中的起始位置。<br>length - 要复制的数组元素的数量。<br>System.arraycopy是一个native方法，是底层使用c++实现的。 </p><h2 id="构造方法："><a href="#构造方法：" class="headerlink" title="构造方法："></a>构造方法：</h2><p>ArrayList提供了三种方式的构造器，可以构造一个默认的空列表、构造一个指定初始容量的空列表以及构造一个包含指定collection的元素的列表，这些元素按照该collection的迭代器返回它们的顺序排列的。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">     * Constructs an empty list with the specified initial capacity. </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;  </span><br><span class="line">                <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;  <span class="comment">//初始容量大于0,实例化数组</span></span><br><span class="line">            <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];  </span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;  <span class="comment">//初始容量为0</span></span><br><span class="line">            <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;  <span class="comment">//空数组</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Capacity: "</span>+  </span><br><span class="line">                                               initialCapacity);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/** ArrayList无参构造函数。</span></span><br><span class="line"><span class="comment">     * Constructs an empty list with an initial capacity of ten. </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/** 创建一个包含collection的ArrayList</span></span><br><span class="line"><span class="comment">     * Constructs a list containing the elements of the specified </span></span><br><span class="line"><span class="comment">     * collection, in the order they are returned by the collection's </span></span><br><span class="line"><span class="comment">     * iterator.      */</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;  </span><br><span class="line">         elementData = c.toArray();  <span class="comment">//先转化成数组</span></span><br><span class="line">        <span class="keyword">if</span> ((size = elementData.length) != <span class="number">0</span>) &#123;  <span class="comment">//如果集合不为空</span></span><br><span class="line">          <span class="comment">// c.toArray might (incorrectly) not return Object[] </span></span><br><span class="line">          <span class="keyword">if</span> (elementData.getClass() != Object[].class)  </span><br><span class="line">  <span class="comment">//给elementData 赋值</span></span><br><span class="line">             elementData = Arrays.copyOf(elementData, size, Object[].class);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">            <span class="comment">// 如果是一个空的集合，用空数组来替换</span></span><br><span class="line">            <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>有参的两个构造器很好理解，下面说下无参的构造器。<br>EMPTY_ELEMENTDATA是什么的？看名字就知道了，是一个空的数组。DEFAULTCAPACITY_EMPTY_ELEMENTDATA也是一个空数组。那么他们之间有什么区别呢？为什么ArrayList无参构造函数构造的是一个DEFAULTCAPACITY_EMPTY_ELEMENTDATA的空数组呢？因为以前的代码是直接初始化一个长度为10的数组。看上面的注释，我们可以知道，We distinguish this from EMPTY_ELEMENTDATA to know how much to inflate when first element is added.就是当第一个元素被加入到elementData中时，区分这两者。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 默认的初始容量为10 </span></span><br><span class="line"><span class="comment">    */</span>  </span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;  </span><br><span class="line">  </span><br><span class="line">   <span class="comment">/** </span></span><br><span class="line"><span class="comment">    * Shared empty array instance used for empty instances. </span></span><br><span class="line"><span class="comment">    */</span>  </span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;  </span><br><span class="line">  </span><br><span class="line">   <span class="comment">/** </span></span><br><span class="line"><span class="comment">    * Shared empty array instance used for default sized empty instances. We</span></span><br><span class="line"><span class="comment">    * distinguish this from EMPTY_ELEMENTDATA to know how much to inflate when  first element is added. </span></span><br><span class="line"><span class="comment">    */</span>  </span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br></pre></td></tr></table></figure></p><p>既然如此，我们先看一下add()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>.<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;  </span><br><span class="line"><span class="number">2</span>.       ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!  </span></span><br><span class="line"><span class="number">3</span>.       elementData[size++] = e;  </span><br><span class="line"><span class="number">4</span>.       <span class="keyword">return</span> <span class="keyword">true</span>;  </span><br><span class="line"><span class="number">5</span>.   &#125;</span><br></pre></td></tr></table></figure><p>看第一行，应该就是区分的体现了，下面着重看下这个ensureCapacityInternal()函数。这涉及到下面的数组容量扩充，我们单独说一下。</p><h2 id="调整数组容量ensureCapacity："><a href="#调整数组容量ensureCapacity：" class="headerlink" title="调整数组容量ensureCapacity："></a>调整数组容量ensureCapacity：</h2><p>与之前的ArrayList源码改变最大的就是这一部分了，先把三个调整容量的函数都贴出来，下面要多次用到。ensureCapacityInternal是第二个。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>.<span class="comment">/** </span></span><br><span class="line"><span class="comment">2.     * Increases the capacity of this &lt;tt&gt;ArrayList&lt;/tt&gt; instance, if </span></span><br><span class="line"><span class="comment">3.     * necessary, to ensure that it can hold at least the number of elements </span></span><br><span class="line"><span class="comment">4.     * specified by the minimum capacity argument. </span></span><br><span class="line"><span class="comment">5.     * </span></span><br><span class="line"><span class="comment">6.     * <span class="doctag">@param</span>   minCapacity   the desired minimum capacity </span></span><br><span class="line"><span class="comment">7.     */</span>  </span><br><span class="line"><span class="number">8</span>.    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ensureCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;  </span><br><span class="line"><span class="number">9</span>.        <span class="keyword">int</span> minExpand = (elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA)  </span><br><span class="line"><span class="number">10</span>.            <span class="comment">// any size if not default element table  </span></span><br><span class="line"><span class="number">11</span>.            ? <span class="number">0</span>  </span><br><span class="line"><span class="number">12</span>.            <span class="comment">// larger than default for default empty table. It's already  </span></span><br><span class="line"><span class="number">13</span>.            <span class="comment">// supposed to be at default size.  </span></span><br><span class="line"><span class="number">14</span>.            : DEFAULT_CAPACITY;  </span><br><span class="line"><span class="number">15</span>.  </span><br><span class="line"><span class="number">16</span>.        <span class="keyword">if</span> (minCapacity &gt; minExpand) &#123;  </span><br><span class="line"><span class="number">17</span>.            ensureExplicitCapacity(minCapacity);  </span><br><span class="line"><span class="number">18</span>.        &#125;  </span><br><span class="line"><span class="number">19</span>.    &#125;  </span><br><span class="line"><span class="number">20</span>.  </span><br><span class="line"><span class="number">21</span>.    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;  </span><br><span class="line"><span class="number">22</span>.        <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;  </span><br><span class="line"><span class="number">23</span>.            minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);  </span><br><span class="line"><span class="number">24</span>.        &#125;  </span><br><span class="line"><span class="number">25</span>.        ensureExplicitCapacity(minCapacity);  </span><br><span class="line"><span class="number">26</span>.    &#125;  </span><br><span class="line"><span class="number">27</span>.  </span><br><span class="line"><span class="number">28</span>.    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;  </span><br><span class="line"><span class="number">29</span>.        modCount++;   </span><br><span class="line"><span class="number">30</span>.        <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)  </span><br><span class="line"><span class="number">31</span>.            grow(minCapacity);  </span><br><span class="line"><span class="number">32</span>.    &#125;  </span><br><span class="line"></span><br><span class="line"><span class="number">1</span>.   <span class="comment">/**  容量扩充，确保数组中至少能包含minimum capacity个元素</span></span><br><span class="line"><span class="comment">2.     * Increases the capacity to ensure that it can hold at least the </span></span><br><span class="line"><span class="comment">3.     * number of elements specified by the minimum capacity argument. </span></span><br><span class="line"><span class="comment">4.     * </span></span><br><span class="line"><span class="comment">5.     * <span class="doctag">@param</span> minCapacity the desired minimum capacity </span></span><br><span class="line"><span class="comment">6.     */</span>  </span><br><span class="line"><span class="number">7</span>.    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;  </span><br><span class="line"><span class="number">8</span>.        <span class="keyword">int</span> oldCapacity = elementData.length;  </span><br><span class="line"><span class="number">9</span>.      <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>); <span class="comment">//原来容量的1.5倍 </span></span><br><span class="line"><span class="number">10</span>.        <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)  </span><br><span class="line"><span class="number">11</span>.            newCapacity = minCapacity;  </span><br><span class="line"><span class="number">12</span>.        <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)  </span><br><span class="line"><span class="number">13</span>.            newCapacity = hugeCapacity(minCapacity);  </span><br><span class="line"><span class="number">14</span>.        <span class="comment">// minCapacity is usually close to size, so this is a win:  </span></span><br><span class="line"><span class="number">15</span>.        elementData = Arrays.copyOf(elementData, newCapacity);  </span><br><span class="line"><span class="number">16</span>.    &#125;  </span><br><span class="line"><span class="number">17</span>.  <span class="comment">//对大容量数组的处理</span></span><br><span class="line"><span class="number">18</span>.    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hugeCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;  </span><br><span class="line"><span class="number">19</span>.        <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) <span class="comment">// overflow  </span></span><br><span class="line"><span class="number">20</span>.            <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError();  </span><br><span class="line"><span class="number">21</span>.        <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?  </span><br><span class="line"><span class="number">22</span>.            Integer.MAX_VALUE :  </span><br><span class="line"><span class="number">23</span>.            MAX_ARRAY_SIZE;  </span><br><span class="line"><span class="number">24</span>.    &#125;</span><br></pre></td></tr></table></figure></p><p>看ensureCapacityInternal中的下面这一句<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">33</span>.<span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;  </span><br><span class="line"><span class="number">34</span>.            minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);  </span><br><span class="line"><span class="number">35</span>.        &#125;</span><br></pre></td></tr></table></figure></p><p>看到了吧，先比较DEFAULT_CAPACITY和minCapacity，取较大的值作为minCapacity，显然，对于无参的构造器的空数组，比较的结果是DEFAULT_CAPACITY(上面有定义是10)，然后接下来执行ensureExplicitCapacity(minCapacity)。再接下来，实际执行扩充的是grow(int minCapacity) 这个函数。上面如果是初始化的时候，容易计算此时的minCapacity = DEFAULT_CAPACITY = 10.所以执行grow的时候，<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>.<span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)  </span><br><span class="line">            newCapacity = minCapacity;</span><br></pre></td></tr></table></figure></p><p>会执行这一句，应该空的数组扩充1.5倍之后还是空的。接着往下看，就可以知道其实无参的ArrayList的构造器初始化的是一个长度为10的elementData 数组。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>对于无参的ArrayList构造器，初始化的其实是一个容量为10的Object[] elementData 数组。每次执行扩充时，最终进行数组容量扩充的是grow（）函数，而且不难看出每次数组扩充后的容量为原来数组容量 的1.5倍。int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);</p><h2 id="元素存储："><a href="#元素存储：" class="headerlink" title="元素存储："></a>元素存储：</h2><p>ArrayList提供了set(int index, E element)、add(E e)、add(int index, E element)、addAll(Collection&lt;? extends E&gt; c)、addAll(int index, Collection&lt;? extends E&gt; c)这些添加元素的方法。下面我们一一讲解：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>.  <span class="comment">//两个范围检验函数，查看索引是否越界，越界抛出异常  </span></span><br><span class="line"><span class="number">2</span>.  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rangeCheck</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;    </span><br><span class="line"><span class="number">3</span>.          <span class="keyword">if</span> (index &gt;= size)    </span><br><span class="line"><span class="number">4</span>.              <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));  </span><br><span class="line"><span class="number">5</span>.      &#125;    </span><br><span class="line"><span class="number">6</span>.      <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rangeCheckForAdd</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;    </span><br><span class="line"><span class="number">7</span>.          <span class="keyword">if</span> (index &gt; size || index &lt; <span class="number">0</span>)    </span><br><span class="line"><span class="number">8</span>.              <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));   </span><br><span class="line"><span class="number">9</span>..     &#125;    </span><br><span class="line"><span class="number">10</span>.</span><br><span class="line"><span class="number">11</span>.   <span class="comment">// 用指定的元素替代此列表中指定位置上的元素，并返回以前位于该位置上的元素。      </span></span><br><span class="line"><span class="number">12</span>.   <span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;      </span><br><span class="line"><span class="number">13</span>.      RangeCheck(index);      </span><br><span class="line"><span class="number">14</span>.      E oldValue = (E) elementData[index];      </span><br><span class="line"><span class="number">15</span>.      elementData[index] = element;      </span><br><span class="line"><span class="number">16</span>.      <span class="keyword">return</span> oldValue;      </span><br><span class="line"><span class="number">17</span>.   &#125;        </span><br><span class="line"><span class="number">18</span>.   <span class="comment">// 将指定的元素添加到此列表的尾部。 上面讲到过这个函数，实现也很简单     </span></span><br><span class="line"><span class="number">19</span>.   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;  </span><br><span class="line"><span class="number">20</span>.         ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!  </span></span><br><span class="line"><span class="number">21</span>.         elementData[size++] = e;  </span><br><span class="line"><span class="number">22</span>.         <span class="keyword">return</span> <span class="keyword">true</span>;  </span><br><span class="line"><span class="number">23</span>.      &#125;      </span><br><span class="line"><span class="number">24</span>.   <span class="comment">// 将指定的元素插入此列表中的指定位置。      </span></span><br><span class="line"><span class="number">25</span>.   <span class="comment">// 如果当前位置有元素，则向右移动当前位于该位置的元素以及所有后续元素（将其索引加1）。  </span></span><br><span class="line"><span class="number">26</span>.   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;  </span><br><span class="line"><span class="number">27</span>.          rangeCheckForAdd(index);<span class="comment">//索引范围检验  </span></span><br><span class="line"><span class="number">28</span>.          ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">//  扩充1个单元  </span></span><br><span class="line"><span class="number">29</span>.       <span class="comment">// 将 elementData中从Index位置开始、长度为size-index的元素，      </span></span><br><span class="line"><span class="number">30</span>.      <span class="comment">// 拷贝到从下标为index+1位置开始的新的elementData数组中。      </span></span><br><span class="line"><span class="number">31</span>.      <span class="comment">// 即将当前位于该位置的元素以及所有后续元素右移一个位置。  </span></span><br><span class="line"><span class="number">32</span>.         System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>,  </span><br><span class="line"><span class="number">33</span>.                          size - index);  </span><br><span class="line"><span class="number">34</span>.         elementData[index] = element;<span class="comment">//插入元素  </span></span><br><span class="line"><span class="number">35</span>.         size++;  </span><br><span class="line"><span class="number">36</span>.     &#125;      </span><br><span class="line"><span class="number">37</span>.       </span><br><span class="line"><span class="number">38</span>.  <span class="comment">// 按照指定collection的迭代器所返回的元素顺序，将该collection中的所有元素添加到此列表的尾部。  </span></span><br><span class="line"><span class="number">39</span>. <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;  </span><br><span class="line"><span class="number">40</span>.         Object[] a = c.toArray();<span class="comment">//先转换成数组   </span></span><br><span class="line"><span class="number">41</span>.         <span class="keyword">int</span> numNew = a.length;  </span><br><span class="line"><span class="number">42</span>.        ensureCapacityInternal(size + numNew);  <span class="comment">// 容量扩充            </span></span><br><span class="line"><span class="number">43</span>.         System.arraycopy(a, <span class="number">0</span>, elementData, size, numNew);<span class="comment">//元素复制  </span></span><br><span class="line"><span class="number">44</span>.        size += numNew;  </span><br><span class="line"><span class="number">45</span>.         <span class="keyword">return</span> numNew != <span class="number">0</span>;  </span><br><span class="line"><span class="number">46</span>.      &#125;           </span><br><span class="line"><span class="number">47</span>.   <span class="comment">// 从指定的位置开始，将指定collection中的所有元素插入到此列表中。  </span></span><br><span class="line"><span class="number">48</span>. <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(<span class="keyword">int</span> index, Collection&lt;? extends E&gt; c)</span> </span>&#123;  </span><br><span class="line"><span class="number">49</span>.          rangeCheckForAdd(index);<span class="comment">//索引检查  </span></span><br><span class="line"><span class="number">50</span>.    </span><br><span class="line"><span class="number">51</span>.          Object[] a = c.toArray();  </span><br><span class="line"><span class="number">52</span>.          <span class="keyword">int</span> numNew = a.length;  </span><br><span class="line"><span class="number">53</span>.          ensureCapacityInternal(size + numNew);  <span class="comment">// 容量扩充  </span></span><br><span class="line"><span class="number">54</span>.    </span><br><span class="line"><span class="number">55</span>.         <span class="keyword">int</span> numMoved = size - index;<span class="comment">//要移动的元素的个数  </span></span><br><span class="line"><span class="number">56</span>.         <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)  </span><br><span class="line">             System.arraycopy(elementData, index, elementData, index + numNew, numMoved);<span class="comment">//复制元素  </span></span><br><span class="line"><span class="number">58</span>.   </span><br><span class="line"><span class="number">59</span>.         System.arraycopy(a, <span class="number">0</span>, elementData, index, numNew);  </span><br><span class="line"><span class="number">60</span>.         size += numNew;  </span><br><span class="line"><span class="number">61</span>.         <span class="keyword">return</span> numNew != <span class="number">0</span>;  </span><br><span class="line"><span class="number">62</span>.    &#125;</span><br></pre></td></tr></table></figure></p><p>ArrayList是基于数组实现的，可以看到上面的添加元素的方法，大都需要先进行索引检查（与操作索引相关的），还要进行数组容量的扩充，然后是 System.arraycopy复制元素。具体过程查看上面的注释。</p><h2 id="元素读取："><a href="#元素读取：" class="headerlink" title="元素读取："></a>元素读取：</h2><p>这个很简单，直接返回数组i位置上的元素即可。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回此列表中指定位置上的元素。    </span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;    </span><br><span class="line">    RangeCheck(index);    </span><br><span class="line">    <span class="keyword">return</span> (E) elementData[index];    </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><h2 id="元素删除："><a href="#元素删除：" class="headerlink" title="元素删除："></a>元素删除：</h2><p>ArrayList提供了根据下标或者指定对象两种方式的删除功能。如下：</p><h3 id="romove-int-index"><a href="#romove-int-index" class="headerlink" title="romove(int index):"></a>romove(int index):</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 移除此列表中指定位置上的元素。    </span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;    </span><br><span class="line">     RangeCheck(index);    </span><br><span class="line">     modCount++;    </span><br><span class="line">     E oldValue = (E) elementData[index];    </span><br><span class="line">     <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;    </span><br><span class="line">     <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)    </span><br><span class="line">        System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index, numMoved);    </span><br><span class="line">    elementData[--size] = <span class="keyword">null</span>; <span class="comment">// Let gc do its work    </span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> oldValue;    </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>首先是检查范围，修改modCount，保留将要被移除的元素，将移除位置之后的元素向前挪动一个位置，将list末尾元素置空（null），返回被移除的元素。</p><h3 id="remove-Object-o"><a href="#remove-Object-o" class="headerlink" title="remove(Object o)"></a>remove(Object o)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 移除此列表中首次出现的指定元素（如果存在）。这是应为ArrayList中允许存放重复的元素。    </span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;    </span><br><span class="line">    <span class="comment">// 由于ArrayList中允许存放null，因此下面通过两种情况来分别处理。    </span></span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;    </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)    </span><br><span class="line">           <span class="keyword">if</span> (elementData[index] == <span class="keyword">null</span>) &#123;    </span><br><span class="line">                <span class="comment">// 类似remove(int index)，移除列表中指定位置上的元素。    </span></span><br><span class="line">                fastRemove(index);    </span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;    </span><br><span class="line">            &#125;    </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;    </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)    </span><br><span class="line">           <span class="keyword">if</span> (o.equals(elementData[index])) &#123;    </span><br><span class="line">                fastRemove(index);    </span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;    </span><br><span class="line">            &#125;    </span><br><span class="line">        &#125;    </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;    </span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先通过代码可以看到，当移除成功后返回true，否则返回false。remove(Object o)中通过遍历element寻找是否存在传入对象，一旦找到就调用fastRemove移除对象。为什么找到了元素就知道了index，不通过remove(index)来移除元素呢？因为fastRemove跳过了判断边界的处理，因为找到元素就相当于确定了index不会超过边界，而且fastRemove并不返回被移除的元素。下面是fastRemove的代码，基本和remove(index)一致。方法说明：skips bounds checking and does notreturn the value removed.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fastRemove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;    </span><br><span class="line">         modCount++;    </span><br><span class="line">         <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;    </span><br><span class="line">         <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)    </span><br><span class="line">  System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,    numMoved);</span><br><span class="line">         elementData[--size] = <span class="keyword">null</span>; <span class="comment">// Let gc do its work    </span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><h3 id="batchRemove"><a href="#batchRemove" class="headerlink" title="batchRemove()"></a>batchRemove()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>.<span class="comment">//保留集合c中的元素，集合外的元素全部删除</span></span><br><span class="line"><span class="number">2</span>.      Retains only the elements in <span class="keyword">this</span> list that are contained in the</span><br><span class="line"><span class="number">3</span>.     * specified collection.  In other words, removes from <span class="keyword">this</span> list all</span><br><span class="line"><span class="number">4</span>.     * of its elements that are not contained in the specified collection.</span><br><span class="line"><span class="number">5</span>.<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">retainAll</span><span class="params">(Collection&lt;?&gt; c)</span> </span>&#123;  </span><br><span class="line"><span class="number">6</span>.        Objects.requireNonNull(c);  </span><br><span class="line"><span class="number">7</span>.        <span class="keyword">return</span> batchRemove(c, <span class="keyword">true</span>);  </span><br><span class="line"><span class="number">8</span>.    &#125;  </span><br><span class="line"><span class="number">9</span>.  </span><br><span class="line"><span class="number">10</span>.    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">batchRemove</span><span class="params">(Collection&lt;?&gt; c, <span class="keyword">boolean</span> complement)</span> </span>&#123;  </span><br><span class="line"><span class="number">11</span>.        <span class="keyword">final</span> Object[] elementData = <span class="keyword">this</span>.elementData;  </span><br><span class="line"><span class="number">12</span>.        <span class="keyword">int</span> r = <span class="number">0</span>, w = <span class="number">0</span>;  </span><br><span class="line"><span class="number">13</span>.        <span class="keyword">boolean</span> modified = <span class="keyword">false</span>;  </span><br><span class="line"><span class="number">14</span>.        <span class="keyword">try</span> &#123;  </span><br><span class="line"><span class="number">15</span>.            <span class="keyword">for</span> (; r &lt; size; r++)  </span><br><span class="line"><span class="number">16</span>.                <span class="keyword">if</span> (c.contains(elementData[r]) == complement)  </span><br><span class="line"><span class="number">17</span>.                    elementData[w++] = elementData[r];  </span><br><span class="line"><span class="number">18</span>.        &#125; <span class="keyword">finally</span> &#123;  </span><br><span class="line"><span class="number">19</span>.            <span class="comment">// Preserve behavioral compatibility with AbstractCollection,  </span></span><br><span class="line"><span class="number">20</span>.            <span class="comment">// even if c.contains() throws.  </span></span><br><span class="line"><span class="number">21</span>.            <span class="keyword">if</span> (r != size) &#123;  </span><br><span class="line"><span class="number">22</span>.                System.arraycopy(elementData, r,  </span><br><span class="line"><span class="number">23</span>.                                 elementData, w,  </span><br><span class="line"><span class="number">24</span>.                                 size - r);  </span><br><span class="line"><span class="number">25</span>.                w += size - r;  </span><br><span class="line"><span class="number">26</span>.            &#125;  </span><br><span class="line"><span class="number">27</span>.            <span class="keyword">if</span> (w != size) &#123;  </span><br><span class="line"><span class="number">28</span>.                <span class="comment">// clear to let GC do its work  </span></span><br><span class="line"><span class="number">29</span>.                <span class="keyword">for</span> (<span class="keyword">int</span> i = w; i &lt; size; i++)  </span><br><span class="line"><span class="number">30</span>.                    elementData[i] = <span class="keyword">null</span>;  </span><br><span class="line"><span class="number">31</span>.                modCount += size - w;  </span><br><span class="line"><span class="number">32</span>.                size = w;  </span><br><span class="line"><span class="number">33</span>.                modified = <span class="keyword">true</span>;  </span><br><span class="line"><span class="number">34</span>.            &#125;  </span><br><span class="line"><span class="number">35</span>.        &#125;  </span><br><span class="line"><span class="number">36</span>.        <span class="keyword">return</span> modified;  </span><br><span class="line"><span class="number">37</span>.    &#125;</span><br></pre></td></tr></table></figure><h3 id="removeRange-int-fromIndex-int-toIndex"><a href="#removeRange-int-fromIndex-int-toIndex" class="headerlink" title="removeRange(int fromIndex,int toIndex)"></a>removeRange(int fromIndex,int toIndex)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">removeRange</span><span class="params">(<span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex)</span> </span>&#123;    </span><br><span class="line">     modCount++;    </span><br><span class="line">     <span class="keyword">int</span> numMoved = size - toIndex;    </span><br><span class="line">         System.arraycopy(elementData, toIndex, elementData, fromIndex,    </span><br><span class="line">                          numMoved);    </span><br><span class="line">     </span><br><span class="line">     <span class="comment">// Let gc do its work    </span></span><br><span class="line">     <span class="keyword">int</span> newSize = size - (toIndex-fromIndex);    </span><br><span class="line">    <span class="keyword">while</span> (size != newSize)    </span><br><span class="line">         elementData[--size] = <span class="keyword">null</span>;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行过程是将elementData从toIndex位置开始的元素向前移动到fromIndex，然后将toIndex位置之后的元素全部置空顺便修改size。<br>这个方法是protected，及受保护的方法，为什么这个方法被定义为protected呢？<br>这是一个解释，但是可能不容易看明白。<a href="http://stackoverflow.com/questions/2289183/why-is-javas-abstractlists-removerange-method-protected" target="_blank" rel="noopener">http://stackoverflow.com/questions/2289183/why-is-javas-abstractlists-removerange-method-protected</a><br>先看下面这个例子</p><ol><li>ArrayList<integer> ints = new ArrayList<integer>(Arrays.asList(0, 1, 2,    </integer></integer></li><li>3, 4, 5, 6));    </li><li>// fromIndex low endpoint (inclusive) of the subList    </li><li>// toIndex high endpoint (exclusive) of the subList    </li><li>ints.subList(2, 4).clear();    </li><li>System.out.println(ints);<br>输出结果是[0, 1, 4, 5, 6]，结果是不是像调用了removeRange(int fromIndex,int toIndex)！哈哈哈，就是这样的。但是为什么效果相同呢？是不是调用了removeRange(int fromIndex,int toIndex)呢？<h2 id="ArrayList和Vector区别："><a href="#ArrayList和Vector区别：" class="headerlink" title="ArrayList和Vector区别："></a>ArrayList和Vector区别：</h2>•    ArrayList在内存不够时默认是扩展50% + 1个，Vector是默认扩展1倍。<br>•    Vector提供indexOf(obj, start)接口，ArrayList没有。<br>•    Vector属于线程安全级别的，但是大多数情况下不使用Vector，因为线程安全需要更大的系统开销。<br>##　trimToSize<br>ArrayList还给我们提供了将底层数组的容量调整为当前列表保存的实际元素的大小的功能。它可以通过trimToSiz方法来实现。代码如下：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">trimToSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="keyword">if</span> (size &lt; elementData.length) &#123;</span><br><span class="line">            elementData = (size == <span class="number">0</span>)</span><br><span class="line">              ? EMPTY_ELEMENTDATA</span><br><span class="line">              : Arrays.copyOf(elementData, size);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ol><p>由于elementData的长度会被拓展，size标记的是其中包含的元素的个数。所以会出现size很小但elementData.length很大的情况，将出现空间的浪费。trimToSize将返回一个新的数组给elementData，元素内容保持不变，length和size相同，节省空间。</p><h2 id="转为静态数组toArray"><a href="#转为静态数组toArray" class="headerlink" title="转为静态数组toArray"></a>转为静态数组toArray</h2><p>注意ArrayList的两个转化为静态数组的toArray方法。<br>第一个， 调用Arrays.copyOf将返回一个数组，数组内容是size个elementData的元素，即拷贝elementData从0至size-1位置的元素到新数组并返回.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>.<span class="keyword">public</span> Object[] toArray() &#123;    </span><br><span class="line"><span class="number">2</span>.         <span class="keyword">return</span> Arrays.copyOf(elementData, size);    </span><br><span class="line"><span class="number">3</span>. &#125;</span><br></pre></td></tr></table></figure></p><p>第二个，如果传入数组的长度小于size，返回一个新的数组，大小为size，类型与传入数组相同。所传入数组长度与size相等，则将elementData复制到传入数组中并返回传入的数组。若传入数组长度大于size，除了复制elementData外，还将把返回数组的第size个元素置为空。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; T[] toArray(T[] a) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (a.length &lt; size)  </span><br><span class="line">            <span class="comment">// Make a new array of a's runtime type, but my contents:  </span></span><br><span class="line">            <span class="keyword">return</span> (T[]) Arrays.copyOf(elementData, size, a.getClass());  </span><br><span class="line">    System.arraycopy(elementData, <span class="number">0</span>, a, <span class="number">0</span>, size);  </span><br><span class="line">        <span class="keyword">if</span> (a.length &gt; size)  </span><br><span class="line">            a[size] = <span class="keyword">null</span>;  </span><br><span class="line">        <span class="keyword">return</span> a;  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h2 id="clone"><a href="#clone" class="headerlink" title="clone(),"></a>clone(),</h2><p>返回此 ArrayList 实例的浅表副本。（不复制这些元素本身。）调用父类的clone方法返回一个对象的副本，将返回对象的elementData数组的内容赋值为原对象elementData数组的内容，将副本的modCount设置为0。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            ArrayList&lt;?&gt; v = (ArrayList&lt;?&gt;) <span class="keyword">super</span>.clone();  </span><br><span class="line">            v.elementData = Arrays.copyOf(elementData, size);  </span><br><span class="line">            v.modCount = <span class="number">0</span>;  </span><br><span class="line">            <span class="keyword">return</span> v;  </span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;  </span><br><span class="line">            <span class="comment">// this shouldn't happen, since we are Cloneable  </span></span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(e);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h2 id="clear"><a href="#clear" class="headerlink" title="clear()"></a>clear()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">     modCount++;  </span><br><span class="line">   </span><br><span class="line">     <span class="comment">// Let gc do its work  </span></span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)  </span><br><span class="line">        elementData[i] = <span class="keyword">null</span>;  </span><br><span class="line">   </span><br><span class="line">     size = <span class="number">0</span>;  </span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><p>clear的时候并没有修改elementData的长度（好不容易申请、拓展来的，凭什么释放，留着搞不好还有用呢。这使得确定不再修改list内容之后最好调用trimToSize来释放掉一些空间），只是将所有元素置为null，size设置为0。</p><h2 id="contains-Object"><a href="#contains-Object" class="headerlink" title="contains(Object)"></a>contains(Object)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;  </span><br><span class="line"><span class="keyword">return</span> indexOf(o) &gt;= <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1.indexOf方法返回值与0比较来判断对象是否在list中。接着看indexOf。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object o)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;  </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)  </span><br><span class="line">               <span class="keyword">if</span> (elementData[i]==<span class="keyword">null</span>)  </span><br><span class="line">                    <span class="keyword">return</span> i;  </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)  </span><br><span class="line">                <span class="keyword">if</span> (o.equals(elementData[i]))  </span><br><span class="line">                    <span class="keyword">return</span> i;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;  </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><p>2.lastIndexOf，光看名字应该就明白了返回的是传入对象在elementData数组中最后出现的index值<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(Object o)</span> </span>&#123;  </span><br><span class="line">     <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;  </span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">int</span> i = size-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)  </span><br><span class="line">         <span class="keyword">if</span> (elementData[i]==<span class="keyword">null</span>)  </span><br><span class="line">             <span class="keyword">return</span> i;  </span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">int</span> i = size-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)  </span><br><span class="line">         <span class="keyword">if</span> (o.equals(elementData[i]))  </span><br><span class="line">             <span class="keyword">return</span> i;  </span><br><span class="line">    &#125;  </span><br><span class="line">     <span class="keyword">return</span> -<span class="number">1</span>;  </span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure></p><p>采用了从后向前遍历element数组，若遇到Object则返回index值，若没有遇到，返回-1.</p><h2 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h2><p>因为实现了java.io.Serializable接口，索引可以进行序列化操作。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">     * Save the state of the &lt;tt&gt;ArrayList&lt;/tt&gt; instance to a stream (that </span></span><br><span class="line"><span class="comment">     * is, serialize it). 把arraylist实例写入一个流中</span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(java.io.ObjectOutputStream s)</span>  </span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> java.io.IOException</span>&#123;  </span><br><span class="line">        <span class="comment">// Write out element count, and any hidden stuff  </span></span><br><span class="line">        <span class="keyword">int</span> expectedModCount = modCount;  </span><br><span class="line">        s.defaultWriteObject();  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">// Write out size as capacity for behavioural compatibility with clone()  </span></span><br><span class="line">        s.writeInt(size);  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">// Write out all elements in the proper order.  </span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; i++) &#123;  </span><br><span class="line">            s.writeObject(elementData[i]);  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">if</span> (modCount != expectedModCount) &#123;  </span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * Reconstitute the &lt;tt&gt;ArrayList&lt;/tt&gt; instance from a stream (that is, </span></span><br><span class="line"><span class="comment">     * deserialize it). 从流中读出一个ArrayList实例</span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(java.io.ObjectInputStream s)</span>  </span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> java.io.IOException, ClassNotFoundException </span>&#123;  </span><br><span class="line">        elementData = EMPTY_ELEMENTDATA;  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">// Read in size, and any hidden stuff  </span></span><br><span class="line">        s.defaultReadObject();  </span><br><span class="line"></span><br><span class="line">        <span class="comment">// Read in capacity  </span></span><br><span class="line">        s.readInt(); <span class="comment">// ignored  </span></span><br><span class="line">  </span><br><span class="line">        <span class="keyword">if</span> (size &gt; <span class="number">0</span>) &#123;  </span><br><span class="line">            <span class="comment">// be like clone(), allocate array based upon size not capacity  </span></span><br><span class="line">            ensureCapacityInternal(size);  </span><br><span class="line">  </span><br><span class="line">            Object[] a = elementData;  </span><br><span class="line">            <span class="comment">// Read in all elements in the proper order.  </span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; i++) &#123;  </span><br><span class="line">                a[i] = s.readObject();  </span><br><span class="line">        &#125;  &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h1 id="Fail-Fast机制："><a href="#Fail-Fast机制：" class="headerlink" title="Fail-Fast机制："></a>Fail-Fast机制：</h1><p>ArrayList也采用了快速失败的机制，通过记录modCount参数来实现。在面对并发的修改时，迭代器很快就会完全失败，而不是冒着在将来某个不确定时间发生任意不确定行为的风险。</p><h1 id="ArrayList的遍历方式"><a href="#ArrayList的遍历方式" class="headerlink" title="ArrayList的遍历方式"></a>ArrayList的遍历方式</h1><p>ArrayList支持3种遍历方式<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、通过迭代器遍历：</span><br><span class="line">Iterator iter = list.iterator();</span><br><span class="line"><span class="keyword">while</span> (iter.hasNext())</span><br><span class="line">&#123;</span><br><span class="line">    System.out.println(iter.next());</span><br><span class="line">&#125;         </span><br><span class="line"><span class="number">2</span>、随机访问，通过索引值去遍历，由于ArrayList实现了RandomAccess接口</span><br><span class="line"><span class="keyword">int</span> size = list.size();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; i++) </span><br><span class="line">&#123;</span><br><span class="line">   System.out.println(list.get(i));        </span><br><span class="line">&#125;      </span><br><span class="line"><span class="number">3</span>、<span class="keyword">for</span>循环遍历：</span><br><span class="line"><span class="keyword">for</span>(String str:list)</span><br><span class="line">&#123;</span><br><span class="line">  System.out.println(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="总结-1"><a href="#总结-1" class="headerlink" title="总结:"></a>总结:</h1><p>关于ArrayList的源码，给出几点比较重要的总结：<br>1.注意其三个不同的构造方法。无参构造方法构造的ArrayList的容量默认为10，带有Collection参数的构造方法，将Collection转化为数组赋给ArrayList的实现数组elementData。<br>2.注意扩充容量的方法ensureCapacity。ArrayList在每次增加元素（可能是1个，也可能是一组）时，都要调用该方法来确保足够的容量。当容量不足以容纳当前的元素个数时，就设置新的容量为旧的容量的1.5倍，如果设置后的新容量还不够，则直接新容量设置为传入的参数（也就是所需的容量），而后用Arrays.copyof()方法将元素拷贝到新的数组（详见下面的第3点）。从中可以看出，当容量不够时，每次增加元素，都要将原来的元素拷贝到一个新的数组中，非常之耗时，也因此建议在事先能确定元素数量的情况下，才使用ArrayList，否则建议使用LinkedList。<br>3.ArrayList的实现中大量地调用了Arrays.copyof()和System.arraycopy()方法。我们有必要对这两个方法的实现做下深入的了解。<br>首先来看Arrays.copyof()方法。它有很多个重载的方法，但实现思路都是一样的，我们来看泛型版本的源码：</p><pre><code class="java"><span class="number">1</span>.    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T[] copyOf(T[] original, <span class="keyword">int</span> newLength) {    <span class="number">2</span>.        <span class="keyword">return</span> (T[]) copyOf(original, newLength, original.getClass());    <span class="number">3</span>.    }</code></pre><p>很明显调用了另一个copyof方法，该方法有三个参数，最后一个参数指明要转换的数据的类型，其源码如下：</p><pre><code class="java"><span class="number">1</span>.    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T,U&gt; T[] copyOf(U[] original, <span class="keyword">int</span> newLength, Class&lt;? extends T[]&gt; newType) {    <span class="number">2</span>.        T[] copy = ((Object)newType == (Object)Object[].class)    <span class="number">3</span>.            ? (T[]) <span class="keyword">new</span> Object[newLength]    <span class="number">4</span>.            : (T[]) Array.newInstance(newType.getComponentType(), newLength);    <span class="number">5</span>.        System.arraycopy(original, <span class="number">0</span>, copy, <span class="number">0</span>,    <span class="number">6</span>.                         Math.min(original.length, newLength));    <span class="number">7</span>.        <span class="keyword">return</span> copy;    <span class="number">8</span>.    } </code></pre><p>这里可以很明显地看出，该方法实际上是在其内部又创建了一个长度为newlength的数组，调用System.arraycopy()方法，将原来数组中的元素复制到了新的数组中。<br>下面来看System.arraycopy()方法。该方法被标记了native，调用了系统的C/C++代码，在JDK中是看不到的，但在openJDK中可以看到其源码。该函数实际上最终调用了C语言的memmove()函数，因此它可以保证同一个数组内元素的正确复制和移动，比一般的复制方法的实现效率要高很多，很适合用来批量处理数组。Java强烈推荐在复制大量数组元素时用该方法，以取得更高的效率。<br>4.ArrayList基于数组实现，可以通过下标索引直接查找到指定位置的元素，因此查找效率高，但每次插入或删除元素，就要大量地移动元素，插入删除元素的效率低。<br>5.在查找给定元素索引值等的方法中，源码都将该元素的值分为null和不为null两种情况处理，ArrayList中允许元素为null。<br>6.数组扩容<br>这是对ArrayList效率影响比较大的一个因素。<br>每 当执行Add、AddRange、Insert、InsertRange等添加元素的方法，都会检查内部数组的容量是否不够了，如果是，它就会以当前容量 的两倍来重新构建一个数组，将旧元素Copy到新数组中，然后丢弃旧数组，在这个临界点的扩容操作，应该来说是比较影响效率的。<br>由于是从word上粘贴过来的，格式有些不太正确，以后慢慢修改吧。 </p>]]></content>
      
      
      <categories>
          
          <category> java集合 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java源码 </tag>
            
            <tag> ArrayList </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java Scanner next()和nextLine()</title>
      <link href="/2017/04/02/Java-Scanner-next-%E5%92%8CnextLine/"/>
      <url>/2017/04/02/Java-Scanner-next-%E5%92%8CnextLine/</url>
      
        <content type="html"><![CDATA[<p>java中使用Scanner类获取数据输入十分方便，Scanner类中next()与nextLine()都可以实现字符串String的获取.它们的区别如下：</p><ol><li>next() 方法从第一个有效字符（非空格，非换行符），开始扫描。当遇见第一个分隔符或结束符(空格或换行符)时，结束扫描，获取扫描到的内容，即获得第一个扫描到的不含空格、换行符的单个字符串。</li><li>使用nextLine()时，则可以扫描到一行内容并作为一个字符串而被获取到。可以获取空格。<a id="more"></a><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">System.out.println(<span class="string">"---&gt;Test1:\n"</span>);</span><br><span class="line">String nextStr = scanner.next();</span><br><span class="line">System.out.println(<span class="string">"scanner.next()得到："</span> + nextStr);</span><br><span class="line">String nextlineStr = scanner.nextLine();</span><br><span class="line">System.out.println(<span class="string">"scanner.nextLine()得到："</span> + nextlineStr);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"\n---&gt;Test2:"</span>);</span><br><span class="line">String nextlineStr2 = scanner.nextLine();</span><br><span class="line">System.out.println(<span class="string">"scanner.nextLine()得到："</span> + nextlineStr2);</span><br><span class="line">String nextStr2 = scanner.next();</span><br><span class="line">System.out.println(<span class="string">"scanner.next()得到："</span> + nextStr2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p><img src="http://i.imgur.com/vgRn5UN.png" alt="结果"></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> Scanner </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>github上ssh配置</title>
      <link href="/2017/03/31/github%E4%B8%8Assh%E9%85%8D%E7%BD%AE/"/>
      <url>/2017/03/31/github%E4%B8%8Assh%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="配置-ssh-key"><a href="#配置-ssh-key" class="headerlink" title="配置 ssh key"></a>配置 ssh key</h1><p>使用 git bash 生成 public ssh key，以下是最简单的方法<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-keygen -t rsa</span><br><span class="line">C/Documents and Settings/username/.ssh 目录下会生成 id_rsa.pub</span><br></pre></td></tr></table></figure></p><p>将 id_rsa.pub 的内容完全复制到 github Account Setting 里的 ssh key 里即可</p><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh -T git@github.com</span><br></pre></td></tr></table></figure><p>然后会看到<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hi [yourGithubAccount]! You&apos;ve successfully authenticated, but GitHub does not provide shell access.</span><br></pre></td></tr></table></figure></p><p>设置用户信息<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user.name &quot;[yourName]&quot;//用户名</span><br><span class="line">$ git config --global user.email  &quot;[yourEmail]&quot;//填写自己的邮箱</span><br></pre></td></tr></table></figure></p><p>经过以上步骤，本机已成功连接到 github，为部署打下基础。</p>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> github </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>栈与队列</title>
      <link href="/2017/03/24/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/"/>
      <url>/2017/03/24/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><div class="note success"><p>用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型.</p></div><a id="more"></a><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>假设两个栈为A和B。</p><ol><li>入队列的时候，只需要向A栈中入栈即可。</li><li>出队列的时候，要先检查B栈是否为空。如果B为空，把A栈中的元素全部放入B栈中。如果B不为空，就从B栈顶弹出一个元素。<br>这样就实现了一个队列先进先出的功能。<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。 </span></span><br><span class="line"><span class="comment"> * &lt;分析&gt;： </span></span><br><span class="line"><span class="comment"> * 入队：将元素进栈A</span></span><br><span class="line"><span class="comment"> * 出队：判断栈B是否为空，如果为空，则将栈A中所有元素pop，并push进栈B，栈B出栈； 如果不为空，栈B直接出栈。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> XIAO</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StackQueue</span> </span>&#123;</span><br><span class="line">Stack&lt;Integer&gt; stack1 = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">Stack&lt;Integer&gt; stack2 = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">stack1.push(node);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">if</span> (!stack2.isEmpty()) &#123;</span><br><span class="line">a = stack2.pop();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">while</span> (!stack1.isEmpty()) &#123;</span><br><span class="line">stack2.push(stack1.pop());</span><br><span class="line">&#125;</span><br><span class="line">a = stack2.pop();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h1 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h1><p>用两个队列实现栈的功能。</p><h1 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h1><p>把B当做一个中转站<br>入栈：将元素进队列A<br>出栈：判断队列A中元素的个数是否为1，如果等于1，则出队列，否则将队列A中的元素出队列并放入队列B，直到队列A中的元素留下一个，然<br>后队列A出队列，再把队列B中的元素出队列以此放入队列A中。</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用两个队列实现栈的功能； 思路 &lt;分析&gt;：把B当做一个中转站 入栈：将元素进队列A</span></span><br><span class="line"><span class="comment"> * 出栈：判断队列A中元素的个数是否为1，如果等于1，则出队列，否则将队列A中的元素出队列并放入队列B，直到队列A中的元素留下一</span></span><br><span class="line"><span class="comment"> * 个，然后队列A出队列，再把 队列B中的元素出队列以此放入队列A中。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> XIAO</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QueueStack</span> </span>&#123;</span><br><span class="line">Queue&lt;Integer&gt; queue1 = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">Queue&lt;Integer&gt; queue2 = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 两个栈都为空时，优先考虑queue1</span></span><br><span class="line"><span class="keyword">if</span> (queue1.isEmpty() &amp;&amp; queue2.isEmpty()) &#123;</span><br><span class="line">queue1.add(node);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果queue1为空，queue2有元素，直接放入queue2</span></span><br><span class="line"><span class="keyword">if</span> (queue1.isEmpty()) &#123;</span><br><span class="line">queue2.add(node);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (queue2.isEmpty()) &#123;</span><br><span class="line">queue1.add(node);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 两个栈都为空时，没有元素可以弹出</span></span><br><span class="line"><span class="keyword">if</span> (queue1.isEmpty() &amp;&amp; queue2.isEmpty()) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"stack is empty"</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果queue1为空，queue2有元素， 将queue2的元素依次放入queue1中，直到最后一个元素，我们弹出。</span></span><br><span class="line"><span class="keyword">if</span> (queue1.isEmpty()) &#123;</span><br><span class="line"><span class="keyword">while</span> (queue2.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">queue1.add(queue2.poll());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> queue2.poll();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (queue2.isEmpty()) &#123;</span><br><span class="line"><span class="keyword">while</span> (queue1.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">queue2.add(queue1.poll());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> queue1.poll();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> (Integer) <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 栈 </tag>
            
            <tag> 队列 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>青蛙跳台阶</title>
      <link href="/2017/03/24/%E9%9D%92%E8%9B%99%E8%B7%B3%E5%8F%B0%E9%98%B6/"/>
      <url>/2017/03/24/%E9%9D%92%E8%9B%99%E8%B7%B3%E5%8F%B0%E9%98%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><div class="note success"><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</p></div><a id="more"></a><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><blockquote><p>假设第一次跳了一阶，那么还剩 n-1 阶，有f(n-1)中跳法。 假设第一次跳了2阶，那么还剩 n-2 阶，有f(n-2)中跳法。所以，这是一个斐波那契数列。f(n) = f(n-1)+f(n-2)</p></blockquote><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 思路：假设第一次跳了一阶，那么还剩 n-1 阶，有f(n-1)中跳法。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 假设第一次跳了2阶，那么还剩 n-2 阶，有f(n-2)中跳法。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 所以，这是一个斐波那契数列。f(n) = f(n-1)+f(n-2)</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> XIAO</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JumpFloor</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">JumpFloorSolution</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (target == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (target == <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (target == <span class="number">2</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> f1 = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> f2 = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> cursum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= target; i++) &#123;</span><br><span class="line">cursum = f1 + f2;</span><br><span class="line">f1 = f2;</span><br><span class="line">f2 = cursum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> cursum;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="题目2"><a href="#题目2" class="headerlink" title="题目2"></a>题目2</h1><blockquote><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</p></blockquote><h1 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h1><blockquote><ol><li>假设第一次跳 1 阶。那么还剩 n-1 阶。一共还剩f(n-1)种跳法。</li><li>假设第一次跳 2 阶。那么还剩 n-2 阶。一共还剩f(n-2)种跳法。 。。。</li><li>假设第一次跳 n-1 阶。那么还剩 1 阶。一共还剩f(1)种跳法。</li><li>假设第一次跳 n 阶。一种跳法。</li><li>所以：f(n) = f(n-1)+f(n-2)+…+1; 而且:f(n-1) = f(n-2) +…+1;</li><li>所以f(n) = 2f(n-1)</li></ol></blockquote><h1 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 思路：同样：假设第一次跳 1 阶。那么还剩 n-1 阶。一共还剩f(n-1)种跳法。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 假设第一次跳 2 阶。那么还剩 n-2 阶。一共还剩f(n-2)种跳法。 。。。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 假设第一次跳 n-1 阶。那么还剩 1 阶。一共还剩f(1)种跳法。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 假设第一次跳 n 阶。一种跳法。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 所以：f(n) = f(n-1)+f(n-2)+...+1; 而且:f(n-1) = f(n-2) +...+1;</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 所以f(n) = 2f(n-1)</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> XIAO</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JumoFloor2</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">JumpFloorSolution</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (target &lt;= <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (target == <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> JumpFloorSolution(target - <span class="number">1</span>) * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>矩阵覆盖</title>
      <link href="/2017/03/24/%E7%9F%A9%E9%98%B5%E8%A6%86%E7%9B%96/"/>
      <url>/2017/03/24/%E7%9F%A9%E9%98%B5%E8%A6%86%E7%9B%96/</url>
      
        <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><div class="note success"><p>我们可以用2*1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2*1的小矩形无重叠地覆盖一个2*n的大矩形，总共有多少种方法？</p></div><a id="more"></a><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>有以下几种情形：</p><blockquote><ol><li>target &lt;= 0 大矩形为&lt;= 2*0,直接return 0；</li><li>target = 1大矩形为2*1，只有一种摆放方法，return1；</li><li>target = 2 大矩形为2*2，有两种摆放方法，return2；</li><li>target = n 分为两步考虑：<br>第一次摆放一块 2<em>1 的小矩阵，则摆放方法总共为f(target - 1)<br>√<br>√<br>第一次摆放一块1\</em>2的小矩阵，则摆放方法总共为f(target-2)<br>因为，摆放了一块1*2的小矩阵（用√√表示），对应下方的1*2（用××表示）摆放方法就确定了，所以为f(targte-2)<br>√    √<br>×    ×<br>所以：f(target) =f(target - 1) + f(targte-2)<br>实际上就是一个斐波那契数列。</li></ol></blockquote><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">RectCover</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">if</span>(target==<span class="number">0</span>)&#123;  </span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">if</span>(target==<span class="number">1</span>)&#123;  </span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(target==<span class="number">2</span>)&#123;  </span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;  </span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;  </span><br><span class="line">            <span class="keyword">return</span> RectCover(target-<span class="number">1</span>)+RectCover(target-<span class="number">2</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>如何终止一个线程</title>
      <link href="/2017/03/23/%E5%A6%82%E4%BD%95%E7%BB%88%E6%AD%A2%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B/"/>
      <url>/2017/03/23/%E5%A6%82%E4%BD%95%E7%BB%88%E6%AD%A2%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="JAVA如何让一个线程死亡或结束"><a href="#JAVA如何让一个线程死亡或结束" class="headerlink" title="JAVA如何让一个线程死亡或结束"></a>JAVA如何让一个线程死亡或结束</h1><p>&emsp;&emsp;不推荐使用stop()方法终止线程。，因为stop()方法容易引起死锁。<br><a id="more"></a><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>.<span class="comment">/**</span></span><br><span class="line"><span class="comment">2. * JAVA里面如何使用一个线程死亡或结束 *</span></span><br><span class="line"><span class="comment">3. */</span></span><br><span class="line"><span class="number">4</span>.<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T</span> </span>&#123;</span><br><span class="line"><span class="number">5</span>.  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="number">6</span>.    <span class="comment">// 启动线程</span></span><br><span class="line"><span class="number">7</span>.    MyThread thread = <span class="keyword">new</span> MyThread();</span><br><span class="line"><span class="number">8</span>.    <span class="keyword">new</span> Thread(thread).start();</span><br><span class="line"><span class="number">9</span>.</span><br><span class="line"><span class="number">10</span>.    <span class="comment">// 你的其它的工作，此时线程在运行中</span></span><br><span class="line"><span class="number">11</span>.</span><br><span class="line"><span class="number">12</span>.    <span class="comment">// 你不想让线程干活了，停掉它</span></span><br><span class="line"><span class="number">13</span>.    <span class="comment">// 注意，这只是一个标志，具体线程何时停，并不能精确控制</span></span><br><span class="line"><span class="number">14</span>.    thread.allDone = <span class="keyword">true</span>;</span><br><span class="line"><span class="number">15</span>.  &#125;</span><br><span class="line"><span class="number">16</span>.&#125;</span><br><span class="line"><span class="number">17</span>.</span><br><span class="line"><span class="number">18</span>.<span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"><span class="number">19</span>.  <span class="keyword">boolean</span> **<span class="keyword">volatile</span>** allDone = <span class="keyword">false</span>;</span><br><span class="line"><span class="number">20</span>.</span><br><span class="line"><span class="number">21</span>.  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="number">22</span>.    <span class="comment">// 每次循环都检测标志</span></span><br><span class="line"><span class="number">23</span>.    <span class="comment">// 如果设置停止标志时已经在循环里</span></span><br><span class="line"><span class="number">24</span>.    <span class="comment">// 则最长需要等待一个循环的时间才能终止</span></span><br><span class="line"><span class="number">25</span>.    <span class="keyword">while</span> (!allDone) &#123;</span><br><span class="line"><span class="number">26</span>.      <span class="comment">// 循环里的工作</span></span><br><span class="line"><span class="number">27</span>.    &#125;</span><br><span class="line"><span class="number">28</span>.  &#125;</span><br><span class="line"><span class="number">29</span>.&#125;</span><br></pre></td></tr></table></figure></p><p>使用 volatile 标识的变量具有线程可见性。当一个线程修改了这个变量的值，其他线程立即可以知道。所以可以避免多CPU出问题。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 线程 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>求二叉树的深度</title>
      <link href="/2017/03/21/%E6%B1%82%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6/"/>
      <url>/2017/03/21/%E6%B1%82%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6/</url>
      
        <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><div class="note success"><p>&emsp;&emsp;输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。  </p></div><a id="more"></a># 思路&emsp;&emsp;递归求解# 代码undefined&emsp;下面是一个跟上面类似的题目。# 题目描述<div class="note success"><p>&emsp;&emsp;判断一棵树是不是平衡二叉树。平衡二叉树指左右子树的高度不超过1的二叉树。<br>思路很简单，直接贴代码。</p></div><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断一棵树是不是平衡二叉树</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 思路：递归求左右子树的深度，比较判断是否是平衡二叉树</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> XIAO</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IsBalancedBinaryTree</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">IsBalanced_Solution</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> left = getDepth(root.left);</span><br><span class="line"><span class="keyword">int</span> right = getDepth(root.right);</span><br><span class="line"><span class="keyword">if</span> (Math.abs(left - right) &gt; <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归求解二叉树的深度</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getDepth</span><span class="params">(TreeNode node)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> left = getDepth(node.left);</span><br><span class="line"><span class="keyword">int</span> right = getDepth(node.right);</span><br><span class="line"><span class="keyword">return</span> left &gt; right ? left + <span class="number">1</span> : right + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>第一个只出现一次的字符</title>
      <link href="/2017/03/21/%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E5%AD%97%E7%AC%A6/"/>
      <url>/2017/03/21/%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E5%AD%97%E7%AC%A6/</url>
      
        <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>&emsp;&emsp;在一个字符串(1&lt;=字符串长度&lt;=10000，全部由大写字母组成)中找到第一个只出现一次的字符,并返回它的位置.<br><a id="more"></a></p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>&emsp;&emsp;暴力求解。</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在一个字符串(1&lt;=字符串长度&lt;=10000，全部由大写字母组成)中找到第一个只出现一次的字符,并返回它的位置</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 思路：暴力求解</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> XIAO</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FirstNotRepeatingCharSolution</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">FirstNotRepeatingChar</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (str == <span class="keyword">null</span> || str.length() == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 用一个map记录每个字符出现的次数</span></span><br><span class="line">HashMap&lt;Character, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length(); i++) &#123;</span><br><span class="line"><span class="keyword">char</span> c = str.charAt(i);</span><br><span class="line"><span class="keyword">if</span> (map.containsKey(c)) &#123;</span><br><span class="line"><span class="keyword">int</span> times = map.get(c);</span><br><span class="line">times += <span class="number">1</span>;</span><br><span class="line">map.put(c, times);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">map.put(c, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 出现一次的字符 首次出现的索引</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length(); i++) &#123;</span><br><span class="line"><span class="keyword">char</span> c2 = str.charAt(i);</span><br><span class="line"><span class="keyword">if</span> (map.get(c2) == <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>第N个丑数</title>
      <link href="/2017/03/20/%E7%AC%ACN%E4%B8%AA%E4%B8%91%E6%95%B0/"/>
      <url>/2017/03/20/%E7%AC%ACN%E4%B8%AA%E4%B8%91%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><div class="note primary"><p>&emsp;&emsp;把只包含因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含因子7。习惯上<br>我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。 </p></div><a id="more"></a><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><div class="note success"><p>&emsp;&emsp;暴力求解思路。首先我们要搞清楚怎么求丑数。ugly[]表示丑数数组。</p></div><ol><li>ugly[0]=1;</li><li>ugly[1]=1*2;</li><li>ugly[3]=1*3;</li><li>ugly[4]=1<em>2</em>2;</li><li>ugly[5]=1*5;</li><li>ugly[6]=1<em>2</em>3;</li><li>…<br>&emsp;&emsp;是不是可以找出规律来，我们需要记录 丑数中因子 2,3,5 出现的次数。具体用语言不好描述，可以看出规律。<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 把只包含因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含因子7。</span></span><br><span class="line"><span class="comment"> * 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> XIAO</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GetUglyNumber</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">GetUglyNumber_Solution</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (index &lt;= <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[index];</span><br><span class="line">result[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> i2 = <span class="number">0</span>, i3 = <span class="number">0</span>, i5 = <span class="number">0</span>;<span class="comment">// i2,i3,i5分别记录丑数的因子中2,3,5的个数</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; index; i++) &#123;</span><br><span class="line">result[i] = min(result[i2] * <span class="number">2</span>, min(result[i3] * <span class="number">3</span>, result[i5] * <span class="number">5</span>));</span><br><span class="line"><span class="keyword">if</span> (result[i] == result[i2] * <span class="number">2</span>) &#123;</span><br><span class="line">i2++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (result[i] == result[i3] * <span class="number">3</span>) &#123;</span><br><span class="line">i3++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (result[i] == result[i5] * <span class="number">5</span>) &#123;</span><br><span class="line">i5++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result[index - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> i &gt; j ? j : i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>把数组排成最小的数</title>
      <link href="/2017/03/20/%E6%8A%8A%E6%95%B0%E7%BB%84%E6%8E%92%E6%88%90%E6%9C%80%E5%B0%8F%E7%9A%84%E6%95%B0/"/>
      <url>/2017/03/20/%E6%8A%8A%E6%95%B0%E7%BB%84%E6%8E%92%E6%88%90%E6%9C%80%E5%B0%8F%E7%9A%84%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>&emsp;&emsp;输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。<br><a id="more"></a></p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>&emsp;&emsp;不得不说，看了这题的解法，真的佩服！~<br>&emsp;&emsp;先将整型数组转换成String数组，然后将String数组排序，最后将排好序的字符串数组拼接出来。关键就是制定排序规则。<br>为什么需要定制排序，因为字符串 a和b 长度不等的情况。比如 “2” 和 “21” ,显然字符串”2”&lt;”21”,但是把他们链接起来的时候 221&gt;212.所以定制一种规则来排除这种情况。<br>定制排序规则如下：  若ab &gt; ba  则 a &gt; b， 若ab &lt; ba 则 a &lt; b，若ab = ba 则 a = b；<br>这个定制排序很妙！</p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。</span></span><br><span class="line"><span class="comment"> * 例如输入数组&#123;3，32，321&#125;，则打印出这三个数字能排成的最小数字为321323。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 思路：真的思路太强。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 先将整型数组转换成String数组，然后将String数组排序，最后将排好序的字符串数组拼接出来。关键就是制定排序规则。  排序规则如下：  若ab &gt;</span></span><br><span class="line"><span class="comment"> * ba 则 a &gt; b，  若ab &lt; ba 则 a &lt; b， 若ab = ba 则 a = b；  解释说明： * 比如 "3" &lt;"31" 但是</span></span><br><span class="line"><span class="comment"> * "331" &gt; "313"，所以要将二者拼接起来进行比较</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> XIAO</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MinNumberArray</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">PrintMinNumber</span><span class="params">(<span class="keyword">int</span>[] numbers)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (numbers == <span class="keyword">null</span> || numbers.length == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> length = numbers.length;</span><br><span class="line">String[] strings = <span class="keyword">new</span> String[length];</span><br><span class="line"><span class="comment">// 把整型数转换成字符串</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; strings.length; i++) &#123;</span><br><span class="line">strings[i] = String.valueOf(numbers[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 对字符串数组进行排序</span></span><br><span class="line">Arrays.sort(strings, <span class="keyword">new</span> Comparator&lt;String&gt;() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(String o1, String o2)</span> </span>&#123;</span><br><span class="line">String s1 = o1 + o2;</span><br><span class="line">String s2 = o2 + o1;</span><br><span class="line"><span class="keyword">return</span> s1.compareTo(s2);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">StringBuilder builder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"><span class="comment">//把排序好的字符串拼接在一起</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; strings.length; i++) &#123;</span><br><span class="line">builder.append(strings[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> builder.toString();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>连续子数组的最大和</title>
      <link href="/2017/03/19/%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C/"/>
      <url>/2017/03/19/%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C/</url>
      
        <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>&emsp;&emsp;在古老的一维模式识别中,常常需要计算连续子向量的最大和,当向量全为正数的时候,问题很好解决。但是,如果向量中包含负数,是否应该包含某个负数,并期望旁边的正数会弥补它呢？例如:{6,-3,-2,7,-15,1,2,2},连续子向量的最大和为8(从第0个开始,到第3个为止)。你会不会被他忽悠住？(子向量的长度至少是1)</p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><div class="note primary"><p>test </p></div>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hexo利用Github分支在不同电脑上写博客</title>
      <link href="/2017/03/19/Hexo%E5%88%A9%E7%94%A8Github%E5%88%86%E6%94%AF%E5%9C%A8%E4%B8%8D%E5%90%8C%E7%94%B5%E8%84%91%E4%B8%8A%E5%86%99%E5%8D%9A%E5%AE%A2/"/>
      <url>/2017/03/19/Hexo%E5%88%A9%E7%94%A8Github%E5%88%86%E6%94%AF%E5%9C%A8%E4%B8%8D%E5%90%8C%E7%94%B5%E8%84%91%E4%B8%8A%E5%86%99%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>利用github的不同分支来分别保存网站静态文件与hexo源码（md原始文件及主题等），实现在不同电脑上都可以自由写博客。 </p></blockquote><h2 id="Github-Page"><a href="#Github-Page" class="headerlink" title="Github Page"></a>Github Page</h2><p>这里假设你已经在github上建好了page的仓库，也就是 “yourusername.github.io”的名字的项目仓库，比如我的 xiaoybboy.github.io 。另外，也假设你在自己的电脑上已经配置好git、hexo、node js等环境。<br><a id="more"></a></p><h2 id="新建hexo分支"><a href="#新建hexo分支" class="headerlink" title="新建hexo分支"></a>新建hexo分支</h2><p>仓库建好之后，都是默认一个master分支的，Github page要求你的网站文件必须存放在这个master分支上，这个没得选；所以我们需要新建另外一个分支来保存我们的hexo原始文件；master 保存的全是public 文件夹下的内容，这也是 hexo发布到github上的内容，而hexo这个分支，保存的是我们网站的配置 。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git branch hexo</span><br><span class="line">git checkout hexo</span><br><span class="line">git add remote origin git@github.com:xiaoybboy/xiaoybboy.github.io.git</span><br><span class="line">git push -u origin hexo:hexo</span><br></pre></td></tr></table></figure></p><h2 id="设置默认分支"><a href="#设置默认分支" class="headerlink" title="设置默认分支"></a>设置默认分支</h2><p>因为我们写博客更多的是更新这个分支，网站文件所在的master分支则由hexo d命令发布文章的时候进行推送，所以我们将hexo分支设置为默认分支，这样我们在新的电脑环境下git clone该仓库时，自动切到hexo`分支。按下图进行操作。<br><img src="https://i.imgur.com/4BoTift.png" alt="设置默认分支"></p><h2 id="配置hexo-deploy参数"><a href="#配置hexo-deploy参数" class="headerlink" title="配置hexo deploy参数"></a>配置hexo deploy参数</h2><p>为了保证hexo d命令可以正确部署到master分支，在hexo 的配置文件 _config.yml文件中配置参数如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: https://github.com/dxjia/dxjia.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure></p><p>hexo 3.0之后 deploy type，将github改为了git，这样适用性更广了，如果你发现无法hexo d，使用下面的命令安装git deployer插件后重试即可。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure></p><h2 id="修改推送到hexo分支"><a href="#修改推送到hexo分支" class="headerlink" title="修改推送到hexo分支"></a>修改推送到hexo分支</h2><p>上一步的deploy参数正确配置后，文章写完使用hexo g -d命令就可以直接部署了，生成的博客静态文件会自动部署到 username.github.io仓库的master分支上，这时候通过浏览器访问<a href="http://username.github.io就可以看到你的博客页面里。" target="_blank" rel="noopener">http://username.github.io就可以看到你的博客页面里。</a><br>网站页面是保存了，但这时候我们还没有保存我们的hexo原始文件，包括我们的文章md文件，我们千辛万苦修改的主题配置等。。。接下来使用下面的步骤将他们都统统推送到hexo分支上去。其中目录下的.gitignore 表示哪些文件或文件夹不提交，根据自己需要配置。<br>如果没有.git文件，先git init。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m “change description”</span><br><span class="line">git push origin hexo</span><br></pre></td></tr></table></figure></p><p>如果没关联远程仓库，执行第三步会出错。和远程仓库关联执行：git remote add origin &lt;远程仓库地址&gt;<br>这样就OK了，我们的原始文件就都上去了，换电脑也不怕了。</p><h2 id="日常写博客"><a href="#日常写博客" class="headerlink" title="日常写博客"></a>日常写博客</h2><p>有时候我们可能会在不同的电脑上写博客，那在不同的电脑上配置 hexo、git、node.js，以及配置git ssh key等都要折腾一下的，这是免不了的，也是比wordpress等其他博客框架麻烦的一点。</p><h2 id="已有环境"><a href="#已有环境" class="headerlink" title="已有环境"></a>已有环境</h2><p>如果在电脑上已经写过博客，那么可以在已有的工作目录下同步之前写的博客。<br>在你的仓库目录下右键’git bash shell’，起来bash命令行，然后<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull</span><br></pre></td></tr></table></figure></p><p>这样你的状态就更新了，之后就是 hexo命令写文章啦。。。<br>写完hexo g -d部署好后，使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m “change description”</span><br><span class="line">git push origin hexo</span><br></pre></td></tr></table></figure></p><p>推送到hexo分支上去。</p><h2 id="新的环境"><a href="#新的环境" class="headerlink" title="新的环境"></a>新的环境</h2><p>到了新的电脑上时，我们需要将项目先下载到本地，然后再进行hexo初始化。<br><strong>记住不需要hexo init指令</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git clone git@github.com:xiaoybboy/xiaoybboy.github.io.git</span><br><span class="line">cd xiaoybboy.github.io</span><br><span class="line">npm install hexo</span><br><span class="line">npm install</span><br><span class="line">npm install hexo-deployer-git –save</span><br></pre></td></tr></table></figure></p><p>之后开始写博客，写好部署好之后，别忘记 git add , ….git push origin hexo…推上去。。。<br>原文地址：<a href="http://dxjia.cn/2016/01/27/hexo-write-everywhere/" title="原文" target="_blank" rel="noopener">http://dxjia.cn/2016/01/27/hexo-write-everywhere/</a></p>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>hexo提交新文章错误</title>
      <link href="/2017/03/19/hexo%E6%8F%90%E4%BA%A4%E6%96%B0%E6%96%87%E7%AB%A0%E9%94%99%E8%AF%AF/"/>
      <url>/2017/03/19/hexo%E6%8F%90%E4%BA%A4%E6%96%B0%E6%96%87%E7%AB%A0%E9%94%99%E8%AF%AF/</url>
      
        <content type="html"><![CDATA[<h1 id="hexo提交新文章出错"><a href="#hexo提交新文章出错" class="headerlink" title="hexo提交新文章出错"></a>hexo提交新文章出错</h1><p>&emsp;&emsp;提交文章的时候报了下面这个错误，<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">ERROR Process failed: _posts/数组中出现次数超过一半的数字.md</span><br><span class="line">YAMLException: can not read a block mapping entry; a multiline key may not be an                                             implicit key at line 5, column 1:</span><br><span class="line"></span><br><span class="line">    ^</span><br><span class="line">    at generateError (F:\Myblog\hexo\node_modules\hexo\node_modules\js-yaml\lib\                                            js-yaml\loader.js:162:10)</span><br><span class="line">    at throwError (F:\Myblog\hexo\node_modules\hexo\node_modules\js-yaml\lib\js-                                            yaml\loader.js:168:9)</span><br><span class="line">    at readBlockMapping (F:\Myblog\hexo\node_modules\hexo\node_modules\js-yaml\l                                            ib\js-yaml\loader.js:1045:9)</span><br><span class="line">    at composeNode (F:\Myblog\hexo\node_modules\hexo\node_modules\js-yaml\lib\js                                            -yaml\loader.js:1331:12)</span><br><span class="line">    at readDocument (F:\Myblog\hexo\node_modules\hexo\node_modules\js-yaml\lib\j                                            s-yaml\loader.js:1493:3)</span><br><span class="line">    at loadDocuments (F:\Myblog\hexo\node_modules\hexo\node_modules\js-yaml\lib\                                            js-yaml\loader.js:1549:5)</span><br><span class="line">    at Object.load (F:\Myblog\hexo\node_modules\hexo\node_modules\js-yaml\lib\js                                            -yaml\loader.js:1566:19)</span><br><span class="line">    at parseYAML (F:\Myblog\hexo\node_modules\hexo\node_modules\hexo-front-matte                                            r\lib\front_matter.js:80:21)</span><br><span class="line">    at parse (F:\Myblog\hexo\node_modules\hexo\node_modules\hexo-front-matter\li                                            b\front_matter.js:56:12)</span><br><span class="line">    at F:\Myblog\hexo\node_modules\hexo\lib\plugins\processor\post.js:52:18</span><br><span class="line">    at tryCatcher (F:\Myblog\hexo\node_modules\hexo\node_modules\bluebird\js\rel                                            ease\util.js:16:23)</span><br><span class="line">    at Promise._settlePromiseFromHandler (F:\Myblog\hexo\node_modules\hexo\node_                                            modules\bluebird\js\release\promise.js:509:35)</span><br><span class="line">    at Promise._settlePromise (F:\Myblog\hexo\node_modules\hexo\node_modules\blu                                            ebird\js\release\promise.js:569:18)</span><br><span class="line">    at Promise._settlePromise0 (F:\Myblog\hexo\node_modules\hexo\node_modules\bl                                            uebird\js\release\promise.js:614:10)</span><br><span class="line">    at Promise._settlePromises (F:\Myblog\hexo\node_modules\hexo\node_modules\bl                                            uebird\js\release\promise.js:693:18)</span><br><span class="line">    at Promise._fulfill (F:\Myblog\hexo\node_modules\hexo\node_modules\bluebird\                                            js\release\promise.js:638:18)</span><br><span class="line">    at PromiseArray._resolve (F:\Myblog\hexo\node_modules\hexo\node_modules\blue                                            bird\js\release\promise_array.js:126:19)</span><br><span class="line">    at PromiseArray._promiseFulfilled (F:\Myblog\hexo\node_modules\hexo\node_mod                                            ules\bluebird\js\release\promise_array.js:144:14)</span><br><span class="line">    at PromiseArray._iterate (F:\Myblog\hexo\node_modules\hexo\node_modules\blue</span><br></pre></td></tr></table></figure></p><p>仔细排查之后，发现是文章开头的categroies的冒号，写成了中文的冒号。额。。。</p>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>数组中出现次数超过一半的数字</title>
      <link href="/2017/03/19/%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E8%B6%85%E8%BF%87%E4%B8%80%E5%8D%8A%E7%9A%84%E6%95%B0%E5%AD%97/"/>
      <url>/2017/03/19/%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E8%B6%85%E8%BF%87%E4%B8%80%E5%8D%8A%E7%9A%84%E6%95%B0%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>&emsp;&emsp;数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。<br><a id="more"></a></p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>&emsp;&emsp;对于这个问题提供两个解题思路。还有很多其他解法。</p><ol><li>利用排序。先对数组进行排序，因为题目已知，有一个数字出现的次数超过了数组长度的一半。显然，排序完成之<br>后中间的那个数组必定是这个数组。复杂度O(nlgn)</li><li>充分利用数组中有一个数字出现的次数超过数组长度的一半这个条件。这个数一定是相邻重复出现的次数最多的数。<br>即使是最差情况，隔一个数插入这个数，最终这个数必定会出现在最后一位（还是因为出现次数大于数组长度的一半）。<br>这个算法的复杂度只有O（n），不得不说，这个思路真的巧妙。<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组&#123;1,2,3,2,2,2,5,4,2&#125;。</span></span><br><span class="line"><span class="comment"> * 由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 思路1：快速排序 思路2：找最大相邻重复出现的元素</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> XIAO</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MoreThanHalfNumArray</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 第一种思路</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> array</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">MoreThanHalfNum_Solution</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 判断数组长度是否为0或者数组为null</span></span><br><span class="line"><span class="keyword">if</span> (array.length == <span class="number">0</span> || array == <span class="keyword">null</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">Arrays.sort(array);<span class="comment">// 快速排序对数组进行排序</span></span><br><span class="line"><span class="keyword">int</span> mid = array[(array.length) / <span class="number">2</span>];<span class="comment">// 中间的元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对mid 进行验证</span></span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (mid == array[i]) &#123;</span><br><span class="line">count++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> count &gt; (array.length / <span class="number">2</span>) ? mid : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二种思路，想了很久才想明白。关键是利用有一个数的出现次数大于数组长度的一半这个条件</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">MoreThanHalfNum_Solution2</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 判断数组长度是否为0或者数组为null</span></span><br><span class="line"><span class="keyword">if</span> (array.length == <span class="number">0</span> || array == <span class="keyword">null</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 寻找相邻重复次数最多的元素</span></span><br><span class="line"><span class="keyword">int</span> temp = array[<span class="number">0</span>];<span class="comment">// 从第一个元素开始找</span></span><br><span class="line"><span class="keyword">int</span> times = <span class="number">1</span>;<span class="comment">// 重复出现的次数</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; array.length; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (times == <span class="number">0</span>) &#123;</span><br><span class="line">temp = array[i];<span class="comment">// 最后一次赋值的必定是我们要找的元素</span></span><br><span class="line">times = <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (array[i] == temp) &#123;</span><br><span class="line">times++;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">times--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 验证</span></span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (array[i] == temp) &#123;</span><br><span class="line">count++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> count &gt; (array.length / <span class="number">2</span>) ? temp : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>&emsp;&emsp;总体来看，第一种方法比较容易想到，时间复杂度较高。第二种方法想了很久才想明白，哎，算法能力<br>有待提高！时间复杂度才O(N)!其他还有很多方法，有待考虑。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>按字典序输出一个字符串的全排序</title>
      <link href="/2017/03/18/%E6%8C%89%E5%AD%97%E5%85%B8%E5%BA%8F%E8%BE%93%E5%87%BA%E4%B8%80%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%85%A8%E6%8E%92%E5%BA%8F/"/>
      <url>/2017/03/18/%E6%8C%89%E5%AD%97%E5%85%B8%E5%BA%8F%E8%BE%93%E5%87%BA%E4%B8%80%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%85%A8%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>&emsp;&emsp;输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。<br><a id="more"></a></p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>&emsp;&emsp;大脑短路了，想明白这个竟然花了半小时。这个题目的核心其实是求解一个字符串的全排列。因为字典序只需要用<br>Collection.sort()方法排序一个ArrayList<string> 或者TreeSet就行了。<br>&emsp;主要说下怎么对一个字符串进行全排列。比如说”abcd”怎么全排序呢?直觉告诉我们先把a放第一位，对”bcd”再进行全排列，就是一个递归。然后把b放在第一位，”acd”进行递归。…具体操作下面结合代码说。<br>&emsp;下面就是对全排列的字符串进行排序操作，按字典序输出即可。</string></p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串</span></span><br><span class="line"><span class="comment"> * abc,acb,bac,bca,cab和cba。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 思路：先求解字符串的全排列，然后对这些全排列进行排序。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> XIAO</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringPermutationSort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> ArrayList&lt;String&gt; <span class="title">Permutation</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">ArrayList&lt;String&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();<span class="comment">// 保存全排列的结果</span></span><br><span class="line"><span class="keyword">if</span> (str != <span class="keyword">null</span> &amp;&amp; str.length() &gt; <span class="number">0</span>) &#123;<span class="comment">// 如果str不为空           </span></span><br><span class="line">Permutation(str.toCharArray(), <span class="number">0</span>, result);<span class="comment">// 获取字符串的全排列  </span></span><br><span class="line">&#125;</span><br><span class="line">Collections.sort(result);<span class="comment">// 对全排列的字符串进行排序</span></span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * i 表示起始位置，从i这个位置开始向后寻找下面字符的全排列</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> charArray</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> i</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> result</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Permutation</span><span class="params">(<span class="keyword">char</span>[] charArray, <span class="keyword">int</span> i, ArrayList&lt;String&gt; result)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 如果 i 是最后一个字符位置</span></span><br><span class="line"><span class="keyword">if</span> (i == charArray.length - <span class="number">1</span>) &#123;</span><br><span class="line">result.add(String.valueOf(charArray));<span class="comment">// 找到一个全排序</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt;= charArray.length - <span class="number">1</span>; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (j != i &amp;&amp; charArray[j] == charArray[i])<span class="comment">// 有重复字符时，跳过</span></span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">swap(charArray, i, j);</span><br><span class="line">Permutation(charArray, i + <span class="number">1</span>, result);</span><br><span class="line">swap(charArray, i, j);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 交换字符数组s的第i个位置和第j个位置的字符</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">char</span>[] s, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (s[i] == s[j]) &#123;</span><br><span class="line">;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">char</span> c = s[i];</span><br><span class="line">s[i] = s[j];</span><br><span class="line">s[j] = c;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;回头再看究竟是怎么全排列的吧。就是这个函数 private void Permutation(char[] charArray, int i, ArrayList<string> result) 的递归过程。其中 i 表示起始位置，从i这个位置开始向后寻找下面字符的全排列。当i == charArray.length - 1 时，表示已经到了最后一个字符，那么就找到了一个全排列。下面很好看懂，就是递归向下找，但是为什么要交换两次 charArray i和j 位置的字符呢？<br>&emsp;&emsp;其实拿”abcd”来说，当我们交换 a和b 的位置（第一次交换），然后用b作为首字符寻找全排列。但是下次我们要交换 a和c 的位置，但是这时候 a和b 已经交换了，所以要把 a和b 换回来，才能保证每次交换的顺序没有乱。</string></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>二叉搜索树与双向链表</title>
      <link href="/2017/03/18/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/"/>
      <url>/2017/03/18/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>&emsp;&emsp;输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。<br><a id="more"></a></p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>&emsp;&emsp;使用递归的思想。步骤如下：<br>&emsp;1. 将左子树构造成双链表，并返回链表头节点。<br>&emsp;2. 定位至左子树双链表最后一个节点。<br>&emsp;3. 如果左子树链表不为空的话，将当前root追加到左子树链表。<br>&emsp;4. 将右子树构造成双链表，并返回链表头节点。<br>&emsp;5. 如果右子树链表不为空的话，将该链表追加到root节点之后。<br>&emsp;6. 根据左子树链表是否为空确定返回的节点。</p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。</span></span><br><span class="line"><span class="comment"> * 思路：解题思路：</span></span><br><span class="line"><span class="comment">1.将左子树构造成双链表，并返回链表头节点。</span></span><br><span class="line"><span class="comment">2.定位至左子树双链表最后一个节点。</span></span><br><span class="line"><span class="comment">3.如果左子树链表不为空的话，将当前root追加到左子树链表。</span></span><br><span class="line"><span class="comment">4.将右子树构造成双链表，并返回链表头节点。</span></span><br><span class="line"><span class="comment">5.如果右子树链表不为空的话，将该链表追加到root节点之后。</span></span><br><span class="line"><span class="comment">6.根据左子树链表是否为空确定返回的节点。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> XIAO</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinaryTreeLinkedList</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">Convert</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果root的左右子树都为空</span></span><br><span class="line"><span class="keyword">if</span> (root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line">TreeNode left = Convert(root.left);<span class="comment">// 把root节点的左子树转成链表，返回值为链表的头</span></span><br><span class="line">TreeNode p = left;</span><br><span class="line"><span class="keyword">while</span> (p != <span class="keyword">null</span> &amp;&amp; p.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">p = p.right;<span class="comment">// 循环定位到左子树双链表的最后一个节点</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果左子树链表不为空的话，将当前root追加到左子树链表</span></span><br><span class="line"><span class="keyword">if</span> (left != <span class="keyword">null</span>) &#123;</span><br><span class="line">p.right = root;<span class="comment">// 把root连接到左子树形成的双向链表中，双向链表，需要左右都连接</span></span><br><span class="line">root.left = p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 同样的，把根节点的右子树也形成双向链表，返回值为链表头</span></span><br><span class="line">TreeNode right = Convert(root.right);</span><br><span class="line"><span class="comment">// 把右子树的链表连接到上面的左子树和根节点的链表中</span></span><br><span class="line"><span class="keyword">if</span> (right != <span class="keyword">null</span>) &#123;</span><br><span class="line">root.right = right;<span class="comment">// 同样把右子树的链表连接上去</span></span><br><span class="line">right.left = root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> left != <span class="keyword">null</span> ? left : root;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>二叉树中和为某一值的路径</title>
      <link href="/2017/03/18/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84/"/>
      <url>/2017/03/18/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84/</url>
      
        <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>&emsp;&emsp;输入一颗二叉树和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。<br><a id="more"></a></p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; listAll = <span class="keyword">new</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; FindPath(TreeNode root,<span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> listAll;</span><br><span class="line">        list.add(root.val);</span><br><span class="line">        target -= root.val;</span><br><span class="line">        <span class="keyword">if</span>(target == <span class="number">0</span> &amp;&amp; root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>)</span><br><span class="line">            listAll.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;(list));</span><br><span class="line">        FindPath(root.left, target);</span><br><span class="line">        FindPath(root.right, target);</span><br><span class="line">        list.remove(list.size()-<span class="number">1</span>);<span class="comment">//返回父节点继续搜索</span></span><br><span class="line">        <span class="keyword">return</span> listAll;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>测试字符串中是否包含重复字符</title>
      <link href="/2017/03/18/%E6%B5%8B%E8%AF%95%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E6%98%AF%E5%90%A6%E5%8C%85%E5%90%AB%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6/"/>
      <url>/2017/03/18/%E6%B5%8B%E8%AF%95%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E6%98%AF%E5%90%A6%E5%8C%85%E5%90%AB%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6/</url>
      
        <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>&emsp;&emsp;请实现一个算法，确定一个字符串的所有字符全都不同。要求不允许使用额外的存储空间。</p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>&emsp;&emsp;暂时没想到好的思路，只能暴力求解。<br><a id="more"></a></p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringRepeat</span> </span>&#123;  </span><br><span class="line">    <span class="comment">// 暴力求解，双层循环，一一比较  </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkDifferent</span><span class="params">(String iniString)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;iniString.length();i++) &#123;  </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>;j&lt;iniString.length();j++) &#123;  </span><br><span class="line">                <span class="keyword">if</span> (iniString.charAt(i) == iniString.charAt(j))  </span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hello World</title>
      <link href="/2017/03/07/hello-world/"/>
      <url>/2017/03/07/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><a id="more"></a><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> github </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
