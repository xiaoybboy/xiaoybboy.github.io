<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>David Aaronson</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="www.xiaoyb.cc/"/>
  <updated>2020-03-10T15:05:21.026Z</updated>
  <id>www.xiaoyb.cc/</id>
  
  <author>
    <name>David Aaronson</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>SpringMVC注解@ControllerAdvice</title>
    <link href="www.xiaoyb.cc/2020/03/09/SpringMVC%E6%B3%A8%E8%A7%A3-ControllerAdvice/"/>
    <id>www.xiaoyb.cc/2020/03/09/SpringMVC注解-ControllerAdvice/</id>
    <published>2020-03-09T15:34:08.000Z</published>
    <updated>2020-03-10T15:05:21.026Z</updated>
    
    <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>@ControllerAdvice顾名思义，用于Controller增强，是一个在类上声明的注解，可以用于定义@ExceptionHandler、@InitBinder、@ModelAttribute，并应用到所有@RequestMapping、@PostMapping， @GetMapping注解中。</p><p>使用方法常见有下面3种：</p><ol><li><p>结合方法型注解@ExceptionHandler，用于捕获Controller中抛出的指定类型的异常，从而达到不同类型的异常区别处理的目的；</p></li><li><p>结合方法型注解@InitBinder，用于request中自定义参数解析方式进行注册，从而达到自定义指定格式参数的目的。</p></li><li><p>结合方法型注解@ModelAttribute，表示其标注的方法将会在目标Controller方法执行之前执行。</p></li></ol><a id="more"></a><p>总体使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sam.demo.controller;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> org.springframework.ui.Model;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.WebDataBinder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.*;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * controller 增强器</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> sam</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2017/7/17</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyControllerAdvice</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 应用到所有<span class="doctag">@RequestMapping</span>注解方法，在其执行之前初始化数据绑定器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> binder</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@InitBinder</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initBinder</span><span class="params">(WebDataBinder binder)</span> </span>&#123;&#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 把值绑定到Model中，使全局<span class="doctag">@RequestMapping</span>可以获取到该值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> model</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ModelAttribute</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addAttributes</span><span class="params">(Model model)</span> </span>&#123;</span><br><span class="line">        model.addAttribute(<span class="string">"author"</span>, <span class="string">"Magical Sam"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 全局异常捕捉处理</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ex</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="meta">@ExceptionHandler</span>(value = Exception.class)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map <span class="title">errorHandler</span><span class="params">(Exception ex)</span> </span>&#123;</span><br><span class="line">        Map map = <span class="keyword">new</span> HashMap();</span><br><span class="line">        map.put(<span class="string">"code"</span>, <span class="number">100</span>);</span><br><span class="line">        map.put(<span class="string">"msg"</span>, ex.getMessage());</span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="1-ExceptionHandler"><a href="#1-ExceptionHandler" class="headerlink" title="1.@ExceptionHandler"></a>1.@ExceptionHandler</h1><p>  @ExceptionHandler的作用主要在于声明一个或多个类型的异常，当符合条件的Controller抛出这些异常之后将会对这些异常进行捕获，然后按照其标注的方法的逻辑进行处理，从而改变返回的视图信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebExceptionHandle</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Logger logger = LoggerFactory.getLogger(WebExceptionHandle.class);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 400 - Bad Request</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ResponseStatus</span>(HttpStatus.BAD_REQUEST)</span><br><span class="line">    <span class="meta">@ExceptionHandler</span>(HttpMessageNotReadableException.class)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ServiceResponse <span class="title">handleHttpMessageNotReadableException</span><span class="params">(HttpMessageNotReadableException e)</span> </span>&#123;</span><br><span class="line">        logger.error(<span class="string">"参数解析失败"</span>, e);</span><br><span class="line">        <span class="keyword">return</span> ServiceResponseHandle.failed(<span class="string">"could_not_read_json"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 405 - Method Not Allowed</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ResponseStatus</span>(HttpStatus.METHOD_NOT_ALLOWED)</span><br><span class="line">    <span class="meta">@ExceptionHandler</span>(HttpRequestMethodNotSupportedException.class)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ServiceResponse <span class="title">handleHttpRequestMethodNotSupportedException</span><span class="params">(HttpRequestMethodNotSupportedException e)</span> </span>&#123;</span><br><span class="line">        logger.error(<span class="string">"不支持当前请求方法"</span>, e);</span><br><span class="line">        <span class="keyword">return</span> ServiceResponseHandle.failed(<span class="string">"request_method_not_supported"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 415 - Unsupported Media Type</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ResponseStatus</span>(HttpStatus.UNSUPPORTED_MEDIA_TYPE)</span><br><span class="line">    <span class="meta">@ExceptionHandler</span>(HttpMediaTypeNotSupportedException.class)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ServiceResponse <span class="title">handleHttpMediaTypeNotSupportedException</span><span class="params">(Exception e)</span> </span>&#123;</span><br><span class="line">        logger.error(<span class="string">"不支持当前媒体类型"</span>, e);</span><br><span class="line">        <span class="keyword">return</span> ServiceResponseHandle.failed(<span class="string">"content_type_not_supported"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 500 - Internal Server Error</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ResponseStatus</span>(HttpStatus.INTERNAL_SERVER_ERROR)</span><br><span class="line">    <span class="meta">@ExceptionHandler</span>(Exception.class)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ServiceResponse <span class="title">handleException</span><span class="params">(Exception e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (e <span class="keyword">instanceof</span> BusinessException)&#123;</span><br><span class="line">            <span class="keyword">return</span> ServiceResponseHandle.failed(<span class="string">"BUSINESS_ERROR"</span>, e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        logger.error(<span class="string">"服务运行异常"</span>, e);</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        <span class="keyword">return</span> ServiceResponseHandle.failed(<span class="string">"server_error"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2-InitBinder"><a href="#2-InitBinder" class="headerlink" title="2.@InitBinder"></a>2.@InitBinder</h1><p>@InitBinder的主要作用是绑定一些自定义的参数。对于一些特殊类型参数，比如Date，它们的绑定Spring是没有提供直接的支持的，我们只能为其声明一个转换器，将request中字符串类型的参数通过转换器转换为Date类型的参数，从而供给@RequestMapping标注的方法使用。</p><p> 如下是使用@InitBinder注册Date类型参数转换器的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ControllerAdvice</span>(basePackages = <span class="string">"mvc"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringControllerAdvice</span> </span>&#123;</span><br><span class="line">  <span class="meta">@InitBinder</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">globalInitBinder</span><span class="params">(WebDataBinder binder)</span> </span>&#123;</span><br><span class="line">    binder.addCustomFormatter(<span class="keyword">new</span> DateFormatter(<span class="string">"yyyy-MM-dd"</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里@InitBinder标注的方法注册的转换器在每次request请求进行参数转换时都会调用，用于判断指定的参数是否为其可以转换的参数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/user"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@RequestMapping</span>(value = <span class="string">"/detail"</span>, method = RequestMethod.GET)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> ModelAndView <span class="title">detail</span><span class="params">(@RequestParam(<span class="string">"id"</span>)</span> <span class="keyword">long</span> id, Date date) </span>&#123;</span><br><span class="line">    System.out.println(date);</span><br><span class="line">    ModelAndView view = <span class="keyword">new</span> ModelAndView(<span class="string">"user"</span>);</span><br><span class="line">    User user = userService.detail(id);</span><br><span class="line">    view.addObject(<span class="string">"user"</span>, user);</span><br><span class="line">    <span class="keyword">return</span> view;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  在浏览器输入<a href="http://localhost:8080/user/detail?id=1&amp;date=2018-10-2，可以看到控制台进行了如下打印：" target="_blank" rel="noopener">http://localhost:8080/user/detail?id=1&amp;date=2018-10-2，可以看到控制台进行了如下打印：</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Tue Oct 02 00:00:00 CST 2018</span><br></pre></td></tr></table></figure><p>​    可以看到，这里我们对request参数进行了转换，并且在接口中成功接收了该参数。</p><h1 id="3-ModelAttribute"><a href="#3-ModelAttribute" class="headerlink" title="3. @ModelAttribute"></a>3. @ModelAttribute</h1><p>关于@ModelAttribute的用法，处理用于接口参数可以用于转换对象类型的属性之外，其还可以用来进行方法的声明。如果声明在方法上，并且结合@ControllerAdvice，该方法将会在@ControllerAdvice所指定的范围内的所有接口方法执行之前执行，并且@ModelAttribute标注的方法的返回值还可以供给后续会调用的接口方法使用。</p><p>  这里@ModelAttribute的各个属性值主要是用于其在接口参数上进行标注时使用的，如果是作为方法注解，其name或value属性则指定的是返回值的名称。如下是使用@ModelAttribute进行方法标注的一个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ControllerAdvice</span>(basePackages = <span class="string">"mvc"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringControllerAdvice</span> </span>&#123;</span><br><span class="line">  <span class="meta">@ModelAttribute</span>(value = <span class="string">"message"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">globalModelAttribute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"global model attribute."</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"this is from model attribute"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    这里需要注意的是，该方法提供了一个String类型的返回值，而@ModelAttribute中指定了该属性名称为message，这样在Controller层就可以接收该参数了，如下是Controller层的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/user"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@RequestMapping</span>(value = <span class="string">"/detail"</span>, method = RequestMethod.GET)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> ModelAndView <span class="title">detail</span><span class="params">(@RequestParam(<span class="string">"id"</span>)</span> <span class="keyword">long</span> id, </span></span><br><span class="line"><span class="function">       @<span class="title">ModelAttribute</span><span class="params">(<span class="string">"message"</span>)</span> String message) </span>&#123;</span><br><span class="line">    System.out.println(message);</span><br><span class="line">    ModelAndView view = <span class="keyword">new</span> ModelAndView(<span class="string">"user"</span>);</span><br><span class="line">    User user = userService.detail(id);</span><br><span class="line">    view.addObject(<span class="string">"user"</span>, user);</span><br><span class="line">    <span class="keyword">return</span> view;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    可以看到，这里使用@ModelAttribute注解接收名称为message的参数，从而获取了前面绑定的参数。运行上述代码并且访问<a href="http://localhost:8080/user/detail?id=1，可以看到页面进行了正常的展示，控制台也进行了如下打印：" target="_blank" rel="noopener">http://localhost:8080/user/detail?id=1，可以看到页面进行了正常的展示，控制台也进行了如下打印：</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">global model attribute.</span><br><span class="line">this is from model attribute</span><br></pre></td></tr></table></figure><p>​    可以看到，这里使用@ModelAttribute注解标注的方法确实在目标接口执行之前执行了。需要说明的是，@ModelAttribute标注的方法的执行是在所有拦截器的preHandle()方法执行之后才会执行。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h1&gt;&lt;p&gt;@ControllerAdvice顾名思义，用于Controller增强，是一个在类上声明的注解，可以用于定义@ExceptionHandler、@InitBinder、@ModelAttribute，并应用到所有@RequestMapping、@PostMapping， @GetMapping注解中。&lt;/p&gt;
&lt;p&gt;使用方法常见有下面3种：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;结合方法型注解@ExceptionHandler，用于捕获Controller中抛出的指定类型的异常，从而达到不同类型的异常区别处理的目的；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;结合方法型注解@InitBinder，用于request中自定义参数解析方式进行注册，从而达到自定义指定格式参数的目的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;结合方法型注解@ModelAttribute，表示其标注的方法将会在目标Controller方法执行之前执行。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="SpringMVC" scheme="www.xiaoyb.cc/tags/SpringMVC/"/>
    
  </entry>
  
  <entry>
    <title>springboot学习笔记</title>
    <link href="www.xiaoyb.cc/2018/10/29/springboot%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>www.xiaoyb.cc/2018/10/29/springboot学习笔记/</id>
    <published>2018-10-29T14:20:07.000Z</published>
    <updated>2018-10-29T14:53:09.580Z</updated>
    
    <content type="html"><![CDATA[<div class="note success"><p>一门技术如果不用，真是超快就忘记了。springboot都学几遍了，一两个星期不看，就忘得一干二净，索性自己好好总结一下，供以后经常翻翻，顺便熟悉一下idea。有很多其他大牛博客的东西，多找些资料总结一下。 </p></div><div class="note danger"><p>万事开头难，加油！</p></div><h2 id="Spring-Boot-配置文件"><a href="#Spring-Boot-配置文件" class="headerlink" title="Spring Boot 配置文件"></a>Spring Boot 配置文件</h2><p>SpringBoot使用一个全局的配置文件（resource文件夹下），配置文件名是固定的。<br>-application.properties<br>-application.yml<br>springboot推荐使用yml的方式进行配置（yml的确很方便）。<br>配置文件的作用：修改SpringBoot自动配置的默认值；</p><h3 id="自定义属性与使用"><a href="#自定义属性与使用" class="headerlink" title="自定义属性与使用"></a>自定义属性与使用</h3><p>虽然springboot帮我们配置了很多东西，但是有时候我们需要定义自己的配置，我们可以在application.yml中如下方式定义：<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">person:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">xyb</span></span><br><span class="line"><span class="attr">  age:</span> <span class="number">25</span></span><br><span class="line"><span class="attr">  address:</span> <span class="string">hns</span></span><br></pre></td></tr></table></figure></p><p>然后就可以通过@Value(“${属性名}”)注解来加载对应的配置属性，具体如下：</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;div class=&quot;note success&quot;&gt;&lt;p&gt;一门技术如果不用，真是超快就忘记了。springboot都学几遍了，一两个星期不看，就忘得一干二净，索性自己好好总结一下，供以后经常翻翻，顺便熟悉一下idea。有很多其他大牛博客的东西，多找些资料总结一下。 &lt;/p&gt;&lt;/d
      
    
    </summary>
    
      <category term="spring" scheme="www.xiaoyb.cc/categories/spring/"/>
    
    
      <category term="springboot" scheme="www.xiaoyb.cc/tags/springboot/"/>
    
  </entry>
  
  <entry>
    <title>好久不见</title>
    <link href="www.xiaoyb.cc/2018/10/05/%E5%A5%BD%E4%B9%85%E4%B8%8D%E8%A7%81/"/>
    <id>www.xiaoyb.cc/2018/10/05/好久不见/</id>
    <published>2018-10-05T14:55:25.000Z</published>
    <updated>2018-10-05T15:07:49.786Z</updated>
    
    <content type="html"><![CDATA[<h2 id="羞愧"><a href="#羞愧" class="headerlink" title="羞愧"></a>羞愧</h2><p>被社会的浮躁风气所感染，人都变得没有思想了。<br>不仅许久博客没写了，连读书也要丢弃了。趁着十一假期，脚上有伤，深刻反省了一波。<br>碎片化的阅读，抖音、头条让人变得如同不会思考，没有深度。感觉整个人都停滞不前，无法进步。<br>变成现在这样，非常羞愧！<br>正好把博客重新搭了一下，还是给自己点学习的压力。<br>希望自己坚持下去，保持一颗不焦虑的内心！</p><blockquote class="blockquote-center"><p>在浮躁的社会中，我携书本同行！ </p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;羞愧&quot;&gt;&lt;a href=&quot;#羞愧&quot; class=&quot;headerlink&quot; title=&quot;羞愧&quot;&gt;&lt;/a&gt;羞愧&lt;/h2&gt;&lt;p&gt;被社会的浮躁风气所感染，人都变得没有思想了。&lt;br&gt;不仅许久博客没写了，连读书也要丢弃了。趁着十一假期，脚上有伤，深刻反省了一波。&lt;br&gt;碎
      
    
    </summary>
    
      <category term="生活" scheme="www.xiaoyb.cc/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="生活" scheme="www.xiaoyb.cc/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>SpringMVC拦截器</title>
    <link href="www.xiaoyb.cc/2018/10/05/SpringMVC%E6%8B%A6%E6%88%AA%E5%99%A8/"/>
    <id>www.xiaoyb.cc/2018/10/05/SpringMVC拦截器/</id>
    <published>2018-10-05T06:42:35.000Z</published>
    <updated>2018-10-05T04:10:37.564Z</updated>
    
    <content type="html"><![CDATA[<div class="note success"><p>Spring MVC中的拦截器（Interceptor）类似于Servlet中的过滤器（Filter），它主要用于拦截用户请求并作相应的处理。通过拦截器可以进行权限验证、记录请求信息的日志、判断用户是否登录等。 </p></div><a id="more"></a><div class="note info"><p> SpringMVC 中的Interceptor 拦截请求是通过HandlerInterceptor 来实现的。<br>在SpringMVC 中定义一个Interceptor 主要有两种方式.</p><ol><li>第一种方式是要定义的Interceptor类要实现了Spring 的HandlerInterceptor 接口，或者是这个类继承实现了HandlerInterceptor 接口的类，如Spring已经提供的实现了HandlerInterceptor 接口的抽象类HandlerInterceptorAdapter;</li><li>第二种方式是实现Spring的WebRequestInterceptor接口，或者是继承实现了WebRequestInterceptor的类。</li></ol></div><h2 id="一-实现HandlerInterceptor接口"><a href="#一-实现HandlerInterceptor接口" class="headerlink" title="一.实现HandlerInterceptor接口"></a>一.实现HandlerInterceptor接口</h2><p>HandlerInterceptor 接口中定义了三个方法，我们就是通过这三个方法来对用户的请求进行拦截处理的。流程：<br><img src="http://i.imgur.com/GGUBVhn.png" alt=""><br><img src="https://i.imgur.com/8i84ykU.jpg" alt=""><br>注意postHandle方法的执行顺序与定义顺序正好相反。<br>接口实现如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringMVCInterceptor</span> <span class="keyword">implements</span> <span class="title">HandlerInterceptor</span> </span>&#123;  </span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * preHandle方法是进行处理器拦截用的，该方法将在Controller处理之前进行调用，SpringMVC中的Interceptor拦截器是链式的，可以同时存在 </span></span><br><span class="line"><span class="comment">     * 多个Interceptor，然后SpringMVC会根据声明的前后顺序一个接一个的执行，而且所有的Interceptor中的preHandle方法都会在 </span></span><br><span class="line"><span class="comment">     * Controller方法调用之前调用。SpringMVC的这种Interceptor链式结构也是可以进行中断的，这种中断方式是令preHandle的返 </span></span><br><span class="line"><span class="comment">     * 回值为false，当preHandle的返回值为false的时候整个请求就结束了。 </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request,  </span></span></span><br><span class="line"><span class="function"><span class="params">            HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception </span>&#123;  </span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub  </span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 这个方法只会在当前这个Interceptor的preHandle方法返回值为true的时候才会执行。postHandle是进行处理器拦截用的，它的执行时间是在处理器进行处理之 </span></span><br><span class="line"><span class="comment">     * 后，也就是在Controller的方法调用之后执行，但是它会在DispatcherServlet进行视图的渲染之前执行，也就是说在这个方法中你可以对ModelAndView进行操 </span></span><br><span class="line"><span class="comment">     * 作。这个方法的链式结构跟正常访问的方向是相反的，也就是说先声明的Interceptor拦截器该方法反而会后调用。 </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postHandle</span><span class="params">(HttpServletRequest request,  </span></span></span><br><span class="line"><span class="function"><span class="params">            HttpServletResponse response, Object handler,  </span></span></span><br><span class="line"><span class="function"><span class="params">            ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception </span>&#123;  </span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub   </span></span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 该方法也是需要当前对应的Interceptor的preHandle方法的返回值为true时才会执行。该方法将在整个请求完成之后，也就是DispatcherServlet渲染了视图执行， </span></span><br><span class="line"><span class="comment">     * 这个方法的主要作用是用于清理资源的，当然这个方法也只能在当前这个Interceptor的preHandle方法的返回值为true时才会执行。 </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterCompletion</span><span class="params">(HttpServletRequest request,  </span></span></span><br><span class="line"><span class="function"><span class="params">            HttpServletResponse response, Object handler, Exception ex)</span>  </span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> Exception </span>&#123;  </span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub   </span></span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ol><li>preHandle：预处理回调方法，实现处理器的预处理（如登录检查），第三个参数为响应的处理器（如我们上一章的Controller实现）；<br>返回值：true表示继续流程（如调用下一个拦截器或处理器）;<br>false表示流程中断（如登录检查失败），不会继续调用其他的拦截器或处理器，此时我们需要通过response来产生响应；</li><li>postHandle：后处理回调方法，实现处理器的后处理（但在渲染视图之前），此时我们可以通过modelAndView（模型和视图对象）对模型数据进行处理或对视图进行处理，modelAndView也可能为null。</li><li>afterCompletion：整个请求处理完毕回调方法，即在视图渲染完毕时回调，如性能监控中我们可以在此记录结束时间并输出消耗时间，还可以进行一些资源清理，类似于try-catch-finally中的finally，但仅调用处理器执行链中preHandle返回true的拦截器的afterCompletion。<div class="note primary"><p>在实际应用中，一般都是通过实现HandlerInterceptor接口或者继承HandlerInterceptorAdapter抽象类，复写preHandle()、postHandle()和afterCompletion()这 3 个方法来对用户的请求进行拦截处理的。</p></div></li></ol><h2 id="二-WebRequestInterceptor-接口"><a href="#二-WebRequestInterceptor-接口" class="headerlink" title="二.WebRequestInterceptor 接口"></a>二.WebRequestInterceptor 接口</h2><p>在WebRequestInterceptor接口中也定义了 3 个方法，同HandlerInterceptor接口完全相同，也是通过复写这 3 个方法来用户的请求进行拦截处理的。而且这 3 个方法都传递了同一个参数 WebRequest，这个 WebRequest 是 Spring 中定义的一个接口，它里面的方法定义跟 HttpServletRequest 类似，在WebRequestInterceptor中对 WebRequest 进行的所有操作都将同步到 HttpServletRequest 中，然后在当前请求中依次传递。<br>在 Spring 框架之中，还提供了一个和WebRequestInterceptor接口长的很像的抽象类，那就是：WebRequestInterceptorAdapter，其实现了AsyncHandlerInterceptor接口，并在内部调用了WebRequestInterceptor接口。<br>接下来，咱们主要讲一下WebRequestInterceptor接口的 3 个函数：</p><ol><li>preHandle(WebRequest request)方法，该方法在请求处理之前进行调用，即在 Controller 中的方法调用之前被调用。这个方法跟 HandlerInterceptor 中的 preHandle 不同，主要区别在于该方法的返回值是void 类型的，也就是没有返回值，因此我们主要用它来进行资源的准备工作。在这里，进一步说说 setAttribute 方法的第三个参数 scope ，该参数是一个Integer 类型的。在 WebRequest 的父层接口 RequestAttributes 中对它定义了三个常量，分别为： </li></ol><ul><li>SCOPE_REQUEST ，它的值是 0，表示只有在 request 中可以访问。</li><li>SCOPE_SESSION，它的值是1，如果环境允许的话，它表示的是一个局部的隔离的 session，否则就代表普通的 session，并且在该 session 范围内可以访问。</li><li>SCOPE_GLOBAL_SESSION，它的值是 2，如果环境允许的话，它表示的是一个全局共享的 session，否则就代表普通的 session，并且在该 session 范围内可以访问。</li></ul><ol start="2"><li>postHandle(WebRequest request, ModelMap model)方法，该方法在请求处理之后，也就是在 Controller 中的方法调用之后被调用，但是会在视图返回被渲染之前被调用，所以可以在这个方法里面通过改变数据模型 ModelMap 来改变数据的展示。该方法有两个参数，WebRequest 对象是用于传递整个请求数据的，比如在 preHandle 中准备的数据都可以通过 WebRequest 来传递和访问；ModelMap 就是 Controller 处理之后返回的 Model 对象，咱们可以通过改变它的属性来改变返回的 Model 模型。</li><li>afterCompletion(WebRequest request, Exception ex)方法，该方法会在整个请求处理完成，也就是在视图返回并被渲染之后执行。因此可以在该方法中进行资源的释放操作。而 WebRequest 参数就可以把咱们在 preHandle 中准备的资源传递到这里进行释放。Exception 参数表示的是当前请求的异常对象，如果在 Controller 中抛出的异常已经被 Spring 的异常处理器给处理了的话，那么这个异常对象就是是 null.<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.ui.ModelMap;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.context.request.WebRequest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.context.request.WebRequestInterceptor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WrongCodeInterceptor</span> <span class="keyword">implements</span> <span class="title">WebRequestInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preHandle</span><span class="params">(WebRequest request)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"WrongCodeInterceptor, preHandle......"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postHandle</span><span class="params">(WebRequest request, ModelMap model)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"WrongCodeInterceptor, postHandle......"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterCompletion</span><span class="params">(WebRequest request, Exception ex)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"WrongCodeInterceptor, afterCompletion......"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="拦截器的配置"><a href="#拦截器的配置" class="headerlink" title="拦截器的配置"></a>拦截器的配置</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:interceptors</span>&gt;</span>  </span><br><span class="line">    <span class="comment">&lt;!-- 使用bean定义一个Interceptor，直接定义在mvc:interceptors根下面的Interceptor将拦截所有的请求 --&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"com.host.app.web.interceptor.AllInterceptor"</span>/&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:interceptor</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">mvc:mapping</span> <span class="attr">path</span>=<span class="string">"/test/number.do"</span>/&gt;</span>  </span><br><span class="line">        <span class="comment">&lt;!-- 定义在mvc:interceptor下面的表示是对特定的请求才进行拦截的 --&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"com.host.app.web.interceptor.LoginInterceptor"</span>/&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">mvc:interceptor</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">mvc:interceptors</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="实例1：SpringMVC拦截器实现登录认证"><a href="#实例1：SpringMVC拦截器实现登录认证" class="headerlink" title="实例1：SpringMVC拦截器实现登录认证"></a>实例1：SpringMVC拦截器实现登录认证</h2><p>控制器<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 登录认证的控制器 </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="meta">@Controller</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginControl</span> </span>&#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 登录 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> session </span></span><br><span class="line"><span class="comment">     *          HttpSession </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> username </span></span><br><span class="line"><span class="comment">     *          用户名 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> password </span></span><br><span class="line"><span class="comment">     *          密码 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="meta">@RequestMapping</span>(value=<span class="string">"/login"</span>)  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">login</span><span class="params">(HttpSession session,String username,String password)</span> <span class="keyword">throws</span> Exception</span>&#123;        </span><br><span class="line">        <span class="comment">//在Session里保存信息  </span></span><br><span class="line">        session.setAttribute(<span class="string">"username"</span>, username);  </span><br><span class="line">        <span class="comment">//重定向  </span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"redirect:hello.action"</span>;   </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 退出系统 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> session </span></span><br><span class="line"><span class="comment">     *          Session </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="meta">@RequestMapping</span>(value=<span class="string">"/logout"</span>)  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">logout</span><span class="params">(HttpSession session)</span> <span class="keyword">throws</span> Exception</span>&#123;  </span><br><span class="line">        <span class="comment">//清除Session  </span></span><br><span class="line">        session.invalidate();  </span><br><span class="line">          </span><br><span class="line">        <span class="keyword">return</span> <span class="string">"redirect:hello.action"</span>;  </span><br><span class="line">    &#125;       </span><br><span class="line">&#125; </span><br><span class="line">```   </span><br><span class="line">拦截器：</span><br><span class="line">```java</span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 登录认证的拦截器 </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginInterceptor</span> <span class="keyword">implements</span> <span class="title">HandlerInterceptor</span></span>&#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * Handler执行完成之后调用这个方法 </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterCompletion</span><span class="params">(HttpServletRequest request,  </span></span></span><br><span class="line"><span class="function"><span class="params">            HttpServletResponse response, Object handler, Exception exc)</span>  </span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> Exception </span>&#123;  </span><br><span class="line">          </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * Handler执行之后，ModelAndView返回之前调用这个方法 </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response,  </span></span></span><br><span class="line"><span class="function"><span class="params">            Object handler, ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception </span>&#123;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * Handler执行之前调用这个方法 </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response,  </span></span></span><br><span class="line"><span class="function"><span class="params">            Object handler)</span> <span class="keyword">throws</span> Exception </span>&#123;  </span><br><span class="line">        <span class="comment">//获取请求的URL  </span></span><br><span class="line">        String url = request.getRequestURI();  </span><br><span class="line">        <span class="comment">//URL:login.jsp是公开的;这个demo是除了login.jsp是可以公开访问的，其它的URL都进行拦截控制  </span></span><br><span class="line">        <span class="keyword">if</span>(url.indexOf(<span class="string">"login.action"</span>)&gt;=<span class="number">0</span>)&#123;  </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="comment">//获取Session  </span></span><br><span class="line">        HttpSession session = request.getSession();  </span><br><span class="line">        String username = (String)session.getAttribute(<span class="string">"username"</span>);  </span><br><span class="line">          </span><br><span class="line">        <span class="keyword">if</span>(username != <span class="keyword">null</span>)&#123;  </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="comment">//不符合条件的，跳转到登录界面  </span></span><br><span class="line">        request.getRequestDispatcher(<span class="string">"/WEB-INF/jsp/login.jsp"</span>).forward(request, response);  </span><br><span class="line">          </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;  </span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在spring的配置文件中配置这个拦截器</p><pre><code class="xml"><span class="comment">&lt;!-- 拦截器 --&gt;</span>          <span class="tag">&lt;<span class="name">mvc:interceptors</span>&gt;</span>              <span class="comment">&lt;!-- 多个拦截器，顺序执行 --&gt;</span>              <span class="tag">&lt;<span class="name">mvc:interceptor</span>&gt;</span>                  <span class="tag">&lt;<span class="name">mvc:mapping</span> <span class="attr">path</span>=<span class="string">"/**"</span>/&gt;</span>                  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"com.mvc.interceptor.LoginInterceptor"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span>              <span class="tag">&lt;/<span class="name">mvc:interceptor</span>&gt;</span>          <span class="tag">&lt;/<span class="name">mvc:interceptors</span>&gt;</span></code></pre><p>此外，也可在postHandle和afterCompletion中定义拦截逻辑，其中postHandle处理尚未渲染的ModelAndView数据，afterCompletion中处理后置的一些验证等操作.</p><h2 id="实例2-性能监控"><a href="#实例2-性能监控" class="headerlink" title="实例2 性能监控"></a>实例2 性能监控</h2><p>如记录一下请求的处理时间，得到一些慢请求（如处理时间超过500毫秒），从而进行性能改进，一般的反向代理服务器如apache都具有这个功能，但此处我们演示一下使用拦截器怎么实现。<br>实现分析：<br>1、在进入处理器之前记录开始时间，即在拦截器的preHandle记录开始时间；<br>2、在结束请求处理之后记录结束时间，即在拦截器的afterCompletion记录结束实现，并用结束时间-开始时间得到这次请求的处理时间。<br>问题：<br>我们的拦截器是单例，因此不管用户请求多少次都只有一个拦截器实现，即线程不安全，那我们应该怎么记录时间呢？<br>解决方案是使用ThreadLocal，它是线程绑定的变量，提供线程局部变量（一个线程一个ThreadLocal，A线程的ThreadLocal只能看到A线程的ThreadLocal，不能看到B线程的ThreadLocal）。</p><pre><code class="java"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StopWatchHandlerInterceptor</span> <span class="keyword">extends</span> <span class="title">HandlerInterceptorAdapter</span> </span>{      <span class="keyword">private</span> NamedThreadLocal&lt;Long&gt;  startTimeThreadLocal =   <span class="keyword">new</span> NamedThreadLocal&lt;Long&gt;(<span class="string">"StopWatch-StartTime"</span>);      <span class="meta">@Override</span>      <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response,   </span></span><span class="function"><span class="params">Object handler)</span> <span class="keyword">throws</span> Exception </span>{          <span class="keyword">long</span> beginTime = System.currentTimeMillis();<span class="comment">//1、开始时间  </span>        startTimeThreadLocal.set(beginTime);<span class="comment">//线程绑定变量（该数据只有当前请求的线程可见）  </span>        <span class="keyword">return</span> <span class="keyword">true</span>;<span class="comment">//继续流程  </span>    }      <span class="meta">@Override</span>      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response,   </span></span><span class="function"><span class="params">Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception </span>{          <span class="keyword">long</span> endTime = System.currentTimeMillis();<span class="comment">//2、结束时间  </span>        <span class="keyword">long</span> beginTime = startTimeThreadLocal.get();<span class="comment">//得到线程绑定的局部变量（开始时间）  </span>        <span class="keyword">long</span> consumeTime = endTime - beginTime;<span class="comment">//3、消耗的时间  </span>        <span class="keyword">if</span>(consumeTime &gt; <span class="number">500</span>) {<span class="comment">//此处认为处理时间超过500毫秒的请求为慢请求  </span>            <span class="comment">//TODO 记录到日志文件  </span>            System.out.println(  String.format(<span class="string">"%s consume %d millis"</span>, request.getRequestURI(), consumeTime));          }              }  }</code></pre><p>NamedThreadLocal：Spring提供的一个命名的ThreadLocal实现。<br>在测试时需要把stopWatchHandlerInterceptor放在拦截器链的第一个，这样得到的时间才是比较准确的。</p>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note success&quot;&gt;&lt;p&gt;Spring MVC中的拦截器（Interceptor）类似于Servlet中的过滤器（Filter），它主要用于拦截用户请求并作相应的处理。通过拦截器可以进行权限验证、记录请求信息的日志、判断用户是否登录等。 &lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="spring" scheme="www.xiaoyb.cc/categories/spring/"/>
    
    
      <category term="spring" scheme="www.xiaoyb.cc/tags/spring/"/>
    
      <category term="拦截器" scheme="www.xiaoyb.cc/tags/%E6%8B%A6%E6%88%AA%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>java源码--ArrayDeque</title>
    <link href="www.xiaoyb.cc/2017/08/14/java%E6%BA%90%E7%A0%81-ArrayDeque/"/>
    <id>www.xiaoyb.cc/2017/08/14/java源码-ArrayDeque/</id>
    <published>2017-08-14T05:52:23.000Z</published>
    <updated>2017-08-24T08:40:53.521Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>Deque意为双端队列，ArrayDeque显然是基于数组实现的双端队列，而且作为双端队列时，效率比LinkList高。而且其特性使它还可以当做栈来使用，效率比Stack高。<br>ArrayDeque是非线程安全的（not thread-safe），当多个线程同时使用的时候，需要程序员手动同步；另外，该容器不允许放入null元素。<br><img src="http://i.imgur.com/SRn9K5h.png" alt=""><br><a id="more"></a><br>继承体系：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayDeque</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractCollection</span>&lt;<span class="title">E</span>&gt;  </span></span><br><span class="line"><span class="class">                           <span class="keyword">implements</span> <span class="title">Deque</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure></p><h1 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h1><p>从内部存储上，可以看到内部只有一个数组<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 底层用数组存储元素  </span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">transient</span> E[] elements;  </span><br><span class="line"> <span class="comment">// 队列的头部元素索引（即将pop出的一个）  </span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> head;  </span><br><span class="line"> <span class="comment">// 队列下一个要添加的元素索引 ，注意是下一个，不是最后一个元素</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> tail;  </span><br><span class="line"> <span class="comment">// 最小的初始化容量大小，需要为2的n次幂  </span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_INITIAL_CAPACITY = <span class="number">8</span>;</span><br></pre></td></tr></table></figure></p><p><img src="http://i.imgur.com/sxw4t8w.png" alt=""><br>上图中我们看到，head指向首端第一个有效元素，tail指向尾端第一个可以插入元素的空位，不是当前数组的元素位置。<br>因为是循环数组，所以head不一定总等于0，tail也不一定总是比head大。</p><h1 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 默认构造方法，数组的初始容量为16 </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayDeque</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    elements = (E[]) <span class="keyword">new</span> Object[<span class="number">16</span>];  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 使用一个指定的初始容量构造一个ArrayDeque,但是最终分配的容量并不是numElements，初始容量是大于指定numElements的最小的2的n次幂 </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayDeque</span><span class="params">( <span class="keyword">int</span> numElements)</span> </span>&#123;  </span><br><span class="line">    allocateElements(numElements);  </span><br><span class="line">&#125;  </span><br><span class="line">   </span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 构造一个指定Collection集合参数的ArrayDeque </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayDeque</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;  </span><br><span class="line">    allocateElements(c.size());  </span><br><span class="line">    addAll(c);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>allocateElements()是什么东西呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">    * 分配合适容量大小的数组，确保初始容量是大于指定numElements的最小的2的n次幂 </span></span><br><span class="line"><span class="comment">    */</span>  </span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">allocateElements</span><span class="params">(<span class="keyword">int</span> numElements)</span> </span>&#123;  </span><br><span class="line">       <span class="keyword">int</span> initialCapacity = MIN_INITIAL_CAPACITY;  <span class="comment">//初始容量为8</span></span><br><span class="line">       <span class="comment">// 找到大于指定容量的最小的2的n次幂  </span></span><br><span class="line">       <span class="comment">// Find the best power of two to hold elements.  </span></span><br><span class="line">       <span class="comment">// Tests "&lt;=" because arrays aren't kept full.  </span></span><br><span class="line">       <span class="comment">// 如果指定的容量小于初始容量8，则执行一下if中的逻辑操作  </span></span><br><span class="line">       <span class="keyword">if</span> (numElements &gt;= initialCapacity) &#123;  </span><br><span class="line">           initialCapacity = numElements;  </span><br><span class="line">           initialCapacity |= (initialCapacity &gt;&gt;&gt;  <span class="number">1</span>);  </span><br><span class="line">           initialCapacity |= (initialCapacity &gt;&gt;&gt;  <span class="number">2</span>);  </span><br><span class="line">           initialCapacity |= (initialCapacity &gt;&gt;&gt;  <span class="number">4</span>);  </span><br><span class="line">           initialCapacity |= (initialCapacity &gt;&gt;&gt;  <span class="number">8</span>);  </span><br><span class="line">           initialCapacity |= (initialCapacity &gt;&gt;&gt; <span class="number">16</span>);  </span><br><span class="line">           initialCapacity++;  </span><br><span class="line">  </span><br><span class="line">           <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)   <span class="comment">// Too many elements, must back off  </span></span><br><span class="line">               initialCapacity &gt;&gt;&gt;= <span class="number">1</span>; <span class="comment">// Good luck allocating 2 ^ 30 elements  </span></span><br><span class="line">       &#125;  </span><br><span class="line">      elements = (E[]) <span class="keyword">new</span> Object[initialCapacity];  </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>此方法是给数组分配初始容量，初始容量并不是numElements，而是大于指定长度的最小的2的幂正数<br>所以ArrayDeque的容量一定是2的幂整数.至于这是为什么，应该是计算机内存分配的关系吧。2的幂次方页空间分配的更快。（个人猜测）</p><h1 id="重要方法"><a href="#重要方法" class="headerlink" title="重要方法"></a>重要方法</h1><h2 id="入队（添加元素到队尾）"><a href="#入队（添加元素到队尾）" class="headerlink" title="入队（添加元素到队尾）"></a>入队（添加元素到队尾）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 增加一个元素，如果队列已满，则抛出一个IIIegaISlabEepeplian异常 </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;  </span><br><span class="line">        <span class="comment">// 调用addLast方法，将元素添加到队尾  </span></span><br><span class="line">        addLast(e);  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">* 把元素填入到队列前端.即在head的前面添加元素 </span><br><span class="line">*/  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFirst</span><span class="params">(E e)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>)  <span class="comment">//允许插入空值</span></span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();  </span><br><span class="line">   elements[head = (head - <span class="number">1</span>) &amp; (elements.length - <span class="number">1</span>)] = e;  </span><br><span class="line">   <span class="keyword">if</span> (head == tail)  <span class="comment">//表示队列已经满了</span></span><br><span class="line">       doubleCapacity();  <span class="comment">//扩充容量</span></span><br><span class="line">&#125;</span><br><span class="line">      <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 将元素添加到队尾 </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addLast</span><span class="params">(E e)</span> </span>&#123;  </span><br><span class="line">       <span class="comment">// 如果元素为null，咋抛出空指针异常  </span></span><br><span class="line">       <span class="keyword">if</span> (e == <span class="keyword">null</span>)  </span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();  </span><br><span class="line">       <span class="comment">// 将元素e放到数组的tail位置  </span></span><br><span class="line">        elements[tail] = e;  </span><br><span class="line">        <span class="comment">// 判断tail和head是否相等，如果相等则对数组进行扩容  </span></span><br><span class="line">        <span class="keyword">if</span> ( (tail = (tail + <span class="number">1</span>) &amp; ( elements.length - <span class="number">1</span>)) == head)  </span><br><span class="line">            <span class="comment">// 进行两倍扩容  </span></span><br><span class="line">           doubleCapacity();  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 添加一个元素 </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;  </span><br><span class="line">        <span class="comment">// 调用offerLast方法，将元素添加到队尾  </span></span><br><span class="line">        <span class="keyword">return</span> offerLast(e);  </span><br><span class="line">    &#125;  </span><br><span class="line">     <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * Inserts the specified element at the front of this deque. </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offerFirst</span><span class="params">(E e)</span> </span>&#123;  </span><br><span class="line">        addFirst(e);  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;  </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 在队尾添加一个元素 </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offerLast</span><span class="params">(E e)</span> </span>&#123;  </span><br><span class="line">        <span class="comment">// 调用addLast方法，将元素添加到队尾  </span></span><br><span class="line">        addLast(e);  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="addFirst"><a href="#addFirst" class="headerlink" title="addFirst()"></a>addFirst()</h2><p>addFirst(E e)的作用是在Deque的首端插入元素，也就是在head的前面插入元素，在空间足够且下标没有越界的情况下，只需要将elements[–head] = e即可。<br><img src="http://i.imgur.com/6oMsBPQ.png" alt=""><br>实际需要考虑：1.空间是否够用 2.下标是否越界的问题。上图中，如果head为0之后接着调用addFirst()，虽然空余空间还够用，但head为-1，下标越界了。下列代码很好的解决了这两个问题.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">* 把元素填入到队列前端.即在head的前面添加元素 </span><br><span class="line">*/  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFirst</span><span class="params">(E e)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>)  <span class="comment">//允许插入空值</span></span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();  </span><br><span class="line">   elements[head = (head - <span class="number">1</span>) &amp; (elements.length - <span class="number">1</span>)] = e;  </span><br><span class="line">   <span class="keyword">if</span> (head == tail)  <span class="comment">//表示队列已经满了</span></span><br><span class="line">       doubleCapacity();  <span class="comment">//扩充容量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码我们看到，空间问题是在插入之后解决的，因为tail总是指向下一个可插入的空位，也就意味着elements数组至少有一个空位，所以插入元素的时候不用考虑空间问题。<br>下标越界的处理解决起来非常简单，head = (head - 1) &amp; (elements.length - 1)就可以了，这段代码相当于取余，同时解决了head为负值的情况。因为elements.length必需是2的指数倍，elements - 1就是二进制低位全1，跟head - 1相与之后就起到了取模的作用，如果head - 1为负数（其实只可能是-1），则相当于对其取相对于elements.length的补码。<br>比如说，如果elements.length为8，则(elements.length - 1)为7，二进制为0111，对于负数-1，与7相与，结果为7，对于正数8，与7相与，结果为0，都能达到循环数组中找下一个正确位置的目的。<br>对于取与操作而言，有下面的结论：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">记mod = elements.length = 2^k, a为[-1,module+1]之间的一个整数，那么有：  </span><br><span class="line">  </span><br><span class="line">a == -1:  </span><br><span class="line">a &amp; (mod-1) == mod - 1;  </span><br><span class="line">0 &lt;= a &lt; mod:  </span><br><span class="line">a &amp; (mod - 1) == a  </span><br><span class="line">a == mod:  </span><br><span class="line">a &amp; (mod - 1) == 0</span><br></pre></td></tr></table></figure></p><p>下面再说说扩容函数doubleCapacity()，其逻辑是申请一个更大的数组（原数组的两倍），然后将原数组复制过去。过程如下图所示：<br> <img src="http://i.imgur.com/TXjfxNm.png" alt=""><br>图中我们看到，复制分两次进行，第一次复制head右边的元素，第二次复制head左边的元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/** 将队列的容量变成二倍</span></span><br><span class="line"><span class="comment"> * Doubles the capacity of this deque.  Call only when full, i.e., </span></span><br><span class="line"><span class="comment"> * when head and tail have wrapped around to become equal. </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doubleCapacity</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">assert</span> head == tail;  </span><br><span class="line">    <span class="keyword">int</span> p = head;  </span><br><span class="line">    <span class="keyword">int</span> n = elements.length;  </span><br><span class="line">    <span class="keyword">int</span> r = n - p; <span class="comment">// number of elements to the right of p  </span></span><br><span class="line">    <span class="keyword">int</span> newCapacity = n &lt;&lt; <span class="number">1</span>;  </span><br><span class="line">    <span class="keyword">if</span> (newCapacity &lt; <span class="number">0</span>)  </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Sorry, deque too big"</span>);  </span><br><span class="line">   Object[] a = <span class="keyword">new</span> Object[newCapacity];  </span><br><span class="line">    System.arraycopy(elements, p, a, <span class="number">0</span>, r);  </span><br><span class="line">    System.arraycopy(elements, <span class="number">0</span>, a, r, p);  </span><br><span class="line">    elements = a;  </span><br><span class="line">    head = <span class="number">0</span>;  </span><br><span class="line">   tail = n;</span><br></pre></td></tr></table></figure><h2 id="addLast"><a href="#addLast" class="headerlink" title="addLast()"></a>addLast()</h2><p>addLast(E e)的作用是在Deque的尾端插入元素，也就是在tail的位置插入元素，由于tail总是指向下一个可以插入的空位，因此只需要elements[tail] = e;即可。插入完成后再检查空间，如果空间已经用光，则调用doubleCapacity()进行扩容。<br> <img src="http://i.imgur.com/OMfipDU.png" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/** </span></span><br><span class="line"><span class="comment">  * Inserts the specified element at the end of this deque. </span></span><br><span class="line"><span class="comment">  */</span>  </span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addLast</span><span class="params">(E e)</span> </span>&#123;  </span><br><span class="line">     <span class="keyword">if</span> (e == <span class="keyword">null</span>)  </span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();  </span><br><span class="line">     elements[tail] = e;  </span><br><span class="line">     <span class="keyword">if</span> ( (tail = (tail + <span class="number">1</span>) &amp; (elements.length - <span class="number">1</span>)) == head) <span class="comment">//在tail位置后面加入元素 </span></span><br><span class="line">         doubleCapacity();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下标越界处理方式和addFirst()相同</p><h2 id="offerFirst-offerLast"><a href="#offerFirst-offerLast" class="headerlink" title="offerFirst(),offerLast()"></a>offerFirst(),offerLast()</h2><p>这两个方法从源码看的很清楚，与addxx()方法的区别就是:add()方法插入失败(插入一个null)会抛出异常，而offer()方法至于插入成功时才会返回true，可用于某些判断。</p><h2 id="出队（移除并返回队头元素）"><a href="#出队（移除并返回队头元素）" class="headerlink" title="出队（移除并返回队头元素）"></a>出队（移除并返回队头元素）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/** </span></span><br><span class="line"><span class="comment">   * 移除并返回队列头部的元素，如果队列为空，则抛出一个NoSuchElementException异常 </span></span><br><span class="line"><span class="comment">   */</span>  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">      <span class="comment">// 调用removeFirst方法，移除队头的元素  </span></span><br><span class="line">     <span class="keyword">return</span> removeFirst();  </span><br><span class="line">  &#125;  </span><br><span class="line"> </span><br><span class="line">  <span class="comment">/** </span></span><br><span class="line"><span class="comment">   * <span class="doctag">@throws</span> NoSuchElementException &#123;<span class="doctag">@inheritDoc</span>&#125; </span></span><br><span class="line"><span class="comment">   */</span>  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> E <span class="title">removeFirst</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">      <span class="comment">// 调用pollFirst方法，移除并返回队头的元素  </span></span><br><span class="line">      E x = pollFirst();  </span><br><span class="line">      <span class="comment">// 如果队列为空，则抛出NoSuchElementException异常  </span></span><br><span class="line">      <span class="keyword">if</span> (x == <span class="keyword">null</span>)  </span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();  </span><br><span class="line">      <span class="keyword">return</span> x;  </span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="comment">/** </span></span><br><span class="line"><span class="comment">  * <span class="doctag">@throws</span> NoSuchElementException &#123;<span class="doctag">@inheritDoc</span>&#125; </span></span><br><span class="line"><span class="comment">  */</span>  </span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">removeLast</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">     E x = pollLast();  </span><br><span class="line">    <span class="keyword">if</span> (x == <span class="keyword">null</span>)  </span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();  </span><br><span class="line">     <span class="keyword">return</span> x;  </span><br><span class="line"> &#125;     </span><br><span class="line">  <span class="comment">/** </span></span><br><span class="line"><span class="comment">   * 移除并返问队列头部的元素，如果队列为空，则返回null </span></span><br><span class="line"><span class="comment">   */</span>  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">      <span class="comment">// 调用pollFirst方法，移除并返回队头的元素  </span></span><br><span class="line">      <span class="keyword">return</span> pollFirst();  </span><br><span class="line">  &#125;  </span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> E <span class="title">pollFirst</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">     <span class="keyword">int</span> h = head ;  </span><br><span class="line">      <span class="comment">// 取出数组队头位置的元素  </span></span><br><span class="line">     E result = elements[h]; <span class="comment">// Element is null if deque empty  </span></span><br><span class="line">      <span class="comment">// 如果数组队头位置没有元素，则返回null值  </span></span><br><span class="line">      <span class="keyword">if</span> (result == <span class="keyword">null</span>)  </span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">null</span>;  </span><br><span class="line">      <span class="comment">// 将数组队头位置置空，也就是删除元素  </span></span><br><span class="line">     elements[h] = <span class="keyword">null</span>;     <span class="comment">// Must null out slot  </span></span><br><span class="line">      <span class="comment">// 将head指针往前移动一个位置  </span></span><br><span class="line">      head = (h + <span class="number">1</span>) &amp; (elements .length - <span class="number">1</span>);  </span><br><span class="line">      <span class="comment">// 将队头元素返回  </span></span><br><span class="line">      <span class="keyword">return</span> result;  </span><br><span class="line">  &#125;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">pollLast</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> t = (tail - <span class="number">1</span>) &amp; (elements.length - <span class="number">1</span>);  <span class="comment">//因为tail总是指向下一个队列元素，所以pollLast时候，实际取得是tail-1位置的元素</span></span><br><span class="line">     <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)  </span><br><span class="line">     E result = (E) elements[t];  </span><br><span class="line">     <span class="keyword">if</span> (result == <span class="keyword">null</span>)  <span class="comment">//null值意味着deque为空</span></span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">null</span>;  </span><br><span class="line">     elements[t] = <span class="keyword">null</span>;  </span><br><span class="line">     tail = t;  </span><br><span class="line">     <span class="keyword">return</span> result;  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>可以看到，remove方法和poll方法的区别是：如果没有出队元素(null)，remove方法抛出异常，而poll方法返回null;</p><h2 id="返回队列元素-不出队"><a href="#返回队列元素-不出队" class="headerlink" title="返回队列元素(不出队)"></a>返回队列元素(不出队)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     *  返回队列头部的元素，如果队列为空，则抛出一个NoSuchElementException异常 </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">element</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="comment">// 调用getFirst方法，获取队头的元素  </span></span><br><span class="line">        <span class="keyword">return</span> getFirst();  </span><br><span class="line">    &#125;  </span><br><span class="line">   </span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NoSuchElementException &#123;<span class="doctag">@inheritDoc</span>&#125; </span></span><br><span class="line"><span class="comment">.     */</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">getFirst</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="comment">// 取得数组head位置的元素  </span></span><br><span class="line">        E x = elements[head ];  </span><br><span class="line">        <span class="comment">// 如果数组head位置的元素为null，则抛出异常  </span></span><br><span class="line">        <span class="keyword">if</span> (x == <span class="keyword">null</span>)  </span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();  </span><br><span class="line">        <span class="keyword">return</span> x;  </span><br><span class="line">    &#125;  </span><br><span class="line">     <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NoSuchElementException &#123;<span class="doctag">@inheritDoc</span>&#125; </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">getLast</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)  </span><br><span class="line">        E result = (E) elements[(tail - <span class="number">1</span>) &amp; (elements.length - <span class="number">1</span>)];  </span><br><span class="line">        <span class="keyword">if</span> (result == <span class="keyword">null</span>)  </span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();  </span><br><span class="line">        <span class="keyword">return</span> result;  </span><br><span class="line">    &#125;  </span><br><span class="line">   </span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 返回队列头部的元素，如果队列为空，则返回null </span></span><br><span class="line"><span class="comment">     .     */</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">peek</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="comment">// 调用peekFirst方法，获取队头的元素  </span></span><br><span class="line">        <span class="keyword">return</span> peekFirst();  </span><br><span class="line">    &#125;  </span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">peekFirst</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">       <span class="comment">// 取得数组head位置的元素并返回  </span></span><br><span class="line">        <span class="keyword">return</span> elements [head]; <span class="comment">// elements[head] is null if deque empty  </span></span><br><span class="line">    &#125;  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> E <span class="title">peekLast</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">      <span class="keyword">return</span> (E) elements[(tail - <span class="number">1</span>) &amp; (elements.length - <span class="number">1</span>)];  </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>get()和peek()方法的区别在于：get()方法取到的元素是null(队列为空)时，抛出异常，而peek()方法返回null;</p><h2 id="push-pop"><a href="#push-pop" class="headerlink" title="push(),pop()"></a>push(),pop()</h2><p>显而易见的操作，把ArrayDeque当做堆栈使用时，push()即为在head处插入元素，pop（）即为删除head处元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(E e)</span> </span>&#123;  </span><br><span class="line">        addFirst(e);  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">pop</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> removeFirst();  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">    * Returns the number of elements in this deque. </span></span><br><span class="line"><span class="comment">    */</span>  </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">       <span class="keyword">return</span> (tail - head) &amp; (elements.length - <span class="number">1</span>);  </span><br><span class="line">   &#125;  </span><br><span class="line">     <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * Returns an array containing all of the elements in this deque </span></span><br><span class="line"><span class="comment">     * in proper sequence (from first to last element). </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="keyword">public</span> Object[] toArray() &#123;  </span><br><span class="line">        <span class="keyword">return</span> copyElements(<span class="keyword">new</span> Object[size()]);  </span><br><span class="line">   &#125;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;<span class="comment">//清空操作    </span></span><br><span class="line">    <span class="keyword">int</span> h = head;    </span><br><span class="line">    <span class="keyword">int</span> t = tail;    </span><br><span class="line">   <span class="keyword">if</span> (h != t) &#123; <span class="comment">// head != tail 表示队列元素 不为空    </span></span><br><span class="line">       head = tail = <span class="number">0</span>;<span class="comment">//设置head 和 tail 初始状态    </span></span><br><span class="line">        <span class="keyword">int</span> i = h;    </span><br><span class="line">        <span class="keyword">int</span> mask = elements.length - <span class="number">1</span>;    </span><br><span class="line">        <span class="keyword">do</span> &#123;    </span><br><span class="line">            elements[i] = <span class="keyword">null</span>;<span class="comment">//配合循环将所有元素设置为null    </span></span><br><span class="line">           i = (i + <span class="number">1</span>) &amp; mask;    </span><br><span class="line">        &#125; <span class="keyword">while</span> (i != t);    </span><br><span class="line">    &#125;    </span><br><span class="line">&#125;    </span><br><span class="line"><span class="comment">//遍历集合，正向遍历,从head -- tail</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> DeqIterator();  </span><br><span class="line">   &#125;  </span><br><span class="line"><span class="comment">//反向遍历</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">descendingIterator</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> DescendingIterator();  </span><br><span class="line">   &#125;  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;<span class="comment">//判断队列是否包含该元素    </span></span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>)    </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;    </span><br><span class="line">    <span class="keyword">int</span> mask = elements.length - <span class="number">1</span>;    </span><br><span class="line">    <span class="keyword">int</span> i = head;    </span><br><span class="line">    E x;    </span><br><span class="line">    <span class="keyword">while</span> ( (x = elements[i]) != <span class="keyword">null</span>) &#123;<span class="comment">//从head元素向后猪哥判断,是否equals    </span></span><br><span class="line">        <span class="keyword">if</span> (o.equals(x))    </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;    </span><br><span class="line">        i = (i + <span class="number">1</span>) &amp; mask;    </span><br><span class="line">   &#125;    </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;    </span><br><span class="line">&#125;    </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;<span class="comment">//获取队列元素个数,(tail - head) &amp; (elements.length - 1)保证大小在有效范围内。    </span></span><br><span class="line">        <span class="keyword">return</span> (tail - head) &amp; (elements.length - <span class="number">1</span>);    </span><br><span class="line">    &#125;    </span><br><span class="line">    </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;<span class="comment">//入队操作,tail+=1;出队操作head+=1;当一直出队元素的时候,head一直+，会==tail,此时head==tail都指向null元素。    </span></span><br><span class="line">        <span class="keyword">return</span> head == tail;    </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;Deque意为双端队列，ArrayDeque显然是基于数组实现的双端队列，而且作为双端队列时，效率比LinkList高。而且其特性使它还可以当做栈来使用，效率比Stack高。&lt;br&gt;ArrayDeque是非线程安全的（not thread-safe），当多个线程同时使用的时候，需要程序员手动同步；另外，该容器不允许放入null元素。&lt;br&gt;&lt;img src=&quot;http://i.imgur.com/SRn9K5h.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="java源码" scheme="www.xiaoyb.cc/categories/java%E6%BA%90%E7%A0%81/"/>
    
    
      <category term="java" scheme="www.xiaoyb.cc/tags/java/"/>
    
      <category term="ArrayDeque" scheme="www.xiaoyb.cc/tags/ArrayDeque/"/>
    
  </entry>
  
  <entry>
    <title>SpringMVC使用@ResponseBody返回json 中文乱码</title>
    <link href="www.xiaoyb.cc/2017/08/10/SpringMVC-%E4%BD%BF%E7%94%A8-ResponseBody%E8%BF%94%E5%9B%9Ejson-%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81/"/>
    <id>www.xiaoyb.cc/2017/08/10/SpringMVC-使用-ResponseBody返回json-中文乱码/</id>
    <published>2017-08-10T11:18:01.000Z</published>
    <updated>2017-08-24T08:40:53.514Z</updated>
    
    <content type="html"><![CDATA[<p>Spring中解析字符串的转换器默认编码居然是ISO-8859-1,如何处理utf-8中文字符<br>下面这都两个可以<br><a id="more"></a><br>方法一，使用（produces = “application/json; charset=utf-8”）：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(value=<span class="string">"/getUsersByPage"</span>,produces = <span class="string">"application/json; charset=utf-8"</span>)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getUsersByPage</span><span class="params">(String page,String rows,String text,HttpServletRequest request,HttpServletResponse response)</span></span>&#123;</span><br></pre></td></tr></table></figure></p><p>方法二，在spring-mvc.xml中添加：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 处理请求返回json字符串的中文乱码问题 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:annotation-driven</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mvc:message-converters</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.http.converter.StringHttpMessageConverter"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"supportedMediaTypes"</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">value</span>&gt;</span>application/json;charset=UTF-8<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">mvc:message-converters</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mvc:annotation-driven</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>以上两种方式经过验证都没有问题。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Spring中解析字符串的转换器默认编码居然是ISO-8859-1,如何处理utf-8中文字符&lt;br&gt;下面这都两个可以&lt;br&gt;
    
    </summary>
    
      <category term="spring" scheme="www.xiaoyb.cc/categories/spring/"/>
    
    
      <category term="springmvc" scheme="www.xiaoyb.cc/tags/springmvc/"/>
    
      <category term="json" scheme="www.xiaoyb.cc/tags/json/"/>
    
  </entry>
  
  <entry>
    <title>SpringMVC 使用HandlerMethodArgumentResolver自定义解析器实现请求数据绑定方法入参</title>
    <link href="www.xiaoyb.cc/2017/08/07/SpringMVC%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3%E5%92%8C%E6%8B%A6%E6%88%AA%E5%99%A8%E5%AE%9E%E7%8E%B0%E7%94%A8%E6%88%B7%E8%A1%8C%E4%B8%BA%E9%AA%8C%E8%AF%81/"/>
    <id>www.xiaoyb.cc/2017/08/07/SpringMVC自定义注解和拦截器实现用户行为验证/</id>
    <published>2017-08-07T10:59:23.000Z</published>
    <updated>2017-08-24T08:40:53.519Z</updated>
    
    <content type="html"><![CDATA[<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>首先，我们遇到的问题是，当我们需要在controller中频繁的从session中获取数据，比如向下面这样<br>在controller中需要从session中获取user对象，那么可能你会想到在controller里面或者其他类里面写这样的代码，然后在controller里面调用….<br><a id="more"></a><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">getLoginUser</span><span class="params">(HttpServletRequest request)</span> </span>&#123;  </span><br><span class="line">        HttpSession session = request.getSession();  </span><br><span class="line">        <span class="keyword">return</span> (User) session.getAttribute(<span class="string">"user"</span>);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>总感觉特别的不好…<br>现在如果我们看了下面介绍的HandlerMethodArgumentResolver自定义解析器实现的请求数据绑定方法入参，你就会看到像下面的代码只需要一个注解就能解决上面的问题↓<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/index"</span>)  </span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">index</span><span class="params">(@MyUser User user,ModelMap modelMap)</span></span>&#123;  </span><br><span class="line">    logger.info(user.getUsername()+<span class="string">"---------------------------"</span>);  </span><br><span class="line">    <span class="keyword">return</span> <span class="string">"login"</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="用HandlerMethodArgumentResolver解决"><a href="#用HandlerMethodArgumentResolver解决" class="headerlink" title="用HandlerMethodArgumentResolver解决"></a>用HandlerMethodArgumentResolver解决</h1><p>首先，我们需要知道一点的就是SpringMVC的工作流程，SpringMVC的DispatchServlet会根据请求来找到对应的HandlerMapping，最终spring会选择用RequestMappingHandlerMapping，然后根据RequestMappingHandlerMapping来获取HandlerMethod，然后来找支持的HandlerMethodArgumentResolver来处理对应controller的方法的入参。<br>首先，我们需要做的就是创建一个Annotation<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.PARAMETER)  </span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)  </span><br><span class="line"><span class="meta">@Documented</span> </span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyUser &#123;  </span><br><span class="line">  <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后我们要做的就是创建一个MyUserMethodArgumentResolver这个类来实现HandlerMethodArgumentResolver这个接口<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyUserMethodArgumentResolver</span> <span class="keyword">implements</span> <span class="title">HandlerMethodArgumentResolver</span> </span>&#123;  </span><br><span class="line"><span class="meta">@Override</span>  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supportsParameter</span><span class="params">(MethodParameter methodParameter)</span> </span>&#123;  </span><br><span class="line">      <span class="keyword">return</span> methodParameter.hasParameterAnnotation(ManyUser.class);  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="meta">@Override</span>  </span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">resolveArgument</span><span class="params">(MethodParameter methodParameter, ModelAndViewContainer   modelAndViewContainer, NativeWebRequest nativeWebRequest, WebDataBinderFactory webDataBinderFactory)</span> <span class="keyword">throws</span> Exception </span>&#123;  </span><br><span class="line"><span class="number">8</span>.         <span class="comment">//直接返回request域对象的user</span></span><br><span class="line"><span class="number">9</span>.        <span class="keyword">return</span> nativeWebRequest.getAttribute(<span class="string">"user"</span>, NativeWebRequest.SCOPE_REQUEST);;  </span><br><span class="line"><span class="number">10</span>.        <span class="comment">//或者这里你也可以直接返回自己创建的User对象 </span></span><br><span class="line"><span class="number">11</span>.        <span class="comment">/* </span></span><br><span class="line"><span class="comment">12.            User user = new User(); </span></span><br><span class="line"><span class="comment">13.            user.setUsername("yangpeng"); </span></span><br><span class="line"><span class="comment">14.            return user; </span></span><br><span class="line"><span class="comment">15.          */</span>  </span><br><span class="line"><span class="number">16</span>.         <span class="comment">/**自定义实现，比如参数是很多用户：如    custom?names=lyncc,fly,ted&amp;ids=1,2,3</span></span><br><span class="line"><span class="comment">17.   List&lt;User&gt; users = new ArrayList&lt;User&gt;();  </span></span><br><span class="line"><span class="comment">18.        String names = (String)webRequest.getParameter("names");  </span></span><br><span class="line"><span class="comment">19.        String ids = (String)webRequest.getParameter("ids");  </span></span><br><span class="line"><span class="comment">20.        if(null != names &amp;&amp; null != ids)&#123;  </span></span><br><span class="line"><span class="comment">21.            String[] nameStrs = names.trim().split(",");  </span></span><br><span class="line"><span class="comment">22.            String[] idStrs = ids.trim().split(",");  </span></span><br><span class="line"><span class="comment">23.            for(int i = 0;i&lt;nameStrs.length;i++)&#123;  </span></span><br><span class="line"><span class="comment">24.             User user = new User(Integer.parseInt(idStrs[i]), nameStrs[i]);</span></span><br><span class="line"><span class="comment">25.                users.add(user);  </span></span><br><span class="line"><span class="comment">26.            &#125;  </span></span><br><span class="line"><span class="comment">27.        &#125;  </span></span><br><span class="line"><span class="comment">28.        return users;  //返回list 例如注解式 <span class="doctag">@manyUser</span> List&lt;User&gt; users</span></span><br><span class="line"><span class="comment">29.    &#125;         </span></span><br><span class="line"><span class="comment">30.&#125;  &#125;</span></span><br></pre></td></tr></table></figure></p><p>Spring默认会注册多个HandlerMethodArgumentResolver来处理不同的请求，Spring会根据HandlerMethodArgumentResolver的supportsParameter()方法来判断是否支持处理当前请求。<br>第一个supportsParameter方法是判断这个MyUserMethodArgumentResolver是否支持传入的MethodParameter对象。<br>第二个resolveArgument方法是处理具体的需要绑定到方法入参，返回的对象就是需要绑定的对象，这里我是直接从session里面获取了一个user的对象直接返回，或者你也可以在这里直接创建一个User对象然后返回用于测试是一样的。<br>接下来就是在spring-mvc.xml中配置了</p><pre><code class="xml"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span>&gt;</span>     <span class="tag">&lt;<span class="name">mvc:argument-resolvers</span>&gt;</span>          <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"com.yp.code.common.bind.method.MyUserMethodArgumentResolver"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span>      <span class="tag">&lt;/<span class="name">mvc:argument-resolvers</span>&gt;</span>  <span class="tag">&lt;/<span class="name">mvc:annotation-driven</span>&gt;</span> </code></pre><p>最后就是使用创建的@MyUser这个Annotation来让SpringMVC自动的帮你绑定到Controller的方法里面了</p><pre><code class="java"><span class="meta">@RequestMapping</span>(<span class="string">"/index"</span>)  <span class="function"><span class="keyword">public</span> String <span class="title">index</span><span class="params">(@MyUser User user,ModelMap modelMap)</span></span>{      System.out.println(user.getUsername());      <span class="keyword">return</span> <span class="string">"login"</span>;  } </code></pre><p>这样就非常优雅的解决了上面的问题。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h1&gt;&lt;p&gt;首先，我们遇到的问题是，当我们需要在controller中频繁的从session中获取数据，比如向下面这样&lt;br&gt;在controller中需要从session中获取user对象，那么可能你会想到在controller里面或者其他类里面写这样的代码，然后在controller里面调用….&lt;br&gt;
    
    </summary>
    
      <category term="spring" scheme="www.xiaoyb.cc/categories/spring/"/>
    
    
      <category term="springmvc" scheme="www.xiaoyb.cc/tags/springmvc/"/>
    
      <category term="自定义参数解析器" scheme="www.xiaoyb.cc/tags/%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%90%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>用@ExceptionHandler，@ControllerAdvice 来进行异常处理</title>
    <link href="www.xiaoyb.cc/2017/08/05/%E7%94%A8-ExceptionHandler%EF%BC%8C-ControllerAdvice-%E6%9D%A5%E8%BF%9B%E8%A1%8C%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"/>
    <id>www.xiaoyb.cc/2017/08/05/用-ExceptionHandler，-ControllerAdvice-来进行异常处理/</id>
    <published>2017-08-05T11:03:25.000Z</published>
    <updated>2017-08-24T08:40:53.523Z</updated>
    
    <content type="html"><![CDATA[<p>有时候我们想统一处理一个Controller中抛出的异常怎么搞呢？<br>直接在Controller里面加上用@ExceptionHandler标注一个处理异常的方法像下面这样子，@ExceptionHandler只在当前controller里面有效。当前controller中所有抛出指定异常的方法。<br><a id="more"></a><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>.<span class="meta">@ExceptionHandler</span>(MissingServletRequestParameterException.class)  </span><br><span class="line"><span class="number">2</span>.<span class="meta">@ResponseStatus</span>(HttpStatus.BAD_REQUEST)  </span><br><span class="line"><span class="number">3</span>.<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processMethod</span><span class="params">(MissingServletRequestParameterException ex,HttpServletRequest request ,HttpServletResponse response)</span> <span class="keyword">throws</span> IOException </span>&#123;  </span><br><span class="line"><span class="number">4</span>.    System.out.println(<span class="string">"抛异常了！"</span>+ex.getLocalizedMessage());  </span><br><span class="line"><span class="number">5</span>.    logger.error(<span class="string">"抛异常了！"</span>+ex.getLocalizedMessage());  </span><br><span class="line"><span class="number">6</span>.    response.getWriter().printf(ex.getMessage());  </span><br><span class="line"><span class="number">7</span>.    response.flushBuffer();  </span><br><span class="line">```  </span><br><span class="line">这样，Controller里面的方法抛出了MissingServletRequestParameterException异常就会执行上面的这个方法来进行异常处理。</span><br><span class="line">像我下面的代码`</span><br><span class="line">```java</span><br><span class="line"><span class="number">1</span>.<span class="meta">@RequestMapping</span>(<span class="string">"/index"</span>)  </span><br><span class="line"><span class="number">2</span>.<span class="function"><span class="keyword">public</span> String <span class="title">index</span><span class="params">(@RequestParam String id,ModelMap modelMap)</span></span>&#123;  </span><br><span class="line"><span class="number">3</span>.    <span class="keyword">if</span> (id==<span class="keyword">null</span>)&#123;</span><br><span class="line"><span class="number">4</span>.   <span class="keyword">throw</span> <span class="keyword">new</span> MissingServletRequestParameterException();</span><br><span class="line"><span class="number">5</span>.&#125;</span><br><span class="line"><span class="number">6</span>.    <span class="keyword">return</span> <span class="string">"login"</span>;  </span><br><span class="line"><span class="number">7</span>.&#125; </span><br><span class="line">``` </span><br><span class="line">如果我没有传入id值，那么就会抛出MissingServletRequestParameterException的异常，就会被上面的异常处理方法处理。</span><br><span class="line">上面的<span class="meta">@ExceptionHandler</span>(MissingServletRequestParameterException.class)这个注解的value的值是一个Class[]类型的，这里的ExceptionClass是你自己指定的，你也可以指定多个需要处理的异常类型，比如这样</span><br><span class="line"><span class="meta">@ExceptionHandler</span>(value = &#123;MissingServletRequestParameterException.class,BindException.class&#125;)，这样就会处理多个异常了。</span><br><span class="line">另一种更加通用的方法时：</span><br><span class="line">首先定义这样一个统一异常处理类</span><br><span class="line">```java</span><br><span class="line">ExceptionController.Java</span><br><span class="line"><span class="number">1</span>.<span class="keyword">import</span> net.sf.json.JSONObject;  </span><br><span class="line"><span class="number">2</span>.<span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ExceptionController</span> </span>&#123;  </span><br><span class="line"><span class="number">3</span>.    <span class="meta">@ExceptionHandler</span>  </span><br><span class="line"><span class="number">4</span>.    <span class="keyword">public</span> <span class="meta">@ResponseBody</span> <span class="function">String <span class="title">exceptionProcess</span><span class="params">(HttpServletRequest request, HttpServletResponse  </span></span></span><br><span class="line"><span class="function"><span class="params"><span class="number">5.</span>            response, RuntimeException ex)</span> </span>&#123;  </span><br><span class="line"><span class="number">6</span>.        JSONObject json = <span class="keyword">new</span> JSONObject();  </span><br><span class="line"><span class="number">7</span>.        json.put(<span class="string">"isError"</span>, <span class="keyword">true</span>);  </span><br><span class="line"><span class="number">8</span>.        json.put(<span class="string">"msg"</span>, ex.getMessage());  </span><br><span class="line"><span class="number">9</span>.        <span class="keyword">return</span> json.toString();  </span><br><span class="line"><span class="number">10</span>.    &#125;  </span><br><span class="line"><span class="number">11</span>.&#125;</span><br></pre></td></tr></table></figure></p><p>在需要进行统一处理的类中继承这个class</p><pre><code class="java"><span class="number">1</span>.    <span class="keyword">import</span> net.sf.json.JSONObject;  <span class="number">2</span>.    <span class="meta">@RequestMapping</span>(<span class="string">"/auth/customer"</span>)  <span class="number">3</span>.    <span class="meta">@Controller</span>  <span class="number">4</span>.    <span class="meta">@LoginAuth</span>  <span class="number">5</span>.    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomerController</span> <span class="keyword">extends</span> <span class="title">ExceptionController</span> </span>{  <span class="number">6</span>.        <span class="meta">@Resource</span>  <span class="number">7</span>.        <span class="keyword">private</span> CustomerService customerService;  <span class="number">8</span>.          <span class="number">9</span>.        <span class="comment">/** </span><span class="comment">10.         *  </span><span class="comment">11.         * <span class="doctag">@param</span> page 第几页，从1开始 </span><span class="comment">12.         * <span class="doctag">@param</span> rows 每页多少记录的行数 </span><span class="comment">13.         * <span class="doctag">@return</span> JSON String </span><span class="comment">14.         */</span>  <span class="number">15</span>.        <span class="meta">@RequestMapping</span>(<span class="string">"/querybypage"</span>)  <span class="number">16</span>.        <span class="meta">@ResponseBody</span>  <span class="number">17</span>.        <span class="function"><span class="keyword">public</span> String <span class="title">QueryByPage</span><span class="params">(<span class="keyword">int</span> page, <span class="keyword">int</span> rows)</span> </span>{  <span class="number">18</span>.            <span class="comment">//当为缺省值的时候进行赋值  </span><span class="number">19</span>.            <span class="keyword">int</span> currentpage = ( page == <span class="number">0</span>) ? <span class="number">1</span>: page;   <span class="comment">//第几页  </span><span class="number">20</span>.            <span class="keyword">int</span> pageSize = (rows == <span class="number">0</span>) ? <span class="number">5</span>: rows;   <span class="comment">//每页显示数量  </span><span class="number">21</span>.            <span class="keyword">int</span> index = (currentpage - <span class="number">1</span>) * pageSize;   <span class="comment">//从第几条开始显示  </span><span class="number">22</span>.            JSONObject map = customerService.queryByPage(index, pageSize);  <span class="number">23</span>.            <span class="keyword">return</span> map.toString();  <span class="number">24</span>.        }  <span class="number">25</span>.          <span class="number">26</span>.        <span class="meta">@RequestMapping</span>(<span class="string">"/test"</span>)  <span class="number">27</span>.        <span class="keyword">public</span> <span class="meta">@ResponseBody</span> <span class="function">Object <span class="title">test</span><span class="params">()</span> </span>{  <span class="number">28</span>.            JSONObject json = <span class="keyword">new</span> JSONObject();  <span class="number">29</span>.            json.put(<span class="string">"status"</span>, <span class="string">"success"</span>);  <span class="number">30</span>.            String str = <span class="keyword">null</span>;  <span class="number">31</span>.            str.toString();  <span class="number">32</span>.            <span class="keyword">return</span> json.toString();  <span class="number">33</span>.        }  <span class="number">34</span>.    } </code></pre><p>其中重要的一行是</p><ol><li>public class CustomerController extends ExceptionController<br>这样CustomController里的方法被访问的时候， 如果有异常，就会被exceptionProces()处理.因为继承之后，子类中都有这个标注的方法了。<br>但这个注解只会是在当前的Controller里面起作用，如果想在所有的Controller里面统一处理异常的话，可以用@ControllerAdvice来创建一个专门处理全局的的类。<br><code>`</code>java</li><li>@ControllerAdvice    </li><li>public class SpringExceptionHandler{    </li><li>/**  </li><li><ul><li>全局处理Exception  </li></ul></li><li><ul><li>错误的情况下返回500  </li></ul></li><li><ul><li>@param ex  </li></ul></li><li><ul><li>@param req  </li></ul></li><li><ul><li>@return  </li></ul></li><li>*/    </li><li>@ExceptionHandler(value = {Exception.class})    </li><li>public ResponseEntity<object> handleOtherExceptions(final Exception ex, final WebRequest req) {    </object></li><li>TResult tResult = new TResult();  //处理结果  </li><li>tResult.setStatus(CodeType.V_500);    </li><li>tResult.setErrorMessage(ex.getMessage());    </li><li>return new ResponseEntity<object>(tResult,HttpStatus.OK);    </object></li><li>}    </li><li>}<br><code>`</code><br>注意，这种注解在springmvc的配置文件中扫描是，要把@ControllerAdvice也包含进来，否则不起作用。<br>此外，@ControllerAdvice还可以用于全局的requestMapping，较少用。<br>参考：<a href="http://jinnianshilongnian.iteye.com/blog/1866350" target="_blank" rel="noopener">http://jinnianshilongnian.iteye.com/blog/1866350</a><br><a href="http://blog.csdn.net/u013632755/article/details/49908621" target="_blank" rel="noopener">http://blog.csdn.net/u013632755/article/details/49908621</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有时候我们想统一处理一个Controller中抛出的异常怎么搞呢？&lt;br&gt;直接在Controller里面加上用@ExceptionHandler标注一个处理异常的方法像下面这样子，@ExceptionHandler只在当前controller里面有效。当前controller中所有抛出指定异常的方法。&lt;br&gt;
    
    </summary>
    
      <category term="spring" scheme="www.xiaoyb.cc/categories/spring/"/>
    
    
      <category term="springmvc" scheme="www.xiaoyb.cc/tags/springmvc/"/>
    
      <category term="异常处理" scheme="www.xiaoyb.cc/tags/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>SpringMVC自定义注解和拦截器实现用户行为验证</title>
    <link href="www.xiaoyb.cc/2017/08/01/SpringMVC%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3/"/>
    <id>www.xiaoyb.cc/2017/08/01/SpringMVC自定义注解/</id>
    <published>2017-08-01T09:30:39.000Z</published>
    <updated>2017-08-24T08:40:53.517Z</updated>
    
    <content type="html"><![CDATA[<p>最近在进行项目开发的时候需要对接口做Session验证</p><h1 id="自定义一个注解-AuthCheckAnnotation"><a href="#自定义一个注解-AuthCheckAnnotation" class="headerlink" title="自定义一个注解@AuthCheckAnnotation"></a>自定义一个注解@AuthCheckAnnotation</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Target</span>(ElementType.METHOD)</span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> AuthCheckAnnotation &#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">check</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;<span class="comment">//默认不需要进行验证</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><h1 id="定义一个相应的拦截器，在springMVC配置文件中进行配置"><a href="#定义一个相应的拦截器，在springMVC配置文件中进行配置" class="headerlink" title="定义一个相应的拦截器，在springMVC配置文件中进行配置"></a>定义一个相应的拦截器，在springMVC配置文件中进行配置</h1><p>拦截器：<br>&emsp;spring为我们提供了org.springframework.web.servlet.handler.HandlerInterceptorAdapter这个适配器，继承此类，可以非常方便的实现自己的拦截器。可以根据我们的需要重写preHandle、postHandle、afterCompletio方法。<br>分别实现预处理、后处理（调用了Service并返回ModelAndView，但未进行页面渲染）、返回处理（已经渲染了页面）</p><ol><li>在preHandle中，可以进行编码、安全控制等处理；</li><li>在postHandle中，有机会修改ModelAndView；</li><li>在afterCompletion中，可以根据ex是否为null判断是否发生了异常，进行日志记录。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AuthCheckInteceptor</span> <span class="keyword">extends</span> <span class="title">HandlerInterceptorAdapter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    UserInfoService userInfoService ;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        </span><br><span class="line">        HandlerMethod methodHandler=(HandlerMethod) handler;</span><br><span class="line">        AuthCheckAnnotation auth=methodHandler.getMethodAnnotation(AuthCheckAnnotation.class);</span><br><span class="line">　　　　　<span class="comment">//如果方法中添加了@AuthCheckAnnotation 这里的auth不为null</span></span><br><span class="line">　　　　　<span class="comment">//如果@AuthCheckAnnotation(check=false) 这里的auth为false,即不用进行拦截验证，@AuthCheckAnnotation默认为前面定义的true　　</span></span><br><span class="line">        <span class="keyword">if</span>(auth!=<span class="keyword">null</span>&amp;&amp;!auth.check())&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;  </span><br><span class="line">        &#125;</span><br><span class="line">        UserInfo user=(UserInfo)request.getSession().getAttribute(Constants.SESSION_USER);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            userInfoService.login(request, user);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            request.getRequestDispatcher(<span class="string">"login.do"</span>).forward(request, response);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>在springMVC.xml文件中添加拦截器<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:interceptors</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mvc:mapping</span> <span class="attr">path</span>=<span class="string">"/*.do"</span>  /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span>  <span class="attr">class</span>=<span class="string">"com.party.common.interceptor.AuthCheckInteceptor"</span>/&gt;</span>        </span><br><span class="line">    <span class="tag">&lt;/<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mvc:interceptors</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h1 id="在springMVC-controller中使用实例"><a href="#在springMVC-controller中使用实例" class="headerlink" title="在springMVC controller中使用实例"></a>在springMVC controller中使用实例</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AuthCheckAnnotation</span>(check=<span class="keyword">true</span>)</span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"doLogin"</span>)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">doLogin</span><span class="params">(HttpServletRequest request,HttpServletResponse response)</span></span>&#123;</span><br><span class="line">    .......</span><br><span class="line">    <span class="keyword">return</span> RetMessage.toJson(responseBody);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>转：<a href="https://www.bbsmax.com/A/QV5Z1jwbJy/" target="_blank" rel="noopener">https://www.bbsmax.com/A/QV5Z1jwbJy/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在进行项目开发的时候需要对接口做Session验证&lt;/p&gt;
&lt;h1 id=&quot;自定义一个注解-AuthCheckAnnotation&quot;&gt;&lt;a href=&quot;#自定义一个注解-AuthCheckAnnotation&quot; class=&quot;headerlink&quot; title=&quot;自定义一个注解@AuthCheckAnnotation&quot;&gt;&lt;/a&gt;自定义一个注解@AuthCheckAnnotation&lt;/h1&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;@Documented&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;@Target&lt;/span&gt;(ElementType.METHOD)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;@Inherited&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;@Retention&lt;/span&gt;(RetentionPolicy.RUNTIME)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;meta&quot;&gt;@interface&lt;/span&gt; AuthCheckAnnotation &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;check&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;default&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;false&lt;/span&gt;&lt;/span&gt;;&lt;span class=&quot;comment&quot;&gt;//默认不需要进行验证&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="spring" scheme="www.xiaoyb.cc/categories/spring/"/>
    
    
      <category term="springmvc" scheme="www.xiaoyb.cc/tags/springmvc/"/>
    
      <category term="自定义注解" scheme="www.xiaoyb.cc/tags/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>maven项目创建时出错</title>
    <link href="www.xiaoyb.cc/2017/07/22/maven/"/>
    <id>www.xiaoyb.cc/2017/07/22/maven/</id>
    <published>2017-07-22T07:56:06.000Z</published>
    <updated>2017-07-23T13:24:50.758Z</updated>
    
    <content type="html"><![CDATA[<p>哎，一些问题每次出错都要重新找方法解决。以后还是都记录下来把。</p><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>Eclipse创建Maven项目时，报错<br>Could not calculate build plan: Plugin org.apache.maven.plugins:maven-resources-plugin:2.6 or one of its dependencies could not be resolved: Failed to read artifact descriptor for org.apache.maven.plugins:maven-resources-plugin:jar:2.6<br>Plugin org.apache.maven.plugins:maven-resources-plugin:2.6 or one of its dependencies could not be resolved: Failed to read artifact descriptor for org.apache.maven.plugins:maven-resources-plugin:jar:2.6<br><a id="more"></a></p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>删除本地Maven仓库org.apache.maven.plugins:maven-resources-plugin所在目录文件夹。然后在一个maven项目中的pom.xml文件中增加以下依赖<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-resources-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>然后执行maven install重新下载maven-resources-plugin这个jar包即可。<br>同样的，有可能其他plugin会报类似的错误，解决方法和上面类似。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;哎，一些问题每次出错都要重新找方法解决。以后还是都记录下来把。&lt;/p&gt;
&lt;h2 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h2&gt;&lt;p&gt;Eclipse创建Maven项目时，报错&lt;br&gt;Could not calculate build plan: Plugin org.apache.maven.plugins:maven-resources-plugin:2.6 or one of its dependencies could not be resolved: Failed to read artifact descriptor for org.apache.maven.plugins:maven-resources-plugin:jar:2.6&lt;br&gt;Plugin org.apache.maven.plugins:maven-resources-plugin:2.6 or one of its dependencies could not be resolved: Failed to read artifact descriptor for org.apache.maven.plugins:maven-resources-plugin:jar:2.6&lt;br&gt;
    
    </summary>
    
      <category term="奇怪的问题" scheme="www.xiaoyb.cc/categories/%E5%A5%87%E6%80%AA%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    
    
  </entry>
  
  <entry>
    <title>Xgboost参数</title>
    <link href="www.xiaoyb.cc/2017/06/12/Xgboost%E5%8F%82%E6%95%B0/"/>
    <id>www.xiaoyb.cc/2017/06/12/Xgboost参数/</id>
    <published>2017-06-12T10:58:23.000Z</published>
    <updated>2017-07-23T13:24:50.754Z</updated>
    
    <content type="html"><![CDATA[<h1 id="XGBoost的参数"><a href="#XGBoost的参数" class="headerlink" title="XGBoost的参数"></a>XGBoost的参数</h1><p>XGBoost的作者把所有的参数分成了三类：</p><ol><li>通用参数：宏观函数控制。</li><li>Booster参数：控制每一步的booster(tree/regression)。</li><li>学习目标参数：控制训练目标的表现。<br>在这里我会类比GBM来讲解，所以作为一种基础知识，强烈推荐先阅读这篇文章。<a id="more"></a><h2 id="通用参数"><a href="#通用参数" class="headerlink" title="通用参数"></a>通用参数</h2>这些参数用来控制XGBoost的宏观功能。<h3 id="booster-默认gbtree"><a href="#booster-默认gbtree" class="headerlink" title="booster[默认gbtree]"></a>booster[默认gbtree]</h3>选择每次迭代的模型，有两种选择：<br>gbtree：基于树的模型<br>gbliner：线性模型<h3 id="silent-默认0"><a href="#silent-默认0" class="headerlink" title="silent[默认0]"></a>silent[默认0]</h3>当这个参数值为1时，静默模式开启，不会输出任何信息。<br>一般这个参数就保持默认的0，因为这样能帮我们更好地理解模型。<h3 id="nthread-默认值为最大可能的线程数"><a href="#nthread-默认值为最大可能的线程数" class="headerlink" title="nthread[默认值为最大可能的线程数]"></a>nthread[默认值为最大可能的线程数]</h3>这个参数用来进行多线程控制，应当输入系统的核数。<br>如果你希望使用CPU全部的核，那就不要输入这个参数，算法会自动检测它。<br>还有两个参数，XGBoost会自动设置，目前你不用管它。接下来咱们一起看booster参数。<h2 id="booster参数"><a href="#booster参数" class="headerlink" title="booster参数"></a>booster参数</h2>尽管有两种booster可供选择，我这里只介绍tree booster，因为它的表现远远胜过linear booster，所以linear booster很少用到。<h3 id="eta-默认0-3"><a href="#eta-默认0-3" class="headerlink" title="eta[默认0.3]"></a>eta[默认0.3]</h3>和GBM中的 learning rate 参数类似。<br>通过减少每一步的权重，可以提高模型的鲁棒性。<br>典型值为0.01-0.2。<h3 id="min-child-weight-默认1"><a href="#min-child-weight-默认1" class="headerlink" title="min_child_weight[默认1]"></a>min_child_weight[默认1]</h3>决定最小叶子节点样本权重和。<br>和GBM的 min_child_leaf 参数类似，但不完全一样。XGBoost的这个参数是最小样本权重的和，而GBM参数是最小样本总数。<br>这个参数用于避免过拟合。当它的值较大时，可以避免模型学习到局部的特殊样本。<br>但是如果这个值过高，会导致欠拟合。这个参数需要使用CV来调整。<h3 id="max-depth-默认6"><a href="#max-depth-默认6" class="headerlink" title="max_depth[默认6]"></a>max_depth[默认6]</h3>和GBM中的参数相同，这个值为树的最大深度。<br>这个值也是用来避免过拟合的。max_depth越大，模型会学到更具体更局部的样本。<br>需要使用CV函数来进行调优。<br>典型值：3-10<h3 id="max-leaf-nodes"><a href="#max-leaf-nodes" class="headerlink" title="max_leaf_nodes"></a>max_leaf_nodes</h3>树上最大的节点或叶子的数量。<br>可以替代max_depth的作用。因为如果生成的是二叉树，一个深度为n的树最多生成n2个叶子。<br>如果定义了这个参数，GBM会忽略max_depth参数。<h3 id="gamma-默认0"><a href="#gamma-默认0" class="headerlink" title="gamma[默认0]"></a>gamma[默认0]</h3>在节点分裂时，只有分裂后损失函数的值下降了，才会分裂这个节点。Gamma指定了节点分裂所需的最小损失函数下降值。<br>这个参数的值越大，算法越保守。这个参数的值和损失函数息息相关，所以是需要调整的。<h3 id="max-delta-step-默认0"><a href="#max-delta-step-默认0" class="headerlink" title="max_delta_step[默认0]"></a>max_delta_step[默认0]</h3>这参数限制每棵树权重改变的最大步长。如果这个参数的值为0，那就意味着没有约束。如果它被赋予了某个正值，那么它会让这个算法更加保守。<br>通常，这个参数不需要设置。但是当各类别的样本十分不平衡时，它对逻辑回归是很有帮助的。<br>这个参数一般用不到，但是你可以挖掘出来它更多的用处。<h3 id="subsample-默认1"><a href="#subsample-默认1" class="headerlink" title="subsample[默认1]"></a>subsample[默认1]</h3>和GBM中的subsample参数一模一样。这个参数控制对于每棵树，随机采样的比例。<br>减小这个参数的值，算法会更加保守，避免过拟合。但是，如果这个值设置得过小，它可能会导致欠拟合。<br>典型值：0.5-1<h3 id="colsample-bytree-默认1"><a href="#colsample-bytree-默认1" class="headerlink" title="colsample_bytree[默认1]"></a>colsample_bytree[默认1]</h3>和GBM里面的max_features参数类似。用来控制每棵随机采样的列数的占比(每一列是一个特征)。<br>典型值：0.5-1<h3 id="colsample-bylevel-默认1"><a href="#colsample-bylevel-默认1" class="headerlink" title="colsample_bylevel[默认1]"></a>colsample_bylevel[默认1]</h3>用来控制树的每一级的每一次分裂，对列数的采样的占比。<br>我个人一般不太用这个参数，因为subsample参数和colsample_bytree参数可以起到相同的作用。但是如果感兴趣，可以挖掘这个参数更多的用处。<h3 id="lambda-默认1"><a href="#lambda-默认1" class="headerlink" title="lambda[默认1]"></a>lambda[默认1]</h3>权重的L2正则化项。(和Ridge regression类似)。<br>这个参数是用来控制XGBoost的正则化部分的。虽然大部分数据科学家很少用到这个参数，但是这个参数在减少过拟合上还是可以挖掘出更多用处的。<h3 id="alpha-默认1"><a href="#alpha-默认1" class="headerlink" title="alpha[默认1]"></a>alpha[默认1]</h3>权重的L1正则化项。(和Lasso regression类似)。<br>可以应用在很高维度的情况下，使得算法的速度更快。<h3 id="scale-pos-weight-默认1"><a href="#scale-pos-weight-默认1" class="headerlink" title="scale_pos_weight[默认1]"></a>scale_pos_weight[默认1]</h3>在各类别样本十分不平衡时，把这个参数设定为一个正值，可以使算法更快收敛。<h2 id="学习目标参数"><a href="#学习目标参数" class="headerlink" title="学习目标参数"></a>学习目标参数</h2>这个参数用来控制理想的优化目标和每一步结果的度量方法。<h3 id="objective-默认reg-linear"><a href="#objective-默认reg-linear" class="headerlink" title="objective[默认reg:linear]"></a>objective[默认reg:linear]</h3>这个参数定义需要被最小化的损失函数。最常用的值有： </li><li>binary:logistic 二分类的逻辑回归，返回预测的概率(不是类别)。</li><li>multi:softmax 使用softmax的多分类器，返回预测的类别(不是概率)。<br>在这种情况下，你还需要多设一个参数：num_class(类别数目)。</li><li>multi:softprob 和multi:softmax参数一样，但是返回的是每个数据属于各个类别的概率。<h3 id="eval-metric-默认值取决于objective参数的取值"><a href="#eval-metric-默认值取决于objective参数的取值" class="headerlink" title="eval_metric[默认值取决于objective参数的取值]"></a>eval_metric[默认值取决于objective参数的取值]</h3>对于有效数据的度量方法。<br>对于回归问题，默认值是rmse，对于分类问题，默认值是error。<br>典型值有： </li><li>rmse 均方根误差(∑Ni=1ϵ2N−−−−−−√)</li><li>mae 平均绝对误差(∑Ni=1|ϵ|N)</li><li>logloss 负对数似然函数值</li><li>error 二分类错误率(阈值为0.5)</li><li>merror 多分类错误率</li><li>mlogloss 多分类logloss损失函数</li><li>auc 曲线下面积<h3 id="seed-默认0"><a href="#seed-默认0" class="headerlink" title="seed(默认0)"></a>seed(默认0)</h3>随机数的种子<br>设置它可以复现随机数据的结果，也可以用于调整参数<br>如果你之前用的是Scikit-learn,你可能不太熟悉这些参数。但是有个好消息，python的XGBoost模块有一个sklearn包，XGBClassifier。这个包中的参数是按sklearn风格命名的。会改变的函数名是：<br>1、eta -&gt; learning_rate<br>2、lambda -&gt; reg_lambda<br>3、alpha -&gt; reg_alpha<br>你肯定在疑惑为啥咱们没有介绍和GBM中的n_estimators类似的参数。XGBClassifier中确实有一个类似的参数，但是，是在标准XGBoost实现中调用拟合函数时，把它作为num_boosting_rounds参数传入。<br>XGBoost Guide 的一些部分是我强烈推荐大家阅读的，通过它可以对代码和参数有一个更好的了解：<br><a href="http://xgboost.readthedocs.io/en/latest/parameter.html#general-parameters" target="_blank" rel="noopener">http://xgboost.readthedocs.io/en/latest/parameter.html#general-parameters</a><br><a href="https://github.com/dmlc/xgboost/tree/master/demo/guide-python" title="XGBoost Demo Codes" target="_blank" rel="noopener">https://github.com/dmlc/xgboost/tree/master/demo/guide-python</a><br><a href="http://xgboost.readthedocs.io/en/latest/python/python_api.html" title="Python Api" target="_blank" rel="noopener">http://xgboost.readthedocs.io/en/latest/python/python_api.html</a><br>本文参考：<a href="http://blog.csdn.net/han_xiaoyang/article/details/52665396" target="_blank" rel="noopener">http://blog.csdn.net/han_xiaoyang/article/details/52665396</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;XGBoost的参数&quot;&gt;&lt;a href=&quot;#XGBoost的参数&quot; class=&quot;headerlink&quot; title=&quot;XGBoost的参数&quot;&gt;&lt;/a&gt;XGBoost的参数&lt;/h1&gt;&lt;p&gt;XGBoost的作者把所有的参数分成了三类：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;通用参数：宏观函数控制。&lt;/li&gt;
&lt;li&gt;Booster参数：控制每一步的booster(tree/regression)。&lt;/li&gt;
&lt;li&gt;学习目标参数：控制训练目标的表现。&lt;br&gt;在这里我会类比GBM来讲解，所以作为一种基础知识，强烈推荐先阅读这篇文章。
    
    </summary>
    
      <category term="Xgboost" scheme="www.xiaoyb.cc/categories/Xgboost/"/>
    
    
      <category term="Xgboost" scheme="www.xiaoyb.cc/tags/Xgboost/"/>
    
  </entry>
  
  <entry>
    <title>python求list的平均数、众数、最大值、最小值、极值、方差等</title>
    <link href="www.xiaoyb.cc/2017/06/07/python%E6%B1%82list%E7%9A%84%E5%B9%B3%E5%9D%87%E6%95%B0%E3%80%81%E4%BC%97%E6%95%B0%E3%80%81%E6%9C%80%E5%A4%A7%E5%80%BC%E3%80%81%E6%9C%80%E5%B0%8F%E5%80%BC%E3%80%81%E6%9E%81%E5%80%BC%E3%80%81%E6%96%B9%E5%B7%AE%E7%AD%89/"/>
    <id>www.xiaoyb.cc/2017/06/07/python求list的平均数、众数、最大值、最小值、极值、方差等/</id>
    <published>2017-06-07T09:03:36.000Z</published>
    <updated>2017-07-23T13:24:50.758Z</updated>
    
    <content type="html"><![CDATA[<p>数据挖掘中经常会用到一组数据(list)的相关特征。<br><a id="more"></a><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">feature.py</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="comment">#最大数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Get_Max</span><span class="params">(list)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> max(list)</span><br><span class="line"></span><br><span class="line"><span class="comment">#最小数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Get_Min</span><span class="params">(list)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> min(list)</span><br><span class="line"></span><br><span class="line"><span class="comment">#极差</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Get_Range</span><span class="params">(list)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> max(list) - min(list)</span><br><span class="line"></span><br><span class="line"><span class="comment">#中位数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_median</span><span class="params">(data)</span>:</span></span><br><span class="line">   data = sorted(data)</span><br><span class="line">   size = len(data)</span><br><span class="line">   <span class="keyword">if</span> size % <span class="number">2</span> == <span class="number">0</span>: <span class="comment"># 判断列表长度为偶数</span></span><br><span class="line">       median = (data[size//<span class="number">2</span>]+data[size//<span class="number">2</span><span class="number">-1</span>])/<span class="number">2</span></span><br><span class="line">   <span class="keyword">if</span> size % <span class="number">2</span> == <span class="number">1</span>: <span class="comment"># 判断列表长度为奇数</span></span><br><span class="line">       median = data[(size<span class="number">-1</span>)//<span class="number">2</span>]</span><br><span class="line">   <span class="keyword">return</span> median</span><br><span class="line"></span><br><span class="line"><span class="comment">#众数(返回多个众数的平均值)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Get_Most</span><span class="params">(list)</span>:</span></span><br><span class="line">    most=[]</span><br><span class="line">    item_num = dict((item, list.count(item)) <span class="keyword">for</span> item <span class="keyword">in</span> list)</span><br><span class="line">    <span class="keyword">for</span> k,v <span class="keyword">in</span> item_num.items():</span><br><span class="line">        <span class="keyword">if</span> v == max(item_num.values()):</span><br><span class="line">           most.append(k)</span><br><span class="line">    <span class="keyword">return</span> sum(most)/len(most)</span><br><span class="line"></span><br><span class="line"><span class="comment">#获取平均数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Get_Average</span><span class="params">(list)</span>:</span></span><br><span class="line">sum = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> list:</span><br><span class="line">sum += item</span><br><span class="line"><span class="keyword">return</span> sum/len(list)</span><br><span class="line"></span><br><span class="line"><span class="comment">#获取方差</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Get_Variance</span><span class="params">(list)</span>:</span></span><br><span class="line">sum = <span class="number">0</span></span><br><span class="line">average = Get_Average(list)</span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> list:</span><br><span class="line">sum += (item - average)**<span class="number">2</span></span><br><span class="line"><span class="keyword">return</span> sum/len(list)</span><br><span class="line"></span><br><span class="line"><span class="comment">#获取n阶原点距</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Get_NMoment</span><span class="params">(list,n)</span>:</span></span><br><span class="line">    sum=<span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> list:</span><br><span class="line">        sum += item**n</span><br><span class="line">    <span class="keyword">return</span> sum/len(list)</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;数据挖掘中经常会用到一组数据(list)的相关特征。&lt;br&gt;
    
    </summary>
    
      <category term="python" scheme="www.xiaoyb.cc/categories/python/"/>
    
    
      <category term="python" scheme="www.xiaoyb.cc/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>使用sklearn优雅地进行数据挖掘</title>
    <link href="www.xiaoyb.cc/2017/06/07/%E4%BD%BF%E7%94%A8sklearn%E4%BC%98%E9%9B%85%E5%9C%B0%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/"/>
    <id>www.xiaoyb.cc/2017/06/07/使用sklearn优雅地进行数据挖掘/</id>
    <published>2017-06-07T02:12:24.000Z</published>
    <updated>2017-07-23T13:24:50.761Z</updated>
    
    <content type="html"><![CDATA[<p>今天找资料的时候，发现一个很牛的大神。写的博客是真的好。慢慢的汲取养分。<br>转自：<a href="http://www.cnblogs.com/jasonfreak/p/5448462.html" target="_blank" rel="noopener">http://www.cnblogs.com/jasonfreak/p/5448462.html</a></p><h1 id="使用sklearn进行数据挖掘"><a href="#使用sklearn进行数据挖掘" class="headerlink" title="使用sklearn进行数据挖掘"></a>使用sklearn进行数据挖掘</h1><h2 id="数据挖掘的步骤"><a href="#数据挖掘的步骤" class="headerlink" title="数据挖掘的步骤"></a>数据挖掘的步骤</h2><p>数据挖掘通常包括数据采集，数据分析，特征工程，训练模型，模型评估等步骤。使用sklearn工具可以方便地进行特征工程和模型训练工作，在《使用sklearn做单机特征工程》中，我们最后留下了一些疑问：特征处理类都有三个方法fit、transform和fit_transform，fit方法居然和模型训练方法fit同名（不光同名，参数列表都一样），这难道都是巧合？<br>显然，这不是巧合，这正是sklearn的设计风格。我们能够更加优雅地使用sklearn进行特征工程和模型训练工作。此时，不妨从一个基本的数据挖掘场景入手：<br><a id="more"></a><br><img src="http://i.imgur.com/Tru96mm.png" alt=""><br>我们使用sklearn进行虚线框内的工作（sklearn也可以进行文本特征提取）。通过分析sklearn源码，我们可以看到除训练，预测和评估以外，处理其他工作的类都实现了3个方法：fit、transform和fit_transform。从命名中可以看到，fit_transform方法是先调用fit然后调用transform，我们只需要关注fit方法和transform方法即可。</p><p>transform方法主要用来对特征进行转换。从可利用信息的角度来说，转换分为无信息转换和有信息转换。无信息转换是指不利用任何其他信息进行转换，比如指数、对数函数转换等。有信息转换从是否利用目标值向量又可分为无监督转换和有监督转换。无监督转换指只利用特征的统计信息的转换，统计信息包括均值、标准差、边界等等，比如标准化、PCA法降维等。有监督转换指既利用了特征信息又利用了目标值信息的转换，比如通过模型选择特征、LDA法降维等。通过总结常用的转换类，我们得到下表：<br><img src="http://i.imgur.com/Eo7KOEI.png" alt=""><br>不难看到，只有有信息的转换类的fit方法才实际有用，显然fit方法的主要工作是获取特征信息和目标值信息，在这点上，fit方法和模型训练时的fit方法就能够联系在一起了：都是通过分析特征和目标值，提取有价值的信息，对于转换类来说是某些统计量，对于模型来说可能是特征的权值系数等。另外，只有有监督的转换类的fit和transform方法才需要特征和目标值两个参数。fit方法无用不代表其没实现，而是除合法性校验以外，其并没有对特征和目标值进行任何处理，Normalizer的fit方法实现如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="function"><span class="keyword">def</span> <span class="title">fit</span><span class="params">(self, X, y=None)</span>:</span></span><br><span class="line"><span class="number">2</span>         <span class="string">"""Do nothing and return the estimator unchanged</span></span><br><span class="line"><span class="string">3         This method is just there to implement the usual API and hence</span></span><br><span class="line"><span class="string">4         work in pipelines.</span></span><br><span class="line"><span class="string">5         """</span></span><br><span class="line"><span class="number">6</span>         X = check_array(X, accept_sparse=<span class="string">'csr'</span>)</span><br><span class="line"><span class="number">7</span>         <span class="keyword">return</span> self</span><br></pre></td></tr></table></figure></p><p>基于这些特征处理工作都有共同的方法，那么试想可不可以将他们组合在一起？在本文假设的场景中，我们可以看到这些工作的组合形式有两种：流水线式和并行式。基于流水线组合的工作需要依次进行，前一个工作的输出是后一个工作的输入；基于并行式的工作可以同时进行，其使用同样的输入，所有工作完成后将各自的输出合并之后输出。sklearn提供了包pipeline来完成流水线式和并行式的工作。</p><h2 id="数据初貌"><a href="#数据初貌" class="headerlink" title="数据初貌"></a>数据初貌</h2><p>在此，我们仍然使用IRIS数据集来进行说明。为了适应提出的场景，对原数据集需要稍微加工：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">1</span> <span class="keyword">from</span> numpy <span class="keyword">import</span> hstack, vstack, array, median, nan</span><br><span class="line"> <span class="number">2</span> <span class="keyword">from</span> numpy.random <span class="keyword">import</span> choice</span><br><span class="line"> <span class="number">3</span> <span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_iris</span><br><span class="line"> <span class="number">4</span> </span><br><span class="line"> <span class="number">5</span> <span class="comment">#特征矩阵加工</span></span><br><span class="line"> <span class="number">6</span> <span class="comment">#使用vstack增加一行含缺失值的样本(nan, nan, nan, nan)</span></span><br><span class="line"> <span class="number">7</span> <span class="comment">#使用hstack增加一列表示花的颜色（0-白、1-黄、2-红），花的颜色是随机的，意味着颜色并不影响花的分类</span></span><br><span class="line"> <span class="number">8</span> iris.data = hstack((choice([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>], size=iris.data.shape[<span class="number">0</span>]+<span class="number">1</span>).reshape(<span class="number">-1</span>,<span class="number">1</span>), vstack((iris.data, array([nan, nan, nan, nan]).reshape(<span class="number">1</span>,<span class="number">-1</span>)))))</span><br><span class="line"> <span class="number">9</span> <span class="comment">#目标值向量加工</span></span><br><span class="line"><span class="number">10</span> <span class="comment">#增加一个目标值，对应含缺失值的样本，值为众数</span></span><br><span class="line"><span class="number">11</span> iris.target = hstack((iris.target, array([median(iris.target)])))</span><br></pre></td></tr></table></figure></p><h2 id="关键技术"><a href="#关键技术" class="headerlink" title="关键技术"></a>关键技术</h2><h2 id="并行处理，流水线处理，自动化调参，持久化是使用sklearn优雅地进行数据挖掘的核心。并行处理和流水线处理将多个特征处理工作，甚至包括模型训练工作组合成一个工作（从代码的角度来说，即将多个对象组合成了一个对象）。在组合的前提下，自动化调参技术帮我们省去了人工调参的反锁。训练好的模型是贮存在内存中的数据，持久化能够将这些数据保存在文件系统中，之后使用时无需再进行训练，直接从文件系统中加载即可。"><a href="#并行处理，流水线处理，自动化调参，持久化是使用sklearn优雅地进行数据挖掘的核心。并行处理和流水线处理将多个特征处理工作，甚至包括模型训练工作组合成一个工作（从代码的角度来说，即将多个对象组合成了一个对象）。在组合的前提下，自动化调参技术帮我们省去了人工调参的反锁。训练好的模型是贮存在内存中的数据，持久化能够将这些数据保存在文件系统中，之后使用时无需再进行训练，直接从文件系统中加载即可。" class="headerlink" title="并行处理，流水线处理，自动化调参，持久化是使用sklearn优雅地进行数据挖掘的核心。并行处理和流水线处理将多个特征处理工作，甚至包括模型训练工作组合成一个工作（从代码的角度来说，即将多个对象组合成了一个对象）。在组合的前提下，自动化调参技术帮我们省去了人工调参的反锁。训练好的模型是贮存在内存中的数据，持久化能够将这些数据保存在文件系统中，之后使用时无需再进行训练，直接从文件系统中加载即可。"></a>并行处理，流水线处理，自动化调参，持久化是使用sklearn优雅地进行数据挖掘的核心。并行处理和流水线处理将多个特征处理工作，甚至包括模型训练工作组合成一个工作（从代码的角度来说，即将多个对象组合成了一个对象）。在组合的前提下，自动化调参技术帮我们省去了人工调参的反锁。训练好的模型是贮存在内存中的数据，持久化能够将这些数据保存在文件系统中，之后使用时无需再进行训练，直接从文件系统中加载即可。</h2><h1 id="并行处理"><a href="#并行处理" class="headerlink" title="并行处理"></a>并行处理</h1><p>并行处理使得多个特征处理工作能够并行地进行。根据对特征矩阵的读取方式不同，可分为整体并行处理和部分并行处理。整体并行处理，即并行处理的每个工作的输入都是特征矩阵的整体；部分并行处理，即可定义每个工作需要输入的特征矩阵的列。</p><h2 id="整体并行处理"><a href="#整体并行处理" class="headerlink" title="整体并行处理"></a>整体并行处理</h2><p>pipeline包提供了FeatureUnion类来进行整体并行处理：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">1</span> <span class="keyword">from</span> numpy <span class="keyword">import</span> log1p</span><br><span class="line"> <span class="number">2</span> <span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> FunctionTransformer</span><br><span class="line"> <span class="number">3</span> <span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> Binarizer</span><br><span class="line"> <span class="number">4</span> <span class="keyword">from</span> sklearn.pipeline <span class="keyword">import</span> FeatureUnion</span><br><span class="line"> <span class="number">5</span> </span><br><span class="line"> <span class="number">6</span> <span class="comment">#新建将整体特征矩阵进行对数函数转换的对象</span></span><br><span class="line"> <span class="number">7</span> step2_1 = (<span class="string">'ToLog'</span>, FunctionTransformer(log1p))</span><br><span class="line"> <span class="number">8</span> <span class="comment">#新建将整体特征矩阵进行二值化类的对象</span></span><br><span class="line"> <span class="number">9</span> step2_2 = (<span class="string">'ToBinary'</span>, Binarizer())</span><br><span class="line"><span class="number">10</span> <span class="comment">#新建整体并行处理对象</span></span><br><span class="line"><span class="number">11</span> <span class="comment">#该对象也有fit和transform方法，fit和transform方法均是并行地调用需要并行处理的对象的fit和transform方法</span></span><br><span class="line"><span class="number">12</span> <span class="comment">#参数transformer_list为需要并行处理的对象列表，该列表为二元组列表，第一元为对象的名称，第二元为对象</span></span><br><span class="line"><span class="number">13</span> step2 = (<span class="string">'FeatureUnion'</span>, FeatureUnion(transformer_list=[step2_1, step2_2, step2_3]))</span><br></pre></td></tr></table></figure></p><h2 id="部分并行处理"><a href="#部分并行处理" class="headerlink" title="部分并行处理"></a>部分并行处理</h2><p>整体并行处理有其缺陷，在一些场景下，我们只需要对特征矩阵的某些列进行转换，而不是所有列。pipeline并没有提供相应的类（仅OneHotEncoder类实现了该功能），需要我们在FeatureUnion的基础上进行优化：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">1</span> <span class="keyword">from</span> sklearn.pipeline <span class="keyword">import</span> FeatureUnion, _fit_one_transformer, _fit_transform_one, _transform_one </span><br><span class="line"> <span class="number">2</span> <span class="keyword">from</span> sklearn.externals.joblib <span class="keyword">import</span> Parallel, delayed</span><br><span class="line"> <span class="number">3</span> <span class="keyword">from</span> scipy <span class="keyword">import</span> sparse</span><br><span class="line"> <span class="number">4</span> <span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"> <span class="number">5</span> </span><br><span class="line"> <span class="number">6</span> <span class="comment">#部分并行处理，继承FeatureUnion</span></span><br><span class="line"> <span class="number">7</span> <span class="class"><span class="keyword">class</span> <span class="title">FeatureUnionExt</span><span class="params">(FeatureUnion)</span>:</span></span><br><span class="line"> <span class="number">8</span>     <span class="comment">#相比FeatureUnion，多了idx_list参数，其表示每个并行工作需要读取的特征矩阵的列</span></span><br><span class="line"> <span class="number">9</span>     <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, transformer_list, idx_list, n_jobs=<span class="number">1</span>, transformer_weights=None)</span>:</span></span><br><span class="line"><span class="number">10</span>         self.idx_list = idx_list</span><br><span class="line"><span class="number">11</span>         FeatureUnion.__init__(self, transformer_list=map(<span class="keyword">lambda</span> trans:(trans[<span class="number">0</span>], trans[<span class="number">1</span>]), transformer_list), n_jobs=n_jobs, transformer_weights=transformer_weights)</span><br><span class="line"><span class="number">12</span> </span><br><span class="line"><span class="number">13</span>     <span class="comment">#由于只部分读取特征矩阵，方法fit需要重构</span></span><br><span class="line"><span class="number">14</span>     <span class="function"><span class="keyword">def</span> <span class="title">fit</span><span class="params">(self, X, y=None)</span>:</span></span><br><span class="line"><span class="number">15</span>         transformer_idx_list = map(<span class="keyword">lambda</span> trans, idx:(trans[<span class="number">0</span>], trans[<span class="number">1</span>], idx), self.transformer_list, self.idx_list)</span><br><span class="line"><span class="number">16</span>         transformers = Parallel(n_jobs=self.n_jobs)(</span><br><span class="line"><span class="number">17</span>             <span class="comment">#从特征矩阵中提取部分输入fit方法</span></span><br><span class="line"><span class="number">18</span>             delayed(_fit_one_transformer)(trans, X[:,idx], y)</span><br><span class="line"><span class="number">19</span>             <span class="keyword">for</span> name, trans, idx <span class="keyword">in</span> transformer_idx_list)</span><br><span class="line"><span class="number">20</span>         self._update_transformer_list(transformers)</span><br><span class="line"><span class="number">21</span>         <span class="keyword">return</span> self</span><br><span class="line"><span class="number">22</span> </span><br><span class="line"><span class="number">23</span>     <span class="comment">#由于只部分读取特征矩阵，方法fit_transform需要重构</span></span><br><span class="line"><span class="number">24</span>     <span class="function"><span class="keyword">def</span> <span class="title">fit_transform</span><span class="params">(self, X, y=None, **fit_params)</span>:</span></span><br><span class="line"><span class="number">25</span>         transformer_idx_list = map(<span class="keyword">lambda</span> trans, idx:(trans[<span class="number">0</span>], trans[<span class="number">1</span>], idx), self.transformer_list, self.idx_list)</span><br><span class="line"><span class="number">26</span>         result = Parallel(n_jobs=self.n_jobs)(</span><br><span class="line"><span class="number">27</span>             <span class="comment">#从特征矩阵中提取部分输入fit_transform方法</span></span><br><span class="line"><span class="number">28</span>             delayed(_fit_transform_one)(trans, name, X[:,idx], y,</span><br><span class="line"><span class="number">29</span>                                         self.transformer_weights, **fit_params)</span><br><span class="line"><span class="number">30</span>             <span class="keyword">for</span> name, trans, idx <span class="keyword">in</span> transformer_idx_list)</span><br><span class="line"><span class="number">31</span> </span><br><span class="line"><span class="number">32</span>         Xs, transformers = zip(*result)</span><br><span class="line"><span class="number">33</span>         self._update_transformer_list(transformers)</span><br><span class="line"><span class="number">34</span>         <span class="keyword">if</span> any(sparse.issparse(f) <span class="keyword">for</span> f <span class="keyword">in</span> Xs):</span><br><span class="line"><span class="number">35</span>             Xs = sparse.hstack(Xs).tocsr()</span><br><span class="line"><span class="number">36</span>         <span class="keyword">else</span>:</span><br><span class="line"><span class="number">37</span>             Xs = np.hstack(Xs)</span><br><span class="line"><span class="number">38</span>         <span class="keyword">return</span> Xs</span><br><span class="line"><span class="number">39</span> </span><br><span class="line"><span class="number">40</span>     <span class="comment">#由于只部分读取特征矩阵，方法transform需要重构</span></span><br><span class="line"><span class="number">41</span>     <span class="function"><span class="keyword">def</span> <span class="title">transform</span><span class="params">(self, X)</span>:</span></span><br><span class="line"><span class="number">42</span>         transformer_idx_list = map(<span class="keyword">lambda</span> trans, idx:(trans[<span class="number">0</span>], trans[<span class="number">1</span>], idx), self.transformer_list, self.idx_list)</span><br><span class="line"><span class="number">43</span>         Xs = Parallel(n_jobs=self.n_jobs)(</span><br><span class="line"><span class="number">44</span>             <span class="comment">#从特征矩阵中提取部分输入transform方法</span></span><br><span class="line"><span class="number">45</span>             delayed(_transform_one)(trans, name, X[:,idx], self.transformer_weights)</span><br><span class="line"><span class="number">46</span>             <span class="keyword">for</span> name, trans, idx <span class="keyword">in</span> transformer_idx_list)</span><br><span class="line"><span class="number">47</span>         <span class="keyword">if</span> any(sparse.issparse(f) <span class="keyword">for</span> f <span class="keyword">in</span> Xs):</span><br><span class="line"><span class="number">48</span>             Xs = sparse.hstack(Xs).tocsr()</span><br><span class="line"><span class="number">49</span>         <span class="keyword">else</span>:</span><br><span class="line"><span class="number">50</span>             Xs = np.hstack(Xs)</span><br><span class="line"><span class="number">51</span>         <span class="keyword">return</span> Xs</span><br></pre></td></tr></table></figure></p><p>在本文提出的场景中，我们对特征矩阵的第1列（花的颜色）进行定性特征编码，对第2、3、4列进行对数函数转换，对第5列进行定量特征二值化处理。使用FeatureUnionExt类进行部分并行处理的代码如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">1</span> <span class="keyword">from</span> numpy <span class="keyword">import</span> log1p</span><br><span class="line"> <span class="number">2</span> <span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> OneHotEncoder</span><br><span class="line"> <span class="number">3</span> <span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> FunctionTransformer</span><br><span class="line"> <span class="number">4</span> <span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> Binarizer</span><br><span class="line"> <span class="number">5</span> </span><br><span class="line"> <span class="number">6</span> <span class="comment">#新建将部分特征矩阵进行定性特征编码的对象</span></span><br><span class="line"> <span class="number">7</span> step2_1 = (<span class="string">'OneHotEncoder'</span>, OneHotEncoder(sparse=<span class="keyword">False</span>))</span><br><span class="line"> <span class="number">8</span> <span class="comment">#新建将部分特征矩阵进行对数函数转换的对象</span></span><br><span class="line"> <span class="number">9</span> step2_2 = (<span class="string">'ToLog'</span>, FunctionTransformer(log1p))</span><br><span class="line"><span class="number">10</span> <span class="comment">#新建将部分特征矩阵进行二值化类的对象</span></span><br><span class="line"><span class="number">11</span> step2_3 = (<span class="string">'ToBinary'</span>, Binarizer())</span><br><span class="line"><span class="number">12</span> <span class="comment">#新建部分并行处理对象</span></span><br><span class="line"><span class="number">13</span> <span class="comment">#参数transformer_list为需要并行处理的对象列表，该列表为二元组列表，第一元为对象的名称，第二元为对象</span></span><br><span class="line"><span class="number">14</span> <span class="comment">#参数idx_list为相应的需要读取的特征矩阵的列</span></span><br><span class="line"><span class="number">15</span> step2 = (<span class="string">'FeatureUnionExt'</span>, FeatureUnionExt(transformer_list=[step2_1, step2_2, step2_3], idx_list=[[<span class="number">0</span>], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>]]))</span><br></pre></td></tr></table></figure></p><h1 id="流水线处理"><a href="#流水线处理" class="headerlink" title="流水线处理"></a>流水线处理</h1><p>pipeline包提供了Pipeline类来进行流水线处理。流水线上除最后一个工作以外，其他都要执行fit_transform方法，且上一个工作输出作为下一个工作的输入。最后一个工作必须实现fit方法，输入为上一个工作的输出；但是不限定一定有transform方法，因为流水线的最后一个工作可能是训练！<br>根据本文提出的场景，结合并行处理，构建完整的流水线的代码如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">1</span> <span class="keyword">from</span> numpy <span class="keyword">import</span> log1p</span><br><span class="line"> <span class="number">2</span> <span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> Imputer</span><br><span class="line"> <span class="number">3</span> <span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> OneHotEncoder</span><br><span class="line"> <span class="number">4</span> <span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> FunctionTransformer</span><br><span class="line"> <span class="number">5</span> <span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> Binarizer</span><br><span class="line"> <span class="number">6</span> <span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> MinMaxScaler</span><br><span class="line"> <span class="number">7</span> <span class="keyword">from</span> sklearn.feature_selection <span class="keyword">import</span> SelectKBest</span><br><span class="line"> <span class="number">8</span> <span class="keyword">from</span> sklearn.feature_selection <span class="keyword">import</span> chi2</span><br><span class="line"> <span class="number">9</span> <span class="keyword">from</span> sklearn.decomposition <span class="keyword">import</span> PCA</span><br><span class="line"><span class="number">10</span> <span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LogisticRegression</span><br><span class="line"><span class="number">11</span> <span class="keyword">from</span> sklearn.pipeline <span class="keyword">import</span> Pipeline</span><br><span class="line"><span class="number">12</span> </span><br><span class="line"><span class="number">13</span> <span class="comment">#新建计算缺失值的对象</span></span><br><span class="line"><span class="number">14</span> step1 = (<span class="string">'Imputer'</span>, Imputer())</span><br><span class="line"><span class="number">15</span> <span class="comment">#新建将部分特征矩阵进行定性特征编码的对象</span></span><br><span class="line"><span class="number">16</span> step2_1 = (<span class="string">'OneHotEncoder'</span>, OneHotEncoder(sparse=<span class="keyword">False</span>))</span><br><span class="line"><span class="number">17</span> <span class="comment">#新建将部分特征矩阵进行对数函数转换的对象</span></span><br><span class="line"><span class="number">18</span> step2_2 = (<span class="string">'ToLog'</span>, FunctionTransformer(log1p))</span><br><span class="line"><span class="number">19</span> <span class="comment">#新建将部分特征矩阵进行二值化类的对象</span></span><br><span class="line"><span class="number">20</span> step2_3 = (<span class="string">'ToBinary'</span>, Binarizer())</span><br><span class="line"><span class="number">21</span> <span class="comment">#新建部分并行处理对象，返回值为每个并行工作的输出的合并</span></span><br><span class="line"><span class="number">22</span> step2 = (<span class="string">'FeatureUnionExt'</span>, FeatureUnionExt(transformer_list=[step2_1, step2_2, step2_3], idx_list=[[<span class="number">0</span>], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>]]))</span><br><span class="line"><span class="number">23</span> <span class="comment">#新建无量纲化对象</span></span><br><span class="line"><span class="number">24</span> step3 = (<span class="string">'MinMaxScaler'</span>, MinMaxScaler())</span><br><span class="line"><span class="number">25</span> <span class="comment">#新建卡方校验选择特征的对象</span></span><br><span class="line"><span class="number">26</span> step4 = (<span class="string">'SelectKBest'</span>, SelectKBest(chi2, k=<span class="number">3</span>))</span><br><span class="line"><span class="number">27</span> <span class="comment">#新建PCA降维的对象</span></span><br><span class="line"><span class="number">28</span> step5 = (<span class="string">'PCA'</span>, PCA(n_components=<span class="number">2</span>))</span><br><span class="line"><span class="number">29</span> <span class="comment">#新建逻辑回归的对象，其为待训练的模型作为流水线的最后一步</span></span><br><span class="line"><span class="number">30</span> step6 = (<span class="string">'LogisticRegression'</span>, LogisticRegression(penalty=<span class="string">'l2'</span>))</span><br><span class="line"><span class="number">31</span> <span class="comment">#新建流水线处理对象</span></span><br><span class="line"><span class="number">32</span> <span class="comment">#参数steps为需要流水线处理的对象列表，该列表为二元组列表，第一元为对象的名称，第二元为对象</span></span><br><span class="line"><span class="number">33</span> pipeline = Pipeline(steps=[step1, step2, step3, step4, step5, step6])</span><br></pre></td></tr></table></figure></p><h1 id="自动化调参"><a href="#自动化调参" class="headerlink" title="自动化调参"></a>自动化调参</h1><p>网格搜索为自动化调参的常见技术之一，grid_search包提供了自动化调参的工具，包括GridSearchCV类。对组合好的对象进行训练以及调参的代码如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="keyword">from</span> sklearn.grid_search <span class="keyword">import</span> GridSearchCV</span><br><span class="line"><span class="number">2</span> </span><br><span class="line"><span class="number">3</span> <span class="comment">#新建网格搜索对象</span></span><br><span class="line"><span class="number">4</span> <span class="comment">#第一参数为待训练的模型</span></span><br><span class="line"><span class="number">5</span>  <span class="comment">#param_grid为待调参数组成的网格，字典格式，键为参数名称（格式“对象名称__子对象名称__参数名称”），值为可取的参数值列表</span></span><br><span class="line"><span class="number">6</span>  grid_search = GridSearchCV(pipeline, param_grid=&#123;<span class="string">'FeatureUnionExt__ToBinary__threshold'</span>:[<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>, <span class="number">4.0</span>], <span class="string">'LogisticRegression__C'</span>:[<span class="number">0.1</span>, <span class="number">0.2</span>, <span class="number">0.4</span>, <span class="number">0.8</span>]&#125;)</span><br><span class="line"><span class="number">7</span> <span class="comment">#训练以及调参</span></span><br><span class="line"><span class="number">8</span> grid_search.fit(iris.data, iris.target)</span><br></pre></td></tr></table></figure></p><h1 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h1><p>externals.joblib包提供了dump和load方法来持久化和加载内存数据：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="comment">#持久化数据</span></span><br><span class="line"><span class="number">2</span> <span class="comment">#第一个参数为内存中的对象</span></span><br><span class="line"><span class="number">3</span> <span class="comment">#第二个参数为保存在文件系统中的名称</span></span><br><span class="line"><span class="number">4</span> <span class="comment">#第三个参数为压缩级别，0为不压缩，3为合适的压缩级别</span></span><br><span class="line"><span class="number">5</span> dump(grid_search, <span class="string">'grid_search.dmp'</span>, compress=<span class="number">3</span>)</span><br><span class="line"><span class="number">6</span> <span class="comment">#从文件系统中加载数据到内存中</span></span><br><span class="line"><span class="number">7</span> grid_search = load(<span class="string">'grid_search.dmp'</span>)</span><br></pre></td></tr></table></figure></p><h1 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h1><p><img src="http://i.imgur.com/U20pnnw.png" alt=""><br>注意：组合和持久化都会涉及pickle技术，在sklearn的技术文档中有说明，将lambda定义的函数作为FunctionTransformer的自定义转换函数将不能pickle化。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>2015年我设计了一个基于sklearn的自动化特征工程的工具，其以Mysql数据库作为原始数据源，提供了“灵活的”特征提取、特征处理的配置方法，同时重新封装了数据、特征和模型，以方便调度系统识别。说灵活，其实也只是通过配置文件的方式定义每个特征的提取和处理的sql语句。但是纯粹使用sql语句来进行特征处理是很勉强的，除去特征提取以外，我又造了一回轮子，原来sklearn提供了这么优秀的特征处理、工作组合等功能。所以，我在这个博客中先不提任何算法和模型，先从数据挖掘工作的第一步开始，使用基于Python的各个工具把大部分步骤都走了一遍（抱歉，我暂时忽略了特征提取），希望这样的梳理能够少让初学者走弯路吧。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天找资料的时候，发现一个很牛的大神。写的博客是真的好。慢慢的汲取养分。&lt;br&gt;转自：&lt;a href=&quot;http://www.cnblogs.com/jasonfreak/p/5448462.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://www.cnblogs.com/jasonfreak/p/5448462.html&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;使用sklearn进行数据挖掘&quot;&gt;&lt;a href=&quot;#使用sklearn进行数据挖掘&quot; class=&quot;headerlink&quot; title=&quot;使用sklearn进行数据挖掘&quot;&gt;&lt;/a&gt;使用sklearn进行数据挖掘&lt;/h1&gt;&lt;h2 id=&quot;数据挖掘的步骤&quot;&gt;&lt;a href=&quot;#数据挖掘的步骤&quot; class=&quot;headerlink&quot; title=&quot;数据挖掘的步骤&quot;&gt;&lt;/a&gt;数据挖掘的步骤&lt;/h2&gt;&lt;p&gt;数据挖掘通常包括数据采集，数据分析，特征工程，训练模型，模型评估等步骤。使用sklearn工具可以方便地进行特征工程和模型训练工作，在《使用sklearn做单机特征工程》中，我们最后留下了一些疑问：特征处理类都有三个方法fit、transform和fit_transform，fit方法居然和模型训练方法fit同名（不光同名，参数列表都一样），这难道都是巧合？&lt;br&gt;显然，这不是巧合，这正是sklearn的设计风格。我们能够更加优雅地使用sklearn进行特征工程和模型训练工作。此时，不妨从一个基本的数据挖掘场景入手：&lt;br&gt;
    
    </summary>
    
      <category term="sklearn学习" scheme="www.xiaoyb.cc/categories/sklearn%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="sklearn" scheme="www.xiaoyb.cc/tags/sklearn/"/>
    
      <category term="数据挖掘" scheme="www.xiaoyb.cc/tags/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/"/>
    
  </entry>
  
  <entry>
    <title>用sklearn做数据预处理</title>
    <link href="www.xiaoyb.cc/2017/06/06/%E7%94%A8sklearn%E5%81%9A%E6%95%B0%E6%8D%AE%E9%A2%84%E5%A4%84%E7%90%86/"/>
    <id>www.xiaoyb.cc/2017/06/06/用sklearn做数据预处理/</id>
    <published>2017-06-06T06:57:48.000Z</published>
    <updated>2017-07-23T13:24:50.764Z</updated>
    
    <content type="html"><![CDATA[<p>用sklearn做机器学习的时候，一直都是用的时候再去网上找资料，结果每次都要重新找，很麻烦。终于下决心好好总结一下，平时经常用的一些sklearn的东西（或其他相关知识），希望能写成一个系列的笔记。</p><h1 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h1><p>这次就总结下sklearn数据预处理。主要是别人博客的知识，汇总一下。<br>sklearn是一个常用的机器学习库，其中的sklearn.preprocessing模块包含了常用的预处理函数，包括数据的清洗，如缺失值和零值的填充，数据标准化，二值化和哑编码等。</p><h1 id="数据预处理"><a href="#数据预处理" class="headerlink" title="数据预处理"></a>数据预处理</h1><h2 id="1-标准化（均值去除和按方差比例缩放）"><a href="#1-标准化（均值去除和按方差比例缩放）" class="headerlink" title="1.标准化（均值去除和按方差比例缩放）"></a>1.标准化（均值去除和按方差比例缩放）</h2><p>将数据转化为均值为零，方差为一的数据，形如标准正态分布（高斯分布）。实际操作中，经常忽略特征数据的分布形状，移除每个特征均值，划分离散特征的标准差，从而等级化，进而实现数据中心化。在利用机器学习算法（例如SVM）的过程中，如果目标函数中的一个特征的方差的阶数的量级高于其他特征的方差，那么这一特征就会在目标函数中占主导地位，从而“淹没”其他特征的作用。<br>数据标准化的意义：</p><ol><li>消除量纲影响和变量自身变异大小和数值大小的影响。</li><li>数据同趋化，主要解决不同性质数据问题，对不同性质指标直接加总不能正确反映不同作用力的综合结果<h3 id="Z-score标准化"><a href="#Z-score标准化" class="headerlink" title="Z-score标准化"></a>Z-score标准化</h3>基于原始数据的均值（mean）和标准差（standard deviation）进行数据的标准化。<br>公式为：(X-mean)/std  （mean为均值，std为标准差）<br>计算时对每个属性/每列分别进行。<br>将数据按期属性（按列进行）减去其均值，并处以其方差。得到的结果是，对于每个属性/每列来说所有数据都聚集在0附近，方差为1。<br>用sklearn实现有两种方式：<br>1.使用sklearn.preprocessing.scale()函数，可以直接将给定数据进行标准化。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> sklearn <span class="keyword">import</span> preprocessing</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>X = np.array([[ <span class="number">1.</span>, <span class="number">-1.</span>,  <span class="number">2.</span>],</span><br><span class="line"><span class="meta">... </span>              [ <span class="number">2.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>],</span><br><span class="line"><span class="meta">... </span>              [ <span class="number">0.</span>,  <span class="number">1.</span>, <span class="number">-1.</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>X_scaled = preprocessing.scale(X)</span><br><span class="line"> </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>X_scaled                                          </span><br><span class="line">array([[ <span class="number">0.</span>  ..., <span class="number">-1.22</span>...,  <span class="number">1.33</span>...],</span><br><span class="line">       [ <span class="number">1.22</span>...,  <span class="number">0.</span>  ..., <span class="number">-0.26</span>...],</span><br><span class="line">       [<span class="number">-1.22</span>...,  <span class="number">1.22</span>..., <span class="number">-1.06</span>...]])</span><br><span class="line"> </span><br><span class="line">&gt;&gt;&gt;<span class="comment">#处理后数据的均值和方差</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>X_scaled.mean(axis=<span class="number">0</span>)</span><br><span class="line">array([ <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>])<span class="comment">#零均值</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>X_scaled.std(axis=<span class="number">0</span>)</span><br><span class="line">array([ <span class="number">1.</span>,  <span class="number">1.</span>,  <span class="number">1.</span>])<span class="comment">#单位方差</span></span><br></pre></td></tr></table></figure></li></ol><p>2.使用sklearn.preprocessing.StandardScaler类，使用该类的好处在于可以保存训练集中的参数（均值、方差）直接使用其对象转换测试集数据。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>scaler = preprocessing.StandardScaler().fit(X)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>scaler</span><br><span class="line">StandardScaler(copy=<span class="keyword">True</span>, with_mean=<span class="keyword">True</span>, with_std=<span class="keyword">True</span>)</span><br><span class="line"> </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>scaler.mean_                                      </span><br><span class="line">array([ <span class="number">1.</span> ...,  <span class="number">0.</span> ...,  <span class="number">0.33</span>...])</span><br><span class="line"> </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>scaler.std_                                       </span><br><span class="line">array([ <span class="number">0.81</span>...,  <span class="number">0.81</span>...,  <span class="number">1.24</span>...])</span><br><span class="line"> </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>scaler.transform(X)                               </span><br><span class="line">array([[ <span class="number">0.</span>  ..., <span class="number">-1.22</span>...,  <span class="number">1.33</span>...],</span><br><span class="line">       [ <span class="number">1.22</span>...,  <span class="number">0.</span>  ..., <span class="number">-0.26</span>...],</span><br><span class="line">       [<span class="number">-1.22</span>...,  <span class="number">1.22</span>..., <span class="number">-1.06</span>...]])</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">&gt;&gt;&gt;<span class="comment">#可以直接使用训练集对测试集数据进行转换</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>scaler.transform([[<span class="number">-1.</span>,  <span class="number">1.</span>, <span class="number">0.</span>]])                </span><br><span class="line">array([[<span class="number">-2.44</span>...,  <span class="number">1.22</span>..., <span class="number">-0.26</span>...]])</span><br></pre></td></tr></table></figure></p><h3 id="MinMax标准化-最小最大值标准化"><a href="#MinMax标准化-最小最大值标准化" class="headerlink" title="MinMax标准化(最小最大值标准化)"></a>MinMax标准化(最小最大值标准化)</h3><p>将数据缩放至给定的最小值与最大值之间，通常是０与１之间，可用MinMaxScaler实现。或者将最大的绝对值缩放至单位大小，可用MaxAbsScaler实现。<br>对原始数据的线性变换，使结果落到[0,1]区间，转换函数如下：<br>x ＝ (x - min)/(max - min)<br>max: 样本数据的最大值<br>min: 为样本数据的最小值<br>使用这种方法的目的包括：<br>1、对于方差非常小的属性可以增强其稳定性。<br>2、维持稀疏矩阵中为0的条目。<br>sklearn实现MinMax标准化：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>X_train = np.array([[ <span class="number">1.</span>, <span class="number">-1.</span>,  <span class="number">2.</span>],</span><br><span class="line"><span class="meta">... </span>                    [ <span class="number">2.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>],</span><br><span class="line"><span class="meta">... </span>                    [ <span class="number">0.</span>,  <span class="number">1.</span>, <span class="number">-1.</span>]])</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>min_max_scaler = preprocessing.MinMaxScaler()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>X_train_minmax = min_max_scaler.fit_transform(X_train)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>X_train_minmax</span><br><span class="line">array([[ <span class="number">0.5</span>       ,  <span class="number">0.</span>        ,  <span class="number">1.</span>        ],</span><br><span class="line">       [ <span class="number">1.</span>        ,  <span class="number">0.5</span>       ,  <span class="number">0.33333333</span>],</span><br><span class="line">       [ <span class="number">0.</span>        ,  <span class="number">1.</span>        ,  <span class="number">0.</span>        ]])</span><br><span class="line"> </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment">#将相同的缩放应用到测试集数据中</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>X_test = np.array([[ <span class="number">-3.</span>, <span class="number">-1.</span>,  <span class="number">4.</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>X_test_minmax = min_max_scaler.transform(X_test)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>X_test_minmax</span><br><span class="line">array([[<span class="number">-1.5</span>       ,  <span class="number">0.</span>        ,  <span class="number">1.66666667</span>]])</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment">#缩放因子等属性</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>min_max_scaler.scale_                             </span><br><span class="line">array([ <span class="number">0.5</span>       ,  <span class="number">0.5</span>       ,  <span class="number">0.33</span>...])</span><br><span class="line"> </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>min_max_scaler.min_                               </span><br><span class="line">array([ <span class="number">0.</span>        ,  <span class="number">0.5</span>       ,  <span class="number">0.33</span>...])</span><br></pre></td></tr></table></figure></p><p>MinMaxScaler()默认的缩放范围是（0,1）。在构造类对象的时候也可以直接指定最大最小值的范围：feature_range=(min, max)<br>例如：min_max_scaler = preprocessing.MinMaxScaler(feature_range=(min, max))</p><h3 id="MaxAbsScaler（绝对值最大标准化）"><a href="#MaxAbsScaler（绝对值最大标准化）" class="headerlink" title="MaxAbsScaler（绝对值最大标准化）"></a>MaxAbsScaler（绝对值最大标准化）</h3><p>与上述标准化方法相似，但是它通过除以最大值将训练集缩放至[-1,1]<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">X_train = np.array([[ <span class="number">1.</span>, <span class="number">-1.</span>,  <span class="number">2.</span>],  </span><br><span class="line">                     [ <span class="number">2.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>],  </span><br><span class="line">                    [ <span class="number">0.</span>,  <span class="number">1.</span>, <span class="number">-1.</span>]])  </span><br><span class="line">max_abs_scaler = preprocessing.MaxAbsScaler()  </span><br><span class="line">X_train_maxabs = max_abs_scaler.fit_transform(X_train)  </span><br><span class="line"><span class="comment"># doctest +NORMALIZE_WHITESPACE^, out: array([[ 0.5, -1.,  1. ], [ 1. , 0. ,  0. ],       [ 0. ,  1. , -0.5]])  </span></span><br><span class="line">X_test = np.array([[ <span class="number">-3.</span>, <span class="number">-1.</span>,  <span class="number">4.</span>]])  </span><br><span class="line">X_test_maxabs = max_abs_scaler.transform(X_test) <span class="comment">#out: array([[-1.5, -1. ,  2. ]])  </span></span><br><span class="line">max_abs_scaler.scale_  <span class="comment">#out: array([ 2.,  1.,  2.])</span></span><br></pre></td></tr></table></figure></p><h2 id="正则化（Normalization）规范化"><a href="#正则化（Normalization）规范化" class="headerlink" title="正则化（Normalization）规范化"></a>正则化（Normalization）规范化</h2><p>这个本人理解的不是很透，先把别人的结论放上来。而且从找到的资料来看，这个翻译比较模糊。<br>文档上说：Normalization is the process of scaling individual samples to have unit norm.<br>正则化的过程是将每个样本缩放到单位范数（每个样本的范数为1），如果后面要使用如二次型（点积）或者其它核方法计算两个样本之间的相似性这个方法会很有用。<br>将样本缩放成单位向量，标准化数据是针对特征来说的，而现在正则化是对样本来做的，是用样本数据除以他的范式。<br>sklearn实现使用preprocessing.normalize(x, norm = ‘l1’)方法，具体的参数说明详见sklearn文档<br><a href="http://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.normalize.html#sklearn.preprocessing.normalize" target="_blank" rel="noopener">http://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.normalize.html#sklearn.preprocessing.normalize</a><br>1.使用preprocessing.normalize()函数对指定数据进行转换：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>X = [[ <span class="number">1.</span>, <span class="number">-1.</span>,  <span class="number">2.</span>],</span><br><span class="line"><span class="meta">... </span>     [ <span class="number">2.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>],</span><br><span class="line"><span class="meta">... </span>     [ <span class="number">0.</span>,  <span class="number">1.</span>, <span class="number">-1.</span>]]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>X_normalized = preprocessing.normalize(X, norm=<span class="string">'l2'</span>)</span><br><span class="line"> </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>X_normalized                                      </span><br><span class="line">array([[ <span class="number">0.40</span>..., <span class="number">-0.40</span>...,  <span class="number">0.81</span>...],</span><br><span class="line">       [ <span class="number">1.</span>  ...,  <span class="number">0.</span>  ...,  <span class="number">0.</span>  ...],</span><br><span class="line">       [ <span class="number">0.</span>  ...,  <span class="number">0.70</span>..., <span class="number">-0.70</span>...]])</span><br></pre></td></tr></table></figure></p><p>2.使用processing.Normalizer()类实现对训练集和测试集的拟合和转换：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>normalizer = preprocessing.Normalizer().fit(X)  <span class="comment"># fit does nothing</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>normalizer</span><br><span class="line">Normalizer(copy=<span class="keyword">True</span>, norm=<span class="string">'l2'</span>)</span><br><span class="line"> </span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>normalizer.transform(X)                            </span><br><span class="line">array([[ <span class="number">0.40</span>..., <span class="number">-0.40</span>...,  <span class="number">0.81</span>...],</span><br><span class="line">       [ <span class="number">1.</span>  ...,  <span class="number">0.</span>  ...,  <span class="number">0.</span>  ...],</span><br><span class="line">       [ <span class="number">0.</span>  ...,  <span class="number">0.70</span>..., <span class="number">-0.70</span>...]])</span><br><span class="line"> </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>normalizer.transform([[<span class="number">-1.</span>,  <span class="number">1.</span>, <span class="number">0.</span>]])             </span><br><span class="line">array([[<span class="number">-0.70</span>...,  <span class="number">0.70</span>...,  <span class="number">0.</span>  ...]])</span><br></pre></td></tr></table></figure></p><p>对于l2 norm,变换后每个样本的各维特征的平方和为1。类似地，L1 norm则是变换后每个样本的各维特征的绝对值和为1。还有max norm，则是将每个样本的各维特征除以该样本各维特征的最大值.</p><h2 id="二值化（Binarization）"><a href="#二值化（Binarization）" class="headerlink" title="二值化（Binarization）"></a>二值化（Binarization）</h2><p>将数值型数据转化为布尔型的二值数据，可以设置一个阈值（threshold）<br>在sklearn中，sklearn.preprocessing.Binarizer函数可以实现<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>X = [[ <span class="number">1.</span>, <span class="number">-1.</span>,  <span class="number">2.</span>],</span><br><span class="line"><span class="meta">... </span>     [ <span class="number">2.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>],</span><br><span class="line"><span class="meta">... </span>     [ <span class="number">0.</span>,  <span class="number">1.</span>, <span class="number">-1.</span>]]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>binarizer = preprocessing.Binarizer().fit(X)  <span class="comment"># fit does nothing</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>binarizer</span><br><span class="line">Binarizer(copy=<span class="keyword">True</span>, threshold=<span class="number">0.0</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>binarizer.transform(X)</span><br><span class="line">array([[ <span class="number">1.</span>,  <span class="number">0.</span>,  <span class="number">1.</span>],</span><br><span class="line">       [ <span class="number">1.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>],</span><br><span class="line">       [ <span class="number">0.</span>,  <span class="number">1.</span>,  <span class="number">0.</span>]])</span><br></pre></td></tr></table></figure></p><p>而且还可以调整阈值<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>binarizer = preprocessing.Binarizer(threshold=<span class="number">1.1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>binarizer.transform(X)</span><br><span class="line">array([[ <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">1.</span>],</span><br><span class="line">       [ <span class="number">1.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>],</span><br><span class="line">       [ <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>]])</span><br></pre></td></tr></table></figure></p><h2 id="标签预处理（Label-preprocessing）"><a href="#标签预处理（Label-preprocessing）" class="headerlink" title="标签预处理（Label preprocessing）"></a>标签预处理（Label preprocessing）</h2><h3 id="标签二值化（Label-binarization）"><a href="#标签二值化（Label-binarization）" class="headerlink" title="标签二值化（Label binarization）"></a>标签二值化（Label binarization）</h3><p>LabelBinarizer通常用于通过一个多类标签（label）列表，创建一个label指示器矩阵<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>lb = preprocessing.LabelBinarizer()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lb.fit([<span class="number">1</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">2</span>])</span><br><span class="line">LabelBinarizer(neg_label=<span class="number">0</span>, pos_label=<span class="number">1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lb.classes_</span><br><span class="line">array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lb.transform([<span class="number">1</span>, <span class="number">6</span>])</span><br><span class="line">array([[<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">       [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>]])</span><br></pre></td></tr></table></figure></p><p>上例中每个实例中只有一个标签（label），LabelBinarizer也支持每个实例数据显示多个标签：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>lb.fit_transform([(<span class="number">1</span>, <span class="number">2</span>), (<span class="number">3</span>,)]) <span class="comment">#(1,2)实例中就包含两个label</span></span><br><span class="line">array([[<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>],</span><br><span class="line">       [<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lb.classes_</span><br><span class="line">array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br></pre></td></tr></table></figure></p><h3 id="标签编码（Label-encoding）"><a href="#标签编码（Label-encoding）" class="headerlink" title="标签编码（Label encoding）"></a>标签编码（Label encoding）</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> sklearn <span class="keyword">import</span> preprocessing</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>le = preprocessing.LabelEncoder()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>le.fit([<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">6</span>])</span><br><span class="line">LabelEncoder()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>le.classes_</span><br><span class="line">array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">6</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>le.transform([<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">6</span>])</span><br><span class="line">array([<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>le.inverse_transform([<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>])</span><br><span class="line">array([<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">6</span>])</span><br></pre></td></tr></table></figure><p>也可以用于非数值类型的标签到数值类型标签的转化：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>le = preprocessing.LabelEncoder()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>le.fit([<span class="string">"paris"</span>, <span class="string">"paris"</span>, <span class="string">"tokyo"</span>, <span class="string">"amsterdam"</span>])</span><br><span class="line">LabelEncoder()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(le.classes_)</span><br><span class="line">[<span class="string">'amsterdam'</span>, <span class="string">'paris'</span>, <span class="string">'tokyo'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>le.transform([<span class="string">"tokyo"</span>, <span class="string">"tokyo"</span>, <span class="string">"paris"</span>])</span><br><span class="line">array([<span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(le.inverse_transform([<span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>]))</span><br><span class="line">[<span class="string">'tokyo'</span>, <span class="string">'tokyo'</span>, <span class="string">'paris'</span>]</span><br></pre></td></tr></table></figure></p><h2 id="离散变量编码"><a href="#离散变量编码" class="headerlink" title="离散变量编码"></a>离散变量编码</h2><p>例如性别有‘男’， ‘女’，然而计算机的许多模型都只能在数值型数据当中进行计算，如果我们简单的将‘男’为1，‘女’为0，虽然也可以完成转换，但是在转换的过程当中我们引入了大小关系，就是‘女’ &lt; ‘男’，这会对后续模型应用造成不必要的困扰。<br>解决方法为OneHotEncode，就是将其转化为二进制串，除了当前值所在位置为1，其他全部为0，如[0,0,1,0,0], [0,1,0,0,0].。性别可表示为男为[1,0]，女为[0,1]，这样一个性别特征就转化成了两个特征。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">df = pd.DataFrame(&#123;<span class="string">'pet'</span>: [<span class="string">'cat'</span>, <span class="string">'dog'</span>, <span class="string">'dog'</span>, <span class="string">'fish'</span>],<span class="string">'age'</span>: [<span class="number">4</span> , <span class="number">6</span>, <span class="number">3</span>, <span class="number">3</span>],</span><br><span class="line"><span class="string">'salary'</span>:[<span class="number">4</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">1</span>]&#125;)</span><br><span class="line"><span class="comment">#例如有数据比较大，OneHotEncoder会生成非常多的特征，或者为字符串数据，先转化为数字，所以先用LabelEncoder处理。</span></span><br><span class="line">label = preprocessing.LabelEncoder()</span><br><span class="line">df[<span class="string">'pet'</span>] = label.fit_transform(df[<span class="string">'pet'</span>])</span><br><span class="line">one_hot = preprocessing.OneHotEncoder(sparse = <span class="keyword">False</span>)</span><br><span class="line"><span class="keyword">print</span> one_hot.fit_transform(df[[<span class="string">'pet'</span>]])</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">before</span><br><span class="line">   age  pet  salary</span><br><span class="line">0    4    0       4</span><br><span class="line">1    6    1       5</span><br><span class="line">2    3    1       1</span><br><span class="line">3    3    2       1</span><br><span class="line">after</span><br><span class="line">[[ 1.  0.  0.]</span><br><span class="line"> [ 0.  1.  0.]</span><br><span class="line"> [ 0.  1.  0.]</span><br><span class="line"> [ 0.  0.  1.]]</span><br></pre></td></tr></table></figure><h2 id="缺失值处理"><a href="#缺失值处理" class="headerlink" title="缺失值处理"></a>缺失值处理</h2><p>sklearn中的Imputer类提供了一些基本的方法来处理缺失值，如使用均值、中位值或者缺失值所在列中频繁出现的值来替换。<br>例如使用均值来处理的实例：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> numpy <span class="keyword">as</span> np  </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> Imputer  </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>imp = Imputer(missing_values=<span class="string">'NaN'</span>, strategy=<span class="string">'mean'</span>, axis=<span class="number">0</span>)  </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>imp.fit([[<span class="number">1</span>, <span class="number">2</span>], [np.nan, <span class="number">3</span>], [<span class="number">7</span>, <span class="number">6</span>]])  </span><br><span class="line">Imputer(axis=<span class="number">0</span>, copy=<span class="keyword">True</span>, missing_values=<span class="string">'NaN'</span>, strategy=<span class="string">'mean'</span>, verbose=<span class="number">0</span>)  </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>X = [[np.nan, <span class="number">2</span>], [<span class="number">6</span>, np.nan], [<span class="number">7</span>, <span class="number">6</span>]]  </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(imp.transform(X))                             </span><br><span class="line">[[ <span class="number">4.</span>          <span class="number">2.</span>        ]  </span><br><span class="line"> [ <span class="number">6.</span>          <span class="number">3.666</span>...]  </span><br><span class="line"> [ <span class="number">7.</span>          <span class="number">6.</span>        ]]</span><br></pre></td></tr></table></figure></p><p>Imputer也支持稀疏矩阵作为输入：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> scipy.sparse <span class="keyword">as</span> sp</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>X = sp.csc_matrix([[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">0</span>, <span class="number">3</span>], [<span class="number">7</span>, <span class="number">6</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>imp = Imputer(missing_values=<span class="number">0</span>, strategy=<span class="string">'mean'</span>, axis=<span class="number">0</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>imp.fit(X)</span><br><span class="line">Imputer(axis=<span class="number">0</span>, copy=<span class="keyword">True</span>, missing_values=<span class="number">0</span>, strategy=<span class="string">'mean'</span>, verbose=<span class="number">0</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>X_test = sp.csc_matrix([[<span class="number">0</span>, <span class="number">2</span>], [<span class="number">6</span>, <span class="number">0</span>], [<span class="number">7</span>, <span class="number">6</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(imp.transform(X_test))                      </span><br><span class="line">[[ <span class="number">4.</span>          <span class="number">2.</span>        ]</span><br><span class="line"> [ <span class="number">6.</span>          <span class="number">3.666</span>...]</span><br><span class="line"> [ <span class="number">7.</span>          <span class="number">6.</span>        ]]</span><br></pre></td></tr></table></figure></p><h2 id="维度拓展"><a href="#维度拓展" class="headerlink" title="维度拓展"></a>维度拓展</h2><p>考虑复杂化非线性特征，就是生成多项式特征，例如(x1,x2)−&gt;(x1,x2,x21,x1x2,x22)，会使特征数量增加<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">poly = PolynomialFeatures(<span class="number">2</span>)<span class="comment">#参数为阶数</span></span><br><span class="line">poly.fit_transform(X) </span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">before </span></span><br><span class="line"><span class="string">[[0, 1],</span></span><br><span class="line"><span class="string"> [2, 3],</span></span><br><span class="line"><span class="string"> [4, 5]]</span></span><br><span class="line"><span class="string">after</span></span><br><span class="line"><span class="string">[[  1.,   0.,   1.,   0.,   0.,   1.],</span></span><br><span class="line"><span class="string"> [  1.,   2.,   3.,   4.,   6.,   9.],</span></span><br><span class="line"><span class="string"> [  1.,   4.,   5.,  16.,  20.,  25.]]</span></span><br></pre></td></tr></table></figure></p><p>参考：<br><a href="http://scikit-learn.org/stable/modules/preprocessing.html#preprocessing-normalization" target="_blank" rel="noopener">http://scikit-learn.org/stable/modules/preprocessing.html#preprocessing-normalization</a><br><a href="http://blog.csdn.net/u010787640/article/details/60956164" target="_blank" rel="noopener">http://blog.csdn.net/u010787640/article/details/60956164</a><br><a href="http://blog.csdn.net/shmily_skx/article/details/52946414" target="_blank" rel="noopener">http://blog.csdn.net/shmily_skx/article/details/52946414</a><br><a href="http://www.cnblogs.com/chaosimple/p/4153167.html" target="_blank" rel="noopener">http://www.cnblogs.com/chaosimple/p/4153167.html</a><br><a href="http://blog.csdn.net/csmqq/article/details/51461696" target="_blank" rel="noopener">http://blog.csdn.net/csmqq/article/details/51461696</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;用sklearn做机器学习的时候，一直都是用的时候再去网上找资料，结果每次都要重新找，很麻烦。终于下决心好好总结一下，平时经常用的一些sklearn的东西（或其他相关知识），希望能写成一个系列的笔记。&lt;/p&gt;
&lt;h1 id=&quot;概要&quot;&gt;&lt;a href=&quot;#概要&quot; class=
      
    
    </summary>
    
      <category term="sklearn学习" scheme="www.xiaoyb.cc/categories/sklearn%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="机器学习" scheme="www.xiaoyb.cc/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="sklearn" scheme="www.xiaoyb.cc/tags/sklearn/"/>
    
  </entry>
  
  <entry>
    <title>记一次坑爹的windows下安装xgboost的经历</title>
    <link href="www.xiaoyb.cc/2017/06/05/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%9D%91%E7%88%B9%E7%9A%84windows%E4%B8%8B%E5%AE%89%E8%A3%85xgboost%E7%9A%84%E7%BB%8F%E5%8E%86/"/>
    <id>www.xiaoyb.cc/2017/06/05/记一次坑爹的windows下安装xgboost的经历/</id>
    <published>2017-06-05T07:51:28.000Z</published>
    <updated>2017-07-23T13:24:50.765Z</updated>
    
    <content type="html"><![CDATA[<p>近来做一个比赛，一个识别鼠标轨迹是人还是机器的二分类问题。自己用SVM和神经网络等传统的机器学习的方法都试过了，但是提交之后的结果发现并不好。正好前几天研究过几个别人做的其他比赛的解决方案，发现用的boosting方法比较多,其中尤其是xgboost。于是打算再用xgboost的模型做一下，看看结果怎么样。<br>但是，安装xgboost的过程并不轻松。试了好几种方法，最后花了一下午时间，终于安装成功。<br><a id="more"></a></p><h1 id="1-使用纯命令行安装"><a href="#1-使用纯命令行安装" class="headerlink" title="1.使用纯命令行安装"></a>1.使用纯命令行安装</h1><p>参考：<a href="http://www.th7.cn/system/win/201603/157092.shtml" target="_blank" rel="noopener">http://www.th7.cn/system/win/201603/157092.shtml</a><br><a href="http://blog.csdn.net/ychanmy/article/details/50972530" target="_blank" rel="noopener">http://blog.csdn.net/ychanmy/article/details/50972530</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git clone --recursive https://github.com/dmlc/xgboost$ cd xgboost</span><br><span class="line">$ git submodule init</span><br><span class="line">$ git submodule update</span><br><span class="line">$cp make/mingw64.mk config.mk</span><br><span class="line">$make -j4</span><br><span class="line"></span><br><span class="line">$cd python-package</span><br><span class="line">$python setup.py install</span><br></pre></td></tr></table></figure></p><p>但是，为毛别人都能成功，我就是一直报错呢，而且google不到答案，哎。。。<br><img src="http://i.imgur.com/wMngVUt.png" alt=""><br>看来这个东西看人品的，没办法，找其他的办法吧！</p><h1 id="2-使用旧版本的xgboost"><a href="#2-使用旧版本的xgboost" class="headerlink" title="2.使用旧版本的xgboost"></a>2.使用旧版本的xgboost</h1><p>最终，在<a href="http://m.blog.csdn.net/article/details?id=53118803找到一个可用的解决方法。" target="_blank" rel="noopener">http://m.blog.csdn.net/article/details?id=53118803找到一个可用的解决方法。</a><br>下载旧版本的xgboost,<a href="http://download.csdn.net/detail/zhuqiuhui/9476012" target="_blank" rel="noopener">http://download.csdn.net/detail/zhuqiuhui/9476012</a><br>然后就很简单。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$cd xgboost</span><br><span class="line">$make -j4</span><br><span class="line"></span><br><span class="line">$cd python-package</span><br><span class="line">$python setup.py install</span><br></pre></td></tr></table></figure></p><p><img src="http://i.imgur.com/9VfyKQV.png" alt=""><br>终于！不知道旧版本的xgbosot有没有什么问题，先用用试试吧！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;近来做一个比赛，一个识别鼠标轨迹是人还是机器的二分类问题。自己用SVM和神经网络等传统的机器学习的方法都试过了，但是提交之后的结果发现并不好。正好前几天研究过几个别人做的其他比赛的解决方案，发现用的boosting方法比较多,其中尤其是xgboost。于是打算再用xgboost的模型做一下，看看结果怎么样。&lt;br&gt;但是，安装xgboost的过程并不轻松。试了好几种方法，最后花了一下午时间，终于安装成功。&lt;br&gt;
    
    </summary>
    
      <category term="大数据比赛" scheme="www.xiaoyb.cc/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%AF%94%E8%B5%9B/"/>
    
    
      <category term="xgboost" scheme="www.xiaoyb.cc/tags/xgboost/"/>
    
  </entry>
  
  <entry>
    <title>sklearn PCA降维</title>
    <link href="www.xiaoyb.cc/2017/06/01/sklearn-PCA%E9%99%8D%E7%BB%B4/"/>
    <id>www.xiaoyb.cc/2017/06/01/sklearn-PCA降维/</id>
    <published>2017-06-01T10:01:31.000Z</published>
    <updated>2017-07-23T13:24:50.759Z</updated>
    
    <content type="html"><![CDATA[<p>对于太多的特征，一般需要进行降维处理。PCA是最常用的降维的方法，sklearn提供了PCA降维的方法。</p><h1 id="函数原型"><a href="#函数原型" class="headerlink" title="函数原型"></a>函数原型</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class sklearn.decomposition.PCA(n_components=None, copy=True, whiten=False, svd_solver=&apos;auto&apos;, tol=0.0, iterated_power=&apos;auto&apos;, random_state=None)</span><br></pre></td></tr></table></figure><a id="more"></a><h1 id="主要参数"><a href="#主要参数" class="headerlink" title="主要参数"></a>主要参数</h1><ol><li>n_components:<br>意义：PCA算法中所要保留的主成分个数n，也即保留下来的特征个数n<br>类型：int 或者 string，缺省时默认为None，所有成分被保留。<br> 赋值为int，比如n_components=1，将把原始数据降到一个维度。<br> 赋值为string，比如n_components=’mle’，将自动选取特征个数n，使得满足所要求的方差百分比。</li><li>copy:<br>类型：bool，True或者False，缺省时默认为True。<br>意义：表示是否在运行算法时，将原始训练数据复制一份。若为True，则运行PCA算法后，原始训练数据的值不            会有任何改变，因为是在原始数据的副本上进行运算；若为False，则运行PCA算法后，原始训练数据的              值会改，因为是在原始数据上进行降维计算。</li><li>whiten:<br>类型：bool，缺省时默认为False<br>意义：白化，使得每个特征具有相同的方差。</li></ol><h1 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h1><p>和参数差不多，参考<a href="http://scikit-learn.org/stable/modules/generated/sklearn.decomposition.PCA.html" target="_blank" rel="noopener">http://scikit-learn.org/stable/modules/generated/sklearn.decomposition.PCA.html</a></p><h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><p>fit(X[, y]) —— Fit the model with X.<br>fit_transform(X[, y])—— Fit the model with X and apply the dimensionality reduction on X.<br>get_covariance() —— Compute data covariance with the generative model.<br>get_params([deep]) —— Get parameters for this estimator.<br>get_precision() —— Compute data precision matrix with the generative model.<br>inverse_transform(X) —— Transform data back to its original space, i.e.,<br>score(X[, y]) —— Return the average log-likelihood of all samples<br>score_samples(X) —— Return the log-likelihood of each sample<br>set_params(**params) —— Set the parameters of this estimator.<br>transform(X) —— Apply the dimensionality reduction on X.<br>详细说明：</p><ol><li>fit(X,y=None)<br>fit()可以说是scikit-learn中通用的方法，每个需要训练的算法都会有fit()方法，它其实就是算法中的“训练”这一步骤。因为PCA是无监督学习算法，此处y自然等于None。</li><li>fit(X)，表示用数据X来训练PCA模型。<br>函数返回值：调用fit方法的对象本身。比如pca.fit(X)，表示用X对pca这个对象进行训练。</li><li>fit_transform(X)<br>用X来训练PCA模型，同时返回降维后的数据。<br>newX=pca.fit_transform(X)，newX就是降维后的数据。</li><li>inverse_transform()<br>将降维后的数据转换成原始数据，X=pca.inverse_transform(newX)</li><li>transform(X)<br>将数据X转换成降维后的数据。当模型训练好后，对于新输入的数据，都可以用transform方法来降维。<br>此外，还有get_covariance()、get_precision()、get_params(deep=True)、score(X, y=None)等方法，参考上面的英文。<h1 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h1>以一组二维的数据data为例，data如下，一共12个样本（x,y），其实就是分布在直线y=x上的点，并且聚集在x=1、2、3、4上，各3个。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>data  </span><br><span class="line">array([[ <span class="number">1.</span>  ,  <span class="number">1.</span>  ],  </span><br><span class="line">       [ <span class="number">0.9</span> ,  <span class="number">0.95</span>],  </span><br><span class="line">       [ <span class="number">1.01</span>,  <span class="number">1.03</span>],  </span><br><span class="line">       [ <span class="number">2.</span>  ,  <span class="number">2.</span>  ],  </span><br><span class="line">       [ <span class="number">2.03</span>,  <span class="number">2.06</span>],  </span><br><span class="line">       [ <span class="number">1.98</span>,  <span class="number">1.89</span>],  </span><br><span class="line">       [ <span class="number">3.</span>  ,  <span class="number">3.</span>  ],  </span><br><span class="line">       [ <span class="number">3.03</span>,  <span class="number">3.05</span>],  </span><br><span class="line">       [ <span class="number">2.89</span>,  <span class="number">3.1</span> ],  </span><br><span class="line">       [ <span class="number">4.</span>  ,  <span class="number">4.</span>  ],  </span><br><span class="line">       [ <span class="number">4.06</span>,  <span class="number">4.02</span>],  </span><br><span class="line">       [ <span class="number">3.97</span>,  <span class="number">4.01</span>]])</span><br></pre></td></tr></table></figure></li></ol><p>data这组数据，有两个特征，因为两个特征是近似相等的，所以用一个特征就能表示了，即可以降到一维。下面就来看看怎么用sklearn中的PCA算法包。<br>（1）n_components设置为1，copy默认为True，可以看到原始数据data并未改变，newData是一维的，并且明显地将原始数据分成了四类。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> sklearn.decomposition <span class="keyword">import</span> PCA   </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pca=PCA(n_components=<span class="number">1</span>)  </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>newData=pca.fit_transform(data)  </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>newData  </span><br><span class="line">array([[<span class="number">-2.12015916</span>],  </span><br><span class="line">       [<span class="number">-2.22617682</span>],  </span><br><span class="line">       [<span class="number">-2.09185561</span>],  </span><br><span class="line">       [<span class="number">-0.70594692</span>],  </span><br><span class="line">       [<span class="number">-0.64227841</span>],  </span><br><span class="line">       [<span class="number">-0.79795758</span>],  </span><br><span class="line">       [ <span class="number">0.70826533</span>],  </span><br><span class="line">       [ <span class="number">0.76485312</span>],  </span><br><span class="line">       [ <span class="number">0.70139695</span>],  </span><br><span class="line">       [ <span class="number">2.12247757</span>],  </span><br><span class="line">       [ <span class="number">2.17900746</span>],  </span><br><span class="line">       [ <span class="number">2.10837406</span>]])  </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>data  </span><br><span class="line">array([[ <span class="number">1.</span>  ,  <span class="number">1.</span>  ],  </span><br><span class="line">       [ <span class="number">0.9</span> ,  <span class="number">0.95</span>],  </span><br><span class="line">       [ <span class="number">1.01</span>,  <span class="number">1.03</span>],  </span><br><span class="line">       [ <span class="number">2.</span>  ,  <span class="number">2.</span>  ],  </span><br><span class="line">       [ <span class="number">2.03</span>,  <span class="number">2.06</span>],  </span><br><span class="line">       [ <span class="number">1.98</span>,  <span class="number">1.89</span>],  </span><br><span class="line">       [ <span class="number">3.</span>  ,  <span class="number">3.</span>  ],  </span><br><span class="line">       [ <span class="number">3.03</span>,  <span class="number">3.05</span>],  </span><br><span class="line">       [ <span class="number">2.89</span>,  <span class="number">3.1</span> ],  </span><br><span class="line">       [ <span class="number">4.</span>  ,  <span class="number">4.</span>  ],  </span><br><span class="line">       [ <span class="number">4.06</span>,  <span class="number">4.02</span>],  </span><br><span class="line">       [ <span class="number">3.97</span>,  <span class="number">4.01</span>]])</span><br></pre></td></tr></table></figure></p><p>（2）将copy设置为False，原始数据data将发生改变。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>pca=PCA(n_components=<span class="number">1</span>,copy=<span class="keyword">False</span>)  </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>newData=pca.fit_transform(data)  </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>data  </span><br><span class="line">array([[<span class="number">-1.48916667</span>, <span class="number">-1.50916667</span>],  </span><br><span class="line">       [<span class="number">-1.58916667</span>, <span class="number">-1.55916667</span>],  </span><br><span class="line">       [<span class="number">-1.47916667</span>, <span class="number">-1.47916667</span>],  </span><br><span class="line">       [<span class="number">-0.48916667</span>, <span class="number">-0.50916667</span>],  </span><br><span class="line">       [<span class="number">-0.45916667</span>, <span class="number">-0.44916667</span>],  </span><br><span class="line">       [<span class="number">-0.50916667</span>, <span class="number">-0.61916667</span>],  </span><br><span class="line">       [ <span class="number">0.51083333</span>,  <span class="number">0.49083333</span>],  </span><br><span class="line">       [ <span class="number">0.54083333</span>,  <span class="number">0.54083333</span>],  </span><br><span class="line">       [ <span class="number">0.40083333</span>,  <span class="number">0.59083333</span>],  </span><br><span class="line">       [ <span class="number">1.51083333</span>,  <span class="number">1.49083333</span>],  </span><br><span class="line">       [ <span class="number">1.57083333</span>,  <span class="number">1.51083333</span>],  </span><br><span class="line">       [ <span class="number">1.48083333</span>,  <span class="number">1.50083333</span>]])</span><br></pre></td></tr></table></figure></p><p>（3）n_components设置为’mle’，看看效果，自动降到了1维。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>pca=PCA(n_components=<span class="string">'mle'</span>)  </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>newData=pca.fit_transform(data)  </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>newData  </span><br><span class="line">array([[<span class="number">-2.12015916</span>],  </span><br><span class="line">       [<span class="number">-2.22617682</span>],  </span><br><span class="line">       [<span class="number">-2.09185561</span>],  </span><br><span class="line">       [<span class="number">-0.70594692</span>],  </span><br><span class="line">       [<span class="number">-0.64227841</span>],  </span><br><span class="line">       [<span class="number">-0.79795758</span>],  </span><br><span class="line">       [ <span class="number">0.70826533</span>],  </span><br><span class="line">       [ <span class="number">0.76485312</span>],  </span><br><span class="line">       [ <span class="number">0.70139695</span>],  </span><br><span class="line">       [ <span class="number">2.12247757</span>],  </span><br><span class="line">       [ <span class="number">2.17900746</span>],  </span><br><span class="line">       [ <span class="number">2.10837406</span>]])</span><br></pre></td></tr></table></figure></p><p>（4）对象的属性值<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>pca.n_components  </span><br><span class="line"><span class="number">1</span>  </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pca.explained_variance_ratio_  </span><br><span class="line">array([ <span class="number">0.99910873</span>])  </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pca.explained_variance_  </span><br><span class="line">array([ <span class="number">2.55427003</span>])  </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pca.get_params  </span><br><span class="line">&lt;bound method PCA.get_params of PCA(copy=<span class="keyword">True</span>, n_components=<span class="number">1</span>, whiten=<span class="keyword">False</span>)&gt;</span><br></pre></td></tr></table></figure></p><p>我们所训练的pca对象的n_components值为1，即保留1个特征，该特征的方差为2.55427003，占所有特征的方差百分比为0.99910873，意味着几乎保留了所有的信息。get_params返回各个参数的值。<br>（5）对象的方法<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>newA=pca.transform(A)</span><br><span class="line">```  </span><br><span class="line">对新的数据A，用已训练好的pca模型进行降维。</span><br><span class="line">```python</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pca.set_params(copy=<span class="keyword">False</span>)  </span><br><span class="line">PCA(copy=<span class="keyword">False</span>, n_components=<span class="number">1</span>, whiten=<span class="keyword">False</span>)</span><br></pre></td></tr></table></figure></p><p>设置参数。</p><h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><p>在一个论坛上看到的例子<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#导入数值计算库</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="comment">#导入科学计算库</span></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="comment">#导入数据预处理库</span></span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> StandardScaler</span><br><span class="line"><span class="comment">#导入PCA算法库</span></span><br><span class="line"><span class="keyword">from</span> sklearn.decomposition <span class="keyword">import</span> PCA</span><br><span class="line"></span><br><span class="line"><span class="comment">#读取贷款状态数据从创建名为LoanStats3a的数据表</span></span><br><span class="line">LoanStats3a=pd.DataFrame(pd.read_csv(<span class="string">'LoanStats3a.csv'</span>))</span><br><span class="line"> </span><br><span class="line"><span class="comment">#查看数据表内容</span></span><br><span class="line">LoanStats3a.head()</span><br><span class="line"></span><br><span class="line"><span class="comment">#删除包含空值的特征</span></span><br><span class="line">LoanStats3a=LoanStats3a.dropna()</span><br><span class="line"></span><br><span class="line"><span class="comment">#设置特征表X</span></span><br><span class="line"><span class="comment">#将贷款数据表中的贷款特征数据单独提取出来，用于后面的降维操作。</span></span><br><span class="line">X = np.array(LoanStats3a[[<span class="string">'loan_amnt'</span>, <span class="string">'funded_amnt_inv'</span>, <span class="string">'installment'</span>,</span><br><span class="line"><span class="string">'annual_inc'</span>, <span class="string">'dti'</span>, <span class="string">'delinq_2yrs'</span>, <span class="string">'inq_last_6mths'</span>, <span class="string">'open_acc'</span>,</span><br><span class="line"><span class="string">'pub_rec'</span>, <span class="string">'revol_bal'</span>, <span class="string">'total_acc'</span>, <span class="string">'out_prncp'</span>, <span class="string">'out_prncp_inv'</span>,</span><br><span class="line"><span class="string">'total_pymnt'</span>, <span class="string">'total_pymnt_inv'</span>, <span class="string">'total_rec_prncp'</span>, <span class="string">'total_rec_int'</span>,</span><br><span class="line"><span class="string">'total_rec_late_fee'</span>, <span class="string">'recoveries'</span>, <span class="string">'collection_recovery_fee'</span>,</span><br><span class="line"><span class="string">'last_pymnt_amnt'</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment">#对特征数据进行标准化处理,去除不同数据的单位限制，将它们转化为无量纲的纯数值。</span></span><br><span class="line">sc = StandardScaler()</span><br><span class="line">X_std = sc.fit_transform(X)</span><br><span class="line"></span><br><span class="line"><span class="comment">#创建PCA对象，n_components=3</span></span><br><span class="line">pca = decomposition.PCA(n_components=<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#使用PCA对特征进行降维</span></span><br><span class="line">X_std_pca = pca.fit_transform(X_std)</span><br><span class="line"></span><br><span class="line"><span class="comment">#下面的写法与上面相同,下面进行了白化变换，数据还原之后进行了方差的归一化</span></span><br><span class="line">pca=PCA(n_components=<span class="number">6</span>,whiten=<span class="keyword">True</span>)</span><br><span class="line">pca.fit(X_std)</span><br><span class="line">newData=pca.transform(X_std)</span><br><span class="line">X=pca.inverse_transform(newData)</span><br></pre></td></tr></table></figure></p><p>本文参考：<a href="http://blog.csdn.net/u012162613/article/details/42192293" target="_blank" rel="noopener">http://blog.csdn.net/u012162613/article/details/42192293</a><br>        <a href="http://www.aboutyun.com/thread-21655-1-1.html" target="_blank" rel="noopener">http://www.aboutyun.com/thread-21655-1-1.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;对于太多的特征，一般需要进行降维处理。PCA是最常用的降维的方法，sklearn提供了PCA降维的方法。&lt;/p&gt;
&lt;h1 id=&quot;函数原型&quot;&gt;&lt;a href=&quot;#函数原型&quot; class=&quot;headerlink&quot; title=&quot;函数原型&quot;&gt;&lt;/a&gt;函数原型&lt;/h1&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;class sklearn.decomposition.PCA(n_components=None, copy=True, whiten=False, svd_solver=&amp;apos;auto&amp;apos;, tol=0.0, iterated_power=&amp;apos;auto&amp;apos;, random_state=None)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="sklearn学习" scheme="www.xiaoyb.cc/categories/sklearn%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="机器学习" scheme="www.xiaoyb.cc/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="sklearn" scheme="www.xiaoyb.cc/tags/sklearn/"/>
    
  </entry>
  
  <entry>
    <title>lightgbm python接口的安装</title>
    <link href="www.xiaoyb.cc/2017/05/31/lightgbm-python%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%AE%89%E8%A3%85/"/>
    <id>www.xiaoyb.cc/2017/05/31/lightgbm-python接口的安装/</id>
    <published>2017-05-31T10:32:15.000Z</published>
    <updated>2017-07-23T13:24:50.757Z</updated>
    
    <content type="html"><![CDATA[<p>最近看一些大数据比赛大神们开源的解决方案，发现他们经常使用所谓数据挖掘三驾马车。恶补了一下boosting方法.现在把lightgbm的python接口的安装过程记录下来，免得以后忘了。<br>LightGBM（Light Gradient Boosting Machine）是一个基于决策树算法的快速的、分布式的、高性能 gradient boosting（GBDT、GBRT、GBM 或 MART）框架，可被用于排行、分类以及其他许多机器学习任务中。<br>开源项目地址： <a href="https://github.com/Microsoft/LightGBM" target="_blank" rel="noopener">https://github.com/Microsoft/LightGBM</a><br><a id="more"></a><br>优势：</p><blockquote><p>更快的训练效率<br>低内存使用<br>更好的准确率<br>支持并行学习<br>可处理大规模数据</p></blockquote><h1 id="1-下载源码"><a href="#1-下载源码" class="headerlink" title="1.下载源码"></a>1.下载源码</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone --recursive https://github.com/Microsoft/LightGBM</span><br></pre></td></tr></table></figure><h1 id="2-编译dll"><a href="#2-编译dll" class="headerlink" title="2.编译dll"></a>2.编译dll</h1><p>进入下载的LightGBM目录下，用VS打开windows/LightGBM.sln，生成时选择DLL和x64，然后进行编译。dll文件就会在windows/x64/DLL/目录里。<br><img src="http://i.imgur.com/lRW0CwU.png" alt=""></p><h1 id="3-安装python包"><a href="#3-安装python包" class="headerlink" title="3.安装python包"></a>3.安装python包</h1><p>进入目录python-package，执行命令<br><code>python setup.py install</code></p><h1 id="4-测试是否安装成功"><a href="#4-测试是否安装成功" class="headerlink" title="4.测试是否安装成功"></a>4.测试是否安装成功</h1><p>进入examples\python-guide，执行样例<br><code>python .\simple_example.py</code><br>如果没有报错，那就说明安装成功了！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近看一些大数据比赛大神们开源的解决方案，发现他们经常使用所谓数据挖掘三驾马车。恶补了一下boosting方法.现在把lightgbm的python接口的安装过程记录下来，免得以后忘了。&lt;br&gt;LightGBM（Light Gradient Boosting Machine）是一个基于决策树算法的快速的、分布式的、高性能 gradient boosting（GBDT、GBRT、GBM 或 MART）框架，可被用于排行、分类以及其他许多机器学习任务中。&lt;br&gt;开源项目地址： &lt;a href=&quot;https://github.com/Microsoft/LightGBM&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/Microsoft/LightGBM&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="机器学习" scheme="www.xiaoyb.cc/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="机器学习" scheme="www.xiaoyb.cc/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="数据挖掘" scheme="www.xiaoyb.cc/tags/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/"/>
    
  </entry>
  
  <entry>
    <title>hexo个人域名配置</title>
    <link href="www.xiaoyb.cc/2017/05/31/hexo%E4%B8%AA%E4%BA%BA%E5%9F%9F%E5%90%8D%E9%85%8D%E7%BD%AE/"/>
    <id>www.xiaoyb.cc/2017/05/31/hexo个人域名配置/</id>
    <published>2017-05-31T09:20:02.000Z</published>
    <updated>2017-07-23T13:24:50.755Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-在万网上购买域名"><a href="#1-在万网上购买域名" class="headerlink" title="1.在万网上购买域名"></a>1.在万网上购买域名</h1><p><a href="https://wanwang.aliyun.com" target="_blank" rel="noopener">https://wanwang.aliyun.com</a>  或者其他域名购买网站</p><h1 id="2-配置域名解析"><a href="#2-配置域名解析" class="headerlink" title="2.配置域名解析"></a>2.配置域名解析</h1><p>进入你的管理后台<br><a id="more"></a><br><img src="http://i.imgur.com/8TZJ4q9.png" alt="管理后台"></p><h1 id="3-添加域名解析"><a href="#3-添加域名解析" class="headerlink" title="3.添加域名解析"></a>3.添加域名解析</h1><p>按下图所示添加域名解析。<br><img src="http://i.imgur.com/sRLsOBt.png" alt="添加域名解析"><br>其中，记录类型选A或CNAME，A记录的记录值就是ip地址，github(官方文档)提供了两个IP地址，192.30.252.153和192.30.252.154，这两个IP地址为github的服务器地址，两个都要填上，解析记录设置两个www和@，线路就默认就行了，CNAME记录值填你的github博客网址。</p><h1 id="4-创建CNAME文件"><a href="#4-创建CNAME文件" class="headerlink" title="4.创建CNAME文件"></a>4.创建CNAME文件</h1><p> 这些全部设置完成后，此时你并不能要申请的域名访问你的博客。接着你需要做的是在hexo根目录的source文件夹里创建CNAME文件，不带任何后缀，里面添加你的域名信息，如：xiaoyb.me。</p><h1 id="5-发布并访问"><a href="#5-发布并访问" class="headerlink" title="5.发布并访问"></a>5.发布并访问</h1><p>重新发布hexo d -g然后就可以访问你的新域名了。<br>快点试试吧！</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-在万网上购买域名&quot;&gt;&lt;a href=&quot;#1-在万网上购买域名&quot; class=&quot;headerlink&quot; title=&quot;1.在万网上购买域名&quot;&gt;&lt;/a&gt;1.在万网上购买域名&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://wanwang.aliyun.com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://wanwang.aliyun.com&lt;/a&gt;  或者其他域名购买网站&lt;/p&gt;
&lt;h1 id=&quot;2-配置域名解析&quot;&gt;&lt;a href=&quot;#2-配置域名解析&quot; class=&quot;headerlink&quot; title=&quot;2.配置域名解析&quot;&gt;&lt;/a&gt;2.配置域名解析&lt;/h1&gt;&lt;p&gt;进入你的管理后台&lt;br&gt;
    
    </summary>
    
      <category term="hexo" scheme="www.xiaoyb.cc/categories/hexo/"/>
    
    
      <category term="hexo" scheme="www.xiaoyb.cc/tags/hexo/"/>
    
      <category term="域名" scheme="www.xiaoyb.cc/tags/%E5%9F%9F%E5%90%8D/"/>
    
  </entry>
  
  <entry>
    <title>eclipse下创建maven webapp项目</title>
    <link href="www.xiaoyb.cc/2017/04/22/eclipse%E4%B8%8B%E5%88%9B%E5%BB%BAmaven-webapp%E9%A1%B9%E7%9B%AE/"/>
    <id>www.xiaoyb.cc/2017/04/22/eclipse下创建maven-webapp项目/</id>
    <published>2017-04-22T08:17:03.000Z</published>
    <updated>2017-07-23T13:24:50.755Z</updated>
    
    <content type="html"><![CDATA[<p>1、开启eclipse，右键new——》other，如下图找到maven project<br><a id="more"></a><br><img src="http://i.imgur.com/tLozsmT.jpg" alt=""><br>2、选择maven project，显示创建maven项目的窗口，勾选如图所示，Create a simple project<br><img src="http://i.imgur.com/8RBxu5E.jpg" alt=""><br>3、输入maven项目的基本信息，如下图所示：<br><img src="http://i.imgur.com/m69rSeD.jpg" alt=""><br>4、完成maven项目的创建，生成相应的maven项目结果，如下所示，此处有部分结构是项目不需要的，我们需要去掉：<br><img src="http://i.imgur.com/MzkoXcz.jpg" alt=""><br>5、选择项目，右键选择Properties，进入属性页面，选择到Maven菜单下，如下图所示：<br><img src="http://i.imgur.com/wMgDBuy.jpg" alt=""><br>6、选择java版本为1.7，并去掉其他两项，如下图：<br><img src="http://i.imgur.com/SXeVRQJ.jpg" alt=""><br>7、点击ok之后，再次回到项目结构，此时项目结构比较清晰，符合我们想要创建的maven项目<br><img src="http://i.imgur.com/335DCN2.jpg" alt=""><br>8、此时webapp下的结果还没有显示出来，因为此时我们还没有配置此的项目为web项目，再次进去Properties配置，如下图所示：<br><img src="http://i.imgur.com/rNzAT8S.jpg" alt=""><br>9、点击Further configuration available…，如下：<br><img src="http://i.imgur.com/ZD9GThf.jpg" alt=""><br>10、配置src/main/webapp，并勾选生成web.xml的选项，如下：<br><img src="http://i.imgur.com/WRO3v9x.jpg" alt=""><br>11、确定之后，返回到maven菜单下去掉Dynamic Web Module的勾选，点击ok，如下所示，webapp目录结构显示出来了：<br><img src="http://i.imgur.com/XMUM5u7.jpg" alt=""><br>12、此时还需要配置，src/main/webapp为“/”项目的根目录，如下所示：<br><img src="http://i.imgur.com/VfwJFIP.jpg" alt=""><br>13、完成如上配置后，最后完成maven webapp项目结构如下图所示：<br><img src="http://i.imgur.com/ZNSDos7.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;1、开启eclipse，右键new——》other，如下图找到maven project&lt;br&gt;
    
    </summary>
    
      <category term="javaweb" scheme="www.xiaoyb.cc/categories/javaweb/"/>
    
    
      <category term="maven" scheme="www.xiaoyb.cc/tags/maven/"/>
    
      <category term="javaweb" scheme="www.xiaoyb.cc/tags/javaweb/"/>
    
  </entry>
  
  <entry>
    <title>为什么新生代需要两个Survivor区</title>
    <link href="www.xiaoyb.cc/2017/04/12/%E4%B8%BA%E4%BB%80%E4%B9%88%E6%96%B0%E7%94%9F%E4%BB%A3%E9%9C%80%E8%A6%81%E4%B8%A4%E4%B8%AASurvivor%E5%8C%BA/"/>
    <id>www.xiaoyb.cc/2017/04/12/为什么新生代需要两个Survivor区/</id>
    <published>2017-04-12T14:14:32.000Z</published>
    <updated>2017-07-23T13:24:50.759Z</updated>
    
    <content type="html"><![CDATA[<p>在JVM的新生代内存中，为什么除了Eden区，还要设置两个Survivor区？</p><h1 id="为什么要有Survivor区"><a href="#为什么要有Survivor区" class="headerlink" title="为什么要有Survivor区"></a>为什么要有Survivor区</h1><p>先不去想为什么有两个Survivor区，第一个问题是，设置Survivor区的意义在哪里？<br><a id="more"></a><br>堆内存分类<br><img src="http://i.imgur.com/SYmUFnA.png" alt="堆内存分类"><br>如果没有Survivor，Eden区每进行一次Minor GC，存活的对象就会被送到老年代。老年代很快被填满，触发Major GC（因为Major GC一般伴随着Minor GC，也可以看做触发了Full GC）。老年代的内存空间远大于新生代，进行一次Full GC消耗的时间比Minor GC长得多。你也许会问，执行时间长有什么坏处？频发的Full GC消耗的时间是非常可观的，这一点会影响大型程序的执行和响应速度，更不要说某些连接会因为超时发生连接错误了。</p><p>好，那我们来想想在没有Survivor的情况下，有没有什么解决办法，可以避免上述情况：<br><img src="http://i.imgur.com/e1qd82c.png" alt=""><br>显而易见，没有Survivor的话，上述两种解决方案都不能从根本上解决问题。</p><p>我们可以得到第一条结论：<font color="red" size="2"><strong>Survivor的存在意义，就是减少被送到老年代的对象，进而减少Full GC的发生，Survivor的预筛选保证，只有经历16次Minor GC还能在新生代中存活的对象，才会被送到老年代。</strong></font></p><h1 id="为什么要设置两个Survivor区"><a href="#为什么要设置两个Survivor区" class="headerlink" title="为什么要设置两个Survivor区"></a>为什么要设置两个Survivor区</h1><font color="red" size="2"><strong>设置两个Survivor区最大的好处就是解决了碎片化</strong></font><p>下面我们来分析一下。</p><p>为什么一个Survivor区不行？第一部分中，我们知道了必须设置Survivor区。假设现在只有一个survivor区，我们来模拟一下流程：<br>刚刚新建的对象在Eden中，一旦Eden满了，触发一次Minor GC，Eden中的存活对象就会被移动到Survivor区。这样继续循环下去，下一次Eden满了的时候，问题来了，此时进行Minor GC，Eden和Survivor各有一些存活对象，如果此时把Eden区的存活对象硬放到Survivor区，很明显这两部分对象所占有的内存是不连续的，也就导致了内存碎片化。<br>我绘制了一幅图来表明这个过程。其中色块代表对象，白色框分别代表Eden区（大）和Survivor区（小）。Eden区理所当然大一些，否则新建对象很快就导致Eden区满，进而触发Minor GC，有悖于初衷。<br><img src="http://i.imgur.com/NmSEUK3.png" alt=""><br>一个Survivor区带来碎片化</p><p>碎片化带来的风险是极大的，严重影响Java程序的性能。堆空间被散布的对象占据不连续的内存，最直接的结果就是，堆中没有足够大的连续内存空间，接下去如果程序需要给一个内存需求很大的对象分配内存。。。画面太美不敢看。。。这就好比我们爬山的时候，背包里所有东西紧挨着放，最后就可能省出一块完整的空间放相机。如果每件行李之间隔一点空隙乱放，很可能最后就要一路把相机挂在脖子上了。</p><p>那么，顺理成章的，应该建立两块Survivor区，刚刚新建的对象在Eden中，经历一次Minor GC，Eden中的存活对象就会被移动到第一块survivor space S0，Eden被清空；等Eden区再满了，就再触发一次Minor GC，Eden和S0中的存活对象又会被复制送入第二块survivor space S1（这个过程非常重要，因为这种复制算法保证了S1中来自S0和Eden两部分的存活对象占用连续的内存空间，避免了碎片化的发生）。S0和Eden被清空，然后下一轮S0与S1交换角色，如此循环往复。如果对象的复制次数达到16次，该对象就会被送到老年代中。下图中每部分的意义和上一张图一样，就不加注释了。<br><img src="http://i.imgur.com/Y0x3nl1.png" alt=""><br>两块Survivor避免碎片化<br>上述机制最大的好处就是，整个过程中，永远有一个survivor space是空的，另一个非空的survivor space无碎片。</p><p>那么，Survivor为什么不分更多块呢？比方说分成三个、四个、五个?显然，如果Survivor区再细分下去，每一块的空间就会比较小，很容易导致Survivor区满，因此，我认为两块Survivor区是经过权衡之后的最佳方案。</p><p>转自：<a href="http://blog.csdn.net/antony9118/article/details/51425581" target="_blank" rel="noopener">http://blog.csdn.net/antony9118/article/details/51425581</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在JVM的新生代内存中，为什么除了Eden区，还要设置两个Survivor区？&lt;/p&gt;
&lt;h1 id=&quot;为什么要有Survivor区&quot;&gt;&lt;a href=&quot;#为什么要有Survivor区&quot; class=&quot;headerlink&quot; title=&quot;为什么要有Survivor区&quot;&gt;&lt;/a&gt;为什么要有Survivor区&lt;/h1&gt;&lt;p&gt;先不去想为什么有两个Survivor区，第一个问题是，设置Survivor区的意义在哪里？&lt;br&gt;
    
    </summary>
    
      <category term="java虚拟机" scheme="www.xiaoyb.cc/categories/java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
      <category term="java虚拟机" scheme="www.xiaoyb.cc/tags/java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
      <category term="垃圾回收" scheme="www.xiaoyb.cc/tags/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"/>
    
  </entry>
  
</feed>
